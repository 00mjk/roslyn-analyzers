<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ru" original="../ApiReviewAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidCallingProblematicMethodsTitle">
        <source>Avoid calling problematic methods</source>
        <target state="translated">Избегайте вызова проблемных методов</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsDescription">
        <source>A member calls a potentially dangerous or problematic method.</source>
        <target state="translated">Член вызывает потенциально опасный или проблемный метод.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemGCCollect">
        <source>Remove the call to GC.Collect from {0}. It is usually unnecessary to force garbage collection, and doing so can severely degrade performance.</source>
        <target state="translated">Удалите вызов GC.Collect из {0}. В общем случае принудительная сборка мусора не требуется, кроме того, она может существенно снизить производительность.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemThreadingThreadResume">
        <source>Remove the call to Thread.Resume from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</source>
        <target state="translated">Удалите вызов Thread.Resume из {0}. Приостановка и возобновление работы потоков могут быть опасны, если система в это время выполняет критическую операцию, например, выполняется конструктор класса важного системного типа или определяются параметры безопасности для общей сборки.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemThreadingThreadSuspend">
        <source>Remove the call to Thread.Suspend from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</source>
        <target state="translated">Удалите вызов Thread.Suspend из {0}. Приостановка и возобновление работы потоков могут быть опасны, если система в это время выполняет критическую операцию, например, выполняется конструктор класса важного системного типа или определяются параметры безопасности для общей сборки.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemTypeInvokeMember">
        <source>Remove the call to System.Type.InvokeMember with BindingFlags.NonPublic from {0}. Taking a dependency on a private member increases the chance of a breaking change in the future.</source>
        <target state="translated">Удалите вызов System.Type.InvokeMember с BindingFlags.NonPublic из {0}. Использование зависимости от частных членов повышает риск критического изменения в будущем.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageCoInitializeSecurity">
        <source>{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called after the runtime has been initialized. The workaround is to write an unmanaged shim that will call the routine and then activate and call into managed code. You can do this using an export from a mixed-mode C++ DLL, by registering a managed component for use by COM, or by using the runtime hosting API.</source>
        <target state="translated">{0} — объявление PInvoke для интерфейса OLE32 API, который не может быть надежно вызван после инициализации среды выполнения. Обходной путь заключается в том, чтобы написать неуправляемый модификатор, который будет вызывать подпрограмму, а затем активировать и вызывать управляемый код. Это можно сделать с помощью экспорта из библиотеки DLL C++ смешанного режима, с помощью регистрации управляемого компонента для использования в модели COM или с помощью API для размещения среды выполнения</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageCoSetProxyBlanket">
        <source>{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called against a runtime callable wrapper (a managed object wrapping a COM object). Runtime callable wrappers dynamically fetch interface pointers so the effect of the call might be arbitrarily lost. Runtime callable wrappers for a given COM object are also shared across an application domain so the call could possibly affect other users. Replace this call with a native wrapper COM object for the interface pointer that does the appropriate CoSetProxyBlanket calls.</source>
        <target state="translated">{0} — объявление PInvoke для интерфейса OLE32 API, который не может быть надежно вызван при использовании вызываемой оболочки времени выполнения (управляемый объект, используемый в качестве оболочки для COM-объекта). Вызываемые оболочки времени выполнения динамически извлекают указатели на интерфейс, поэтому результат вызова может быть произвольно потерян. Вызываемые оболочки времени выполнения для указанного COM-объекта также находятся в режиме общего доступа в пределах домена приложения, поэтому вызов вполне может затронуть других пользователей. Замените этот вызов COM-объектом в машинной оболочке для указателя интерфейса, который выполняет соответствующие вызовы CoSetProxyBlanket.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemRuntimeInteropServicesSafeHandleDangerousGetHandle">
        <source>Remove the call to SafeHandle.DangerousGetHandle from {0}.</source>
        <target state="translated">Удалите вызов SafeHandle.DangerousGetHandle из {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFrom">
        <source>Remove the call to Assembly.LoadFrom from {0}.</source>
        <target state="translated">Удалите вызов Assembly.LoadFrom из {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFile">
        <source>Remove the call to Assembly.LoadFile from {0}.</source>
        <target state="translated">Удалите вызов Assembly.LoadFile из {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadWithPartialName">
        <source>Remove the call to Assembly.LoadWithPartialName from {0}.</source>
        <target state="translated">Удалите вызов Assembly.LoadWithPartialName из {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="CategoryReliability">
        <source>Reliability</source>
        <target state="translated">Надежность</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>