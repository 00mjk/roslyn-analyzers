[33mcommit 952610f99824fda66b26fd446686811d47f0d210[m
Merge: 6114195 e24e274
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Wed Jun 17 10:51:29 2015 -0700

    fix merge conflict in rules

[33mcommit e24e2747835cb2a81af071cf5302e72e6aeffeb2[m
Merge: 43b3379 425a41b
Author: Jessica Petty <jessica.petty@colorado.edu>
Date:   Wed Jun 17 10:42:11 2015 -0700

    Merge pull request #24 from jepetty/InitializeWork
    
    Initialize work

[33mcommit 425a41beb117f9d6f40fe2808146c9ae7f2827cc[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Wed Jun 17 10:34:12 2015 -0700

    change message for InvalidStatementRule: explain why invalid

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 5cd6e59..88f9a5f 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -196,8 +196,8 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
         public const string InvalidStatement = "MetaAnalyzer020";[m
         internal static DiagnosticDescriptor InvalidStatementRule = new DiagnosticDescriptor([m
             id: InvalidStatement,[m
[31m-            title: "The initialize method should only register actions",[m
[31m-            messageFormat: "'{0}' is an invalid statement",[m
[32m+[m[32m            title: "The Initialize method only registers actions: the statement is invalid",[m
[32m+[m[32m            messageFormat: "The Initialize method only registers actions: the statement '{0}' is invalid",[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m

[33mcommit 6114195650789eea20ea140bd6604fe9fe93fbe9[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Tue Jun 16 16:25:20 2015 -0700

    finish rule declaration fixes, added tutorial to code fix message

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1mindex b4a5013..a0f531d 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[36m@@ -49,26 +49,26 @@[m [mpublic sealed override FixAllProvider GetFixAllProvider()[m
                 if (diagnostic.Id.Equals(MetaCompilationAnalyzer.MissingId))[m
                 {[m
                     ClassDeclarationSyntax declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<ClassDeclarationSyntax>().First();[m
[31m-                    context.RegisterCodeFix(CodeAction.Create("Each diagnostic must have a unique id identifying it from other diagnostics",[m
[32m+[m[32m                    context.RegisterCodeFix(CodeAction.Create("Tutorial: Each diagnostic must have a unique id identifying it from other diagnostics",[m
                         c => MissingIdAsync(context.Document, declaration, c)), diagnostic);[m
                 }[m
 [m
                 if (diagnostic.Id.Equals(MetaCompilationAnalyzer.MissingInit))[m
                 {[m
                     ClassDeclarationSyntax declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<ClassDeclarationSyntax>().First();[m
[31m-                    context.RegisterCodeFix(CodeAction.Create("Each analyzer must have an Initialize method to register actions to be performed when changes occur", c => MissingInitAsync(context.Document, declaration, c)), diagnostic);[m
[32m+[m[32m                    context.RegisterCodeFix(CodeAction.Create("Tutorial: Each analyzer must have an Initialize method to register actions to be performed when changes occur", c => MissingInitAsync(context.Document, declaration, c)), diagnostic);[m
                 }[m
 [m
                 if (diagnostic.Id.Equals(MetaCompilationAnalyzer.MissingRegisterStatement))[m
                 {[m
                     MethodDeclarationSyntax declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<MethodDeclarationSyntax>().First();[m
[31m-                    context.RegisterCodeFix(CodeAction.Create("The Initialize method must register an action to be performed when changes occur", c => MissingRegisterAsync(context.Document, declaration, c)), diagnostic);[m
[32m+[m[32m                    context.RegisterCodeFix(CodeAction.Create("Tutorial: The Initialize method must register an action to be performed when changes occur", c => MissingRegisterAsync(context.Document, declaration, c)), diagnostic);[m
                 }[m
 [m
                 if (diagnostic.Id.Equals(MetaCompilationAnalyzer.TooManyInitStatements))[m
                 {[m
                     MethodDeclarationSyntax declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<MethodDeclarationSyntax>().First();[m
[31m-                    context.RegisterCodeFix(CodeAction.Create("The Initialize method must not contain multiple actions to register (for the purpose of this tutorial)", c => MultipleStatementsAsync(context.Document, declaration, c)), diagnostic);[m
[32m+[m[32m                    context.RegisterCodeFix(CodeAction.Create("Tutorial: The Initialize method must not contain multiple actions to register (for the purpose of this tutorial)", c => MultipleStatementsAsync(context.Document, declaration, c)), diagnostic);[m
                 }[m
             }[m
         }[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex da75664..f0f9736 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -110,15 +110,6 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
 [m
[31m-        public const string IncorrectInitStatement = "MetaAnalyzer005";[m
[31m-        internal static DiagnosticDescriptor IncorrectInitStatementRule = new DiagnosticDescriptor([m
[31m-            id: IncorrectInitStatement,[m
[31m-            title: "This statement needs to register for a supported action",[m
[31m-            messageFormat: "This statement needs to register for a supported action",[m
[31m-            category: "Syntax",[m
[31m-            defaultSeverity: DiagnosticSeverity.Error,[m
[31m-            isEnabledByDefault: true);[m
[31m-[m
         public const string IncorrectInitSig = "MetaAnalyzer006";[m
         internal static DiagnosticDescriptor IncorrectInitSigRule = new DiagnosticDescriptor([m
             id: IncorrectInitSig,[m
[36m@@ -128,7 +119,7 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
 [m
[31m-        public const string InvalidStatement = "MetaAnalyzer020";[m
[32m+[m[32m        public const string InvalidStatement = "MetaAnalyzer005";[m
         internal static DiagnosticDescriptor InvalidStatementRule = new DiagnosticDescriptor([m
             id: InvalidStatement,[m
             title: "The statement is invalid for the Initialize method",[m
[36m@@ -211,7 +202,6 @@[m [mpublic override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
                                              MissingInitRule, [m
                                              MissingRegisterRule, [m
                                              TooManyInitStatementsRule, [m
[31m-                                             IncorrectInitStatementRule, [m
                                              IncorrectInitSigRule,[m
                                              MissingSuppDiagRule,[m
                                              IncorrectSigSuppDiagRule,[m
[36m@@ -365,7 +355,7 @@[m [minternal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context[m
                     }[m
                     else[m
                     {[m
[31m-                        ReportDiagnostic(context, IncorrectInitStatementRule, invocationExpression.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                        ReportDiagnostic(context, InvalidStatementRule, invocationExpression.GetLocation(), invocationExpression);[m
                     }[m
                 }[m
                 else[m
[36m@@ -918,40 +908,40 @@[m [minternal List<object> InitializeBody(CompilationAnalysisContext context, SyntaxL[m
                 var invocationExpr = statement.Expression as InvocationExpressionSyntax;[m
                 if (invocationExpr == null)[m
                 {[m
[31m-                    ReportDiagnostic(context, InvalidStatementRule, statement.GetLocation(), statements[0]);[m
[32m+[m[32m                    ReportDiagnostic(context, InvalidStatementRule, statements[0].GetLocation(), statements[0]);[m
                     return null;[m
                 }[m
 [m
                 var memberExpr = invocationExpr.Expression as MemberAccessExpressionSyntax;[m
                 if (memberExpr == null)[m
                 {[m
[31m-                    ReportDiagnostic(context, InvalidStatementRule, invocationExpr.GetLocation(), statements[0]);[m
[32m+[m[32m                    ReportDiagnostic(context, InvalidStatementRule, statements[0].GetLocation(), statements[0]);[m
                     return null;[m
                 }[m
 [m
                 var memberExprContext = memberExpr.Expression as IdentifierNameSyntax;[m
                 if (memberExprContext == null)[m
                 {[m
[31m-                    ReportDiagnostic(context, InvalidStatementRule, memberExpr.GetLocation(), statements[0]);[m
[32m+[m[32m                    ReportDiagnostic(context, InvalidStatementRule, statements[0].GetLocation(), statements[0]);[m
                     return null;[m
                 }[m
 [m
                 if (memberExprContext.Identifier.Text != "context")[m
                 {[m
[31m-                    ReportDiagnostic(context, InvalidStatementRule, memberExprContext.GetLocation(), statements[0]);[m
[32m+[m[32m                    ReportDiagnostic(context, InvalidStatementRule, statements[0].GetLocation(), statements[0]);[m
                     return null;[m
                 }[m
 [m
                 var memberExprRegister = memberExpr.Name as IdentifierNameSyntax;[m
                 if (memberExprRegister == null)[m
                 {[m
[31m-                    ReportDiagnostic(context, InvalidStatementRule, memberExpr.GetLocation(), statements[0]);[m
[32m+[m[32m                    ReportDiagnostic(context, InvalidStatementRule, statements[0].GetLocation(), statements[0]);[m
                     return null;[m
                 }[m
 [m
                 if (!_branchesDict.ContainsKey(memberExprRegister.ToString()))[m
                 {[m
[31m-                    ReportDiagnostic(context, InvalidStatementRule, memberExprRegister.GetLocation(), statements[0]);[m
[32m+[m[32m                    ReportDiagnostic(context, InvalidStatementRule, statements[0].GetLocation(), statements[0]);[m
                     return null;[m
                 }[m
 [m

[33mcommit 338c0fb97b72b682c50771fcf51ba76c14b150df[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Tue Jun 16 16:04:27 2015 -0700

    change initialize and id rules to differentiate message and title, fixed signature when those diagnostics are reported

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1mindex 02382ba..b4a5013 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[36m@@ -51,7 +51,6 @@[m [mpublic sealed override FixAllProvider GetFixAllProvider()[m
                     ClassDeclarationSyntax declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<ClassDeclarationSyntax>().First();[m
                     context.RegisterCodeFix(CodeAction.Create("Each diagnostic must have a unique id identifying it from other diagnostics",[m
                         c => MissingIdAsync(context.Document, declaration, c)), diagnostic);[m
[31m-[m
                 }[m
 [m
                 if (diagnostic.Id.Equals(MetaCompilationAnalyzer.MissingInit))[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 5cd6e59..da75664 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -75,8 +75,8 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
         public const string MissingId = "MetaAnalyzer001";[m
         internal static DiagnosticDescriptor MissingIdRule = new DiagnosticDescriptor([m
             id: MissingId,[m
[31m-            title: "You are missing a diagnostic id",[m
[31m-            messageFormat: "You are missing a diagnostic id",[m
[32m+[m[32m            title: "The analyzer is missing a diagnostic id",[m
[32m+[m[32m            messageFormat: "The analyzer '{0}' is missing a diagnostic id",[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
[36m@@ -86,8 +86,8 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
         public const string MissingInit = "MetaAnalyzer002";[m
         internal static DiagnosticDescriptor MissingInitRule = new DiagnosticDescriptor([m
             id: MissingInit,[m
[31m-            title: "You are missing the required Initialize method",[m
[31m-            messageFormat: "You are missing the required Initialize method",[m
[32m+[m[32m            title: "The analyzer is missing the required Initialize method",[m
[32m+[m[32m            messageFormat: "The analyzer '{0}' is missing the required Initialize method",[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
[36m@@ -95,8 +95,8 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
         public const string MissingRegisterStatement = "MetaAnalyzer003";[m
         internal static DiagnosticDescriptor MissingRegisterRule = new DiagnosticDescriptor([m
             id: MissingRegisterStatement,[m
[31m-            title: "You need to register an action within the Initialize method",[m
[31m-            messageFormat: "You need to register an action within the Initialize method",[m
[32m+[m[32m            title: "An action must be registered within the method",[m
[32m+[m[32m            messageFormat: "An action must be registered within the '{0}' method",[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
[36m@@ -104,8 +104,8 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
         public const string TooManyInitStatements = "MetaAnalyzer004";[m
         internal static DiagnosticDescriptor TooManyInitStatementsRule = new DiagnosticDescriptor([m
             id: TooManyInitStatements,[m
[31m-            title: "Please only have one statement within Initiailize. You will only be registering one action.",[m
[31m-            messageFormat: "Please only have one statement within Initiailize. You will only be registering one action.",[m
[32m+[m[32m            title: "The method registers multiple actions",[m
[32m+[m[32m            messageFormat: "The method '{0}' registers multiple actions",[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
[36m@@ -122,8 +122,17 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
         public const string IncorrectInitSig = "MetaAnalyzer006";[m
         internal static DiagnosticDescriptor IncorrectInitSigRule = new DiagnosticDescriptor([m
             id: IncorrectInitSig,[m
[31m-            title: "The signature for the Initialize method is incorrect",[m
[31m-            messageFormat: "The signature for the Initialize method is incorrect",[m
[32m+[m[32m            title: "The signature for the method is incorrect",[m
[32m+[m[32m            messageFormat: "The signature for the '{0}' method is incorrect",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public const string InvalidStatement = "MetaAnalyzer020";[m
[32m+[m[32m        internal static DiagnosticDescriptor InvalidStatementRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: InvalidStatement,[m
[32m+[m[32m            title: "The statement is invalid for the Initialize method",[m
[32m+[m[32m            messageFormat: "The statement '{0}' is invalid for the Initialize method",[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
[36m@@ -192,15 +201,6 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
[31m-[m
[31m-        public const string InvalidStatement = "MetaAnalyzer020";[m
[31m-        internal static DiagnosticDescriptor InvalidStatementRule = new DiagnosticDescriptor([m
[31m-            id: InvalidStatement,[m
[31m-            title: "The initialize method should only register actions",[m
[31m-            messageFormat: "'{0}' is an invalid statement",[m
[31m-            category: "Syntax",[m
[31m-            defaultSeverity: DiagnosticSeverity.Error,[m
[31m-            isEnabledByDefault: true);[m
         #endregion[m
 [m
         public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[36m@@ -360,8 +360,7 @@[m [minternal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context[m
                         else[m
                         {[m
                             // diagnostic for missing id names[m
[31m-                           var analyzerClassSyntax = _analyzerClassSymbol.DeclaringSyntaxReferences[0].GetSyntax() as ClassDeclarationSyntax;[m
[31m-                           ReportDiagnostic(context, MissingIdRule, analyzerClassSyntax.Identifier.GetLocation(), MissingIdRule.MessageFormat);[m
[32m+[m[32m                           ReportDiagnostic(context, MissingIdRule, _analyzerClassSymbol.Locations[0], _analyzerClassSymbol.Name.ToString());[m
                         }[m
                     }[m
                     else[m
[36m@@ -736,7 +735,6 @@[m [minternal List<string> CheckIds(string branch, string kind, CompilationAnalysisCo[m
             }[m
 [m
             //returns a symbol for the register call, and a list of the arguments[m
[31m-            //assumes that there is only one thing registered[m
             internal List<object> CheckInitialize(CompilationAnalysisContext context)[m
             {[m
                 //default values for returning[m
[36m@@ -747,7 +745,7 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                 if (_initializeSymbol == null)[m
                 {[m
                     //the initialize method was not found[m
[31m-                    ReportDiagnostic(context, MissingInitRule, _analyzerClassSymbol.Locations[0], MissingInitRule.MessageFormat);[m
[32m+[m[32m                    ReportDiagnostic(context, MissingInitRule, _analyzerClassSymbol.Locations[0], _analyzerClassSymbol.Name.ToString());[m
                     return new List<object>(new object[] { registerCall, registerArgs });[m
                 }[m
                 else[m
[36m@@ -763,7 +761,7 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                     if (statements.Count == 0)[m
                     {[m
                         //no statements inside initiailize[m
[31m-                        ReportDiagnostic(context, MissingRegisterRule, _initializeSymbol.Locations[0], MissingRegisterRule.MessageFormat);[m
[32m+[m[32m                        ReportDiagnostic(context, MissingRegisterRule, _initializeSymbol.Locations[0], _initializeSymbol.Name.ToString());[m
                         return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                     }[m
                     else if (statements.Count > 1)[m
[36m@@ -819,7 +817,7 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                             if (statements.Count() > 1)[m
                             {[m
                                 //too many statements inside initialize[m
[31m-                                ReportDiagnostic(context, TooManyInitStatementsRule, statements[0].GetLocation(), TooManyInitStatementsRule.MessageFormat);[m
[32m+[m[32m                                ReportDiagnostic(context, TooManyInitStatementsRule, _initializeSymbol.Locations[0], _initializeSymbol.Name.ToString());[m
                                 return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                             }[m
                         }[m
[36m@@ -853,7 +851,7 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                         SeparatedSyntaxList<ArgumentSyntax> arguments = invocationExpr.ArgumentList.Arguments;[m
                         if (arguments == null)[m
                         {[m
[31m-                            ReportDiagnostic(context, IncorrectInitStatementRule, memberExpr.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            ReportDiagnostic(context, InvalidStatementRule, memberExpr.GetLocation(), memberExpr.Name.ToString());[m
                             return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
                         if (arguments.Count() > 0)[m
[36m@@ -884,9 +882,11 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
             internal BlockSyntax InitializeOverview(CompilationAnalysisContext context)[m
             {[m
                 ImmutableArray<IParameterSymbol> parameters = _initializeSymbol.Parameters;[m
[31m-                if (parameters.Count() != 1 || parameters[0].Type != context.Compilation.GetTypeByMetadataName("Microsoft.CodeAnalysis.Diagnostics.AnalysisContext") || parameters[0].Name != "context" || _initializeSymbol.DeclaredAccessibility != Accessibility.Public || !_initializeSymbol.IsOverride || !_initializeSymbol.ReturnsVoid)[m
[32m+[m[32m                if (parameters.Count() != 1 || parameters[0].Type != context.Compilation.GetTypeByMetadataName("Microsoft.CodeAnalysis.Diagnostics.AnalysisContext")[m[41m [m
[32m+[m[32m                    || parameters[0].Name != "context" || _initializeSymbol.DeclaredAccessibility != Accessibility.Public[m[41m [m
[32m+[m[32m                    || !_initializeSymbol.IsOverride || !_initializeSymbol.ReturnsVoid)[m
                 {[m
[31m-                    ReportDiagnostic(context, IncorrectInitSigRule, _initializeSymbol.Locations[0], MissingInitRule.MessageFormat);[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectInitSigRule, _initializeSymbol.Locations[0], _initializeSymbol.Name.ToString());[m
                     return null;[m
                 }[m
 [m
[36m@@ -911,45 +911,47 @@[m [minternal List<object> InitializeBody(CompilationAnalysisContext context, SyntaxL[m
                 var statement = statements[0] as ExpressionStatementSyntax;[m
                 if (statement == null)[m
                 {[m
[31m-                    ReportDiagnostic(context, IncorrectInitStatementRule, statements[0].GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                    ReportDiagnostic(context, InvalidStatementRule, statements[0].GetLocation(), statements[0]);[m
                     return null;[m
                 }[m
 [m
                 var invocationExpr = statement.Expression as InvocationExpressionSyntax;[m
                 if (invocationExpr == null)[m
                 {[m
[31m-                    ReportDiagnostic(context, IncorrectInitStatementRule, statement.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                    ReportDiagnostic(context, InvalidStatementRule, statement.GetLocation(), statements[0]);[m
                     return null;[m
                 }[m
 [m
                 var memberExpr = invocationExpr.Expression as MemberAccessExpressionSyntax;[m
                 if (memberExpr == null)[m
                 {[m
[31m-                    ReportDiagnostic(context, IncorrectInitStatementRule, invocationExpr.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                    ReportDiagnostic(context, InvalidStatementRule, invocationExpr.GetLocation(), statements[0]);[m
                     return null;[m
                 }[m
 [m
                 var memberExprContext = memberExpr.Expression as IdentifierNameSyntax;[m
                 if (memberExprContext == null)[m
                 {[m
[31m-                    ReportDiagnostic(context, IncorrectInitStatementRule, memberExpr.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                    ReportDiagnostic(context, InvalidStatementRule, memberExpr.GetLocation(), statements[0]);[m
                     return null;[m
                 }[m
[32m+[m
                 if (memberExprContext.Identifier.Text != "context")[m
                 {[m
[31m-                    ReportDiagnostic(context, IncorrectInitStatementRule, memberExprContext.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                    ReportDiagnostic(context, InvalidStatementRule, memberExprContext.GetLocation(), statements[0]);[m
                     return null;[m
                 }[m
 [m
                 var memberExprRegister = memberExpr.Name as IdentifierNameSyntax;[m
                 if (memberExprRegister == null)[m
                 {[m
[31m-                    ReportDiagnostic(context, IncorrectInitStatementRule, memberExpr.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                    ReportDiagnostic(context, InvalidStatementRule, memberExpr.GetLocation(), statements[0]);[m
                     return null;[m
                 }[m
[32m+[m
                 if (!_branchesDict.ContainsKey(memberExprRegister.ToString()))[m
                 {[m
[31m-                    ReportDiagnostic(context, IncorrectInitStatementRule, memberExprRegister.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                    ReportDiagnostic(context, InvalidStatementRule, memberExprRegister.GetLocation(), statements[0]);[m
                     return null;[m
                 }[m
 [m

[33mcommit a91b7a69dea3284b5f6f6c857a682e4b79a990d4[m
Merge: 1524d75 0e000fd
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Tue Jun 16 15:15:17 2015 -0700

    fix merge conflict in test

[33mcommit 1524d751a1918b4fc3e4467bb506b05ef8ea8067[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Tue Jun 16 15:09:52 2015 -0700

    Add test for missingRegisterStatement

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex cf5f94b..fe2fba3 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -172,7 +172,7 @@[m [mpublic override void Initialize(AnalysisContext context)[m
             VerifyCSharpFix(test, fixtest);[m
         }[m
 [m
[31m-        // test for missing Initialize method[m
[32m+[m[32m        // test for missingInit[m
         [TestMethod][m
         public void TestMethod4()[m
         {[m
[36m@@ -246,6 +246,7 @@[m [mpublic override void Initialize(AnalysisContext context)[m
             VerifyCSharpFix(test, fixtest);[m
         }[m
 [m
[32m+[m[32m        //Check missingRegisterStatement (no statements)[m
         [TestMethod][m
         public void TestMethod5()[m
         {[m
[36m@@ -279,25 +280,7 @@[m [mpublic override void Initialize(AnalysisContext context)[m
 [m
         private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
         {[m
[31m-            var ifStatement = (IfStatementSyntax)context.Node;[m
[31m-            var ifKeyword = ifStatement.IfKeyword;[m
[31m-            var openParen = ifStatement.OpenParenToken;[m
[31m-            var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[31m-[m
[31m-            if (ifKeyword.HasTrailingTrivia)[m
[31m-            {[m
[31m-                var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[31m-                if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[31m-                {[m
[31m-                    if (trailingTrivia.ToString() == "" "")[m
[31m-                    {[m
[31m-                        return;[m
[31m-                    }[m
[31m-                }[m
[31m-            }[m
[31m-[m
[31m-            var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-            context.ReportDiagnostic(diagnostic);[m
[32m+[m[32m            throw new NotImplementedException();[m
         }[m
     }[m
 }";[m
[36m@@ -306,10 +289,47 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
                 Id = MetaCompilationAnalyzer.MissingRegisterStatement,[m
                 Message = "You need to register an action within the Initialize method",[m
                 Severity = DiagnosticSeverity.Error,[m
[31m-                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 35, 30) }[m
[32m+[m[32m                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 25, 30) }[m
             };[m
 [m
             VerifyCSharpDiagnostic(test, expected);[m
[32m+[m
[32m+[m[32m            var fixTest = @"using System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Collections.Immutable;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m[32musing Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Text;[m
[32m+[m
[32m+[m[32mnamespace SyntaxNodeAnalyzer[m
[32m+[m[32m{[m
[32m+[m[32m    [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[32m+[m[32m    public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m    {[m
[32m+[m[32m        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new NotImplementedException();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public override void Initialize(AnalysisContext context)[m
[32m+[m[32m        {[m
[32m+[m[32m            context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m        {[m
[32m+[m[32m            throw new NotImplementedException();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}";[m
[32m+[m[32m            VerifyCSharpFix(test, fixTest);[m
         }[m
 [m
         protected override CodeFixProvider GetCSharpCodeFixProvider()[m

[33mcommit b7eba49c98593701f5c3024a4646bbc883ec68f7[m
Merge: 11709f3 43b3379
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Tue Jun 16 14:38:44 2015 -0700

    fix merge conflicts in unit test

[33mcommit 0e000fd653bce77e3cd101eabd85434587c6c38e[m
Merge: f13220b 43b3379
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Tue Jun 16 12:55:29 2015 -0700

    fix merge conflict

[33mcommit 43b3379843edda544e886832f5f2ae994f73dd2f[m
Merge: a6dd2b2 4165268
Author: Jessica Petty <jessica.petty@colorado.edu>
Date:   Tue Jun 16 11:42:24 2015 -0700

    Merge pull request #20 from jepetty/TestMissingId
    
    Test missing

[33mcommit 416526834e8d62d917e92321eef27fde212228e3[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Tue Jun 16 11:40:21 2015 -0700

    Fixed unit tests and code fix

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex dd4550c..5e32792 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -161,20 +161,21 @@[m [mpublic override void Initialize(AnalysisContext context)[m
         public void TestMethod4()[m
         {[m
             var test = @"using System;[m
[31m-using System.Collections.Generic;[m
[31m-            using System.Collections;[m
[31m-            using System.Linq;[m
[31m-            using System.Threading;[m
[31m-            using Microsoft.CodeAnalysis;[m
[31m-            using Microsoft.CodeAnalysis.CSharp;[m
[31m-            using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[31m-            using Microsoft.CodeAnalysis.Diagnostics;[m
[31m-            using Microsoft.CodeAnalysis.Text;[m
[32m+[m[32m    using System.Collections.Generic;[m
[32m+[m[32m    using System.Collections;[m
[32m+[m[32m    using System.Collections.Immutable;[m
[32m+[m[32m    using System.Linq;[m
[32m+[m[32m    using System.Threading;[m
[32m+[m[32m    using Microsoft.CodeAnalysis;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.Text;[m
 [m
[31m-namespace SyntaxNodeAnalyzer[m
[32m+[m[32m    namespace SyntaxNodeAnalyzer[m
     {[m
         [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[31m-        public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m        public class SyntaxNodeAnalyzer : DiagnosticAnalyzer[m
         {[m
             public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
             {[m
[36m@@ -190,15 +191,15 @@[m [mpublic override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
                 Id = MetaCompilationAnalyzer.MissingInit,[m
                 Message = "You are missing the required Initialize method",[m
                 Severity = DiagnosticSeverity.Error,[m
[31m-                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 15, 22) }[m
[32m+[m[32m                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 16, 22) }[m
             };[m
 [m
             VerifyCSharpDiagnostic(test, expected);[m
 [m
[31m-            var fixtest = @"[m
[31m-    using System;[m
[32m+[m[32m            var fixtest = @"using System;[m
     using System.Collections.Generic;[m
     using System.Collections;[m
[32m+[m[32m    using System.Collections.Immutable;[m
     using System.Linq;[m
     using System.Threading;[m
     using Microsoft.CodeAnalysis;[m
[36m@@ -220,11 +221,11 @@[m [mpublic override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
                 }[m
             }[m
 [m
[31m-            public override void Initialize(AnalsisContext context)[m
[31m-            {[m
[31m-                context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[31m-            }[m
[32m+[m[32m        public override void Initialize(AnalysisContext context)[m
[32m+[m[32m        {[m
[32m+[m[32m            throw new NotImplementedException();[m
         }[m
[32m+[m[32m    }[m
     }";[m
             VerifyCSharpFix(test, fixtest);[m
         }[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1mindex 1de115b..0e922b1 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[36m@@ -69,14 +69,12 @@[m [mpublic sealed override FixAllProvider GetFixAllProvider()[m
         {[m
             SyntaxGenerator generator = SyntaxGenerator.GetGenerator(document);[m
             var type = SyntaxFactory.ParseTypeName("AnalysisContext");[m
[31m-            List<SyntaxNode> parameter = new List<SyntaxNode>();[m
[31m-            parameter.Add(generator.ParameterDeclaration("context", type));[m
[31m-            var voidDeclaration = SyntaxFactory.PredefinedType(SyntaxFactory.ParseToken("void"));[m
[31m-            var exceptionStatement = SyntaxFactory.ParseExpression("new NotImplementedException()");[m
[31m-            List<SyntaxNode> throwStatement = new List<SyntaxNode>();[m
[31m-            throwStatement.Add(generator.ThrowStatement(exceptionStatement));[m
[31m-            var initializeDeclaration = generator.MethodDeclaration("Initialize", parameters: parameter, returnType: voidDeclaration,[m
[31m-                accessibility: Accessibility.Public, modifiers: DeclarationModifiers.Override, statements: throwStatement);[m
[32m+[m[32m            var parameters = new[] { generator.ParameterDeclaration("context", type) };[m
[32m+[m[32m            SemanticModel semanticModel = await document.GetSemanticModelAsync();[m
[32m+[m[32m            INamedTypeSymbol notImplementedException = semanticModel.Compilation.GetTypeByMetadataName("System.NotImplementedException");[m
[32m+[m[32m            var statements = new[] { generator.ThrowStatement(generator.ObjectCreationExpression(notImplementedException)) };[m
[32m+[m[32m            var initializeDeclaration = generator.MethodDeclaration("Initialize", parameters: parameters,[m
[32m+[m[32m                accessibility: Accessibility.Public, modifiers: DeclarationModifiers.Override, statements: statements);[m
 [m
             var newClassDeclaration = generator.AddMembers(declaration, initializeDeclaration);[m
 [m

[33mcommit a6dd2b23cc6edcd142faaa4c7f9311913a62ca6d[m
Merge: a8657fb 5d6b878
Author: zoepetard <t-zopet@microsoft.com>
Date:   Tue Jun 16 11:39:37 2015 -0700

    Merge pull request #22 from zoepetard/checkRules-method-update
    
    Check rules method update

[33mcommit f13220bd8ddb0448c8df830ea7ceba6c9f417db1[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Tue Jun 16 11:01:33 2015 -0700

    add invalid statement diagnostic, code fix for too many statements

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1mindex 1de115b..63e3829 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[36m@@ -25,7 +25,10 @@[m [mpublic override ImmutableArray<string> FixableDiagnosticIds[m
             get[m
             {[m
                 //TODO: add any new rules[m
[31m-                return ImmutableArray.Create(MetaCompilationAnalyzer.MissingId, MetaCompilationAnalyzer.MissingInit, MetaCompilationAnalyzer.MissingRegisterStatement);[m
[32m+[m[32m                return ImmutableArray.Create(MetaCompilationAnalyzer.MissingId,[m[41m [m
[32m+[m[32m                    MetaCompilationAnalyzer.MissingInit,[m[41m [m
[32m+[m[32m                    MetaCompilationAnalyzer.MissingRegisterStatement,[m
[32m+[m[32m                    MetaCompilationAnalyzer.TooManyInitStatements);[m
             }[m
         }[m
 [m
[36m@@ -62,6 +65,12 @@[m [mpublic sealed override FixAllProvider GetFixAllProvider()[m
                     MethodDeclarationSyntax declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<MethodDeclarationSyntax>().First();[m
                     context.RegisterCodeFix(CodeAction.Create("The Initialize method must register an action to be performed when changes occur", c => MissingRegisterAsync(context.Document, declaration, c)), diagnostic);[m
                 }[m
[32m+[m
[32m+[m[32m                if (diagnostic.Id.Equals(MetaCompilationAnalyzer.TooManyInitStatements))[m
[32m+[m[32m                {[m
[32m+[m[32m                    MethodDeclarationSyntax declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<MethodDeclarationSyntax>().First();[m
[32m+[m[32m                    context.RegisterCodeFix(CodeAction.Create("The Initialize method must not contain multiple actions to register (for the purpose of this tutorial)", c => MultipleStatementsAsync(context.Document, declaration, c)), diagnostic);[m
[32m+[m[32m                }[m
             }[m
         }[m
 [m
[36m@@ -136,5 +145,46 @@[m [mpublic sealed override FixAllProvider GetFixAllProvider()[m
 [m
             return newDocument;[m
         }[m
[32m+[m
[32m+[m[32m        private async Task<Document> MultipleStatementsAsync(Document document, MethodDeclarationSyntax declaration, CancellationToken c)[m
[32m+[m[32m        {[m
[32m+[m[32m            var statements = declaration.Body.Statements;[m
[32m+[m
[32m+[m[32m            var newBlock = declaration.Body;[m
[32m+[m
[32m+[m[32m            foreach (ExpressionStatementSyntax statement in statements)[m
[32m+[m[32m            {[m
[32m+[m[32m                var expression = statement.Expression as InvocationExpressionSyntax;[m
[32m+[m[32m                var expressionStart = expression.Expression as MemberAccessExpressionSyntax;[m
[32m+[m[32m                if (expressionStart == null || expressionStart.Name == null ||[m
[32m+[m[32m                    expressionStart.Name.ToString() != "RegisterSyntaxNodeAction")[m
[32m+[m[32m                {[m
[32m+[m[32m                    statements = statements.Remove(statement);[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (expression.ArgumentList == null || expression.ArgumentList.Arguments.Count() != 2)[m
[32m+[m[32m                {[m
[32m+[m[32m                    statements = statements.Remove(statement);[m
[32m+[m[32m                }[m
[32m+[m[32m                var argumentMethod = expression.ArgumentList.Arguments[0].Expression as IdentifierNameSyntax;[m
[32m+[m[32m                var argumentKind = expression.ArgumentList.Arguments[1].Expression as MemberAccessExpressionSyntax;[m
[32m+[m[32m                var preArgumentKind = argumentKind.Expression as IdentifierNameSyntax;[m
[32m+[m[32m                if (argumentMethod.Identifier == null || argumentKind.Name == null || preArgumentKind.Identifier == null ||[m
[32m+[m[32m                    argumentMethod.Identifier.ValueText != "AnalyzeIfStatement" || argumentKind.Name.ToString() != "IfStatement" ||[m
[32m+[m[32m                    preArgumentKind.Identifier.ValueText != "SyntaxKind")[m
[32m+[m[32m                {[m
[32m+[m[32m                    statements = statements.Remove(statement);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            newBlock = newBlock.WithStatements(statements);[m
[32m+[m[32m            var newDeclaration = declaration.WithBody(newBlock);[m
[32m+[m
[32m+[m[32m            var root = await document.GetSyntaxRootAsync();[m
[32m+[m[32m            var newRoot = root.ReplaceNode(declaration, newDeclaration);[m
[32m+[m[32m            var newDocument = document.WithSyntaxRoot(newRoot);[m
[32m+[m
[32m+[m[32m            return newDocument;[m
[32m+[m[32m        }[m
     }[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 17fa8a6..ec207c8 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -183,6 +183,15 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public const string InvalidStatement = "MetaAnalyzer020";[m
[32m+[m[32m        internal static DiagnosticDescriptor InvalidStatementRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: InvalidStatement,[m
[32m+[m[32m            title: "The initialize method should only register actions",[m
[32m+[m[32m            messageFormat: "'{0}' is an invalid statement",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
         #endregion[m
 [m
         public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[36m@@ -205,7 +214,8 @@[m [mpublic override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
                                              MissingIdDeclarationRule, [m
                                              EnabledByDefaultErrorRule, [m
                                              DefaultSeverityErrorRule, [m
[31m-                                             InternalAndStaticErrorRule);[m
[32m+[m[32m                                             InternalAndStaticErrorRule,[m
[32m+[m[32m                                             InvalidStatementRule);[m
             }[m
         }[m
 [m
[36m@@ -703,9 +713,61 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                     }[m
                     else if (statements.Count > 1)[m
                     {[m
[31m-                        //too many statements inside initialize[m
[31m-                        ReportDiagnostic(context, TooManyInitStatementsRule, statements[0].GetLocation(), TooManyInitStatementsRule.MessageFormat);[m
[31m-                        return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
[32m+[m[32m                        foreach (var statement in statements)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            if (statement.Kind() != SyntaxKind.ExpressionStatement)[m
[32m+[m[32m                            {[m
[32m+[m[32m                                ReportDiagnostic(context, InvalidStatementRule, statement.GetLocation(), statement.ToString());[m
[32m+[m[32m                                statements = statements.Remove(statement);[m
[32m+[m[32m                                continue;[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        if (statements.Count() > 1)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            foreach (ExpressionStatementSyntax statement in statements)[m
[32m+[m[32m                            {[m
[32m+[m[32m                                var expression = statement.Expression as InvocationExpressionSyntax;[m
[32m+[m[32m                                if (expression == null)[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    ReportDiagnostic(context, InvalidStatementRule, statement.GetLocation(), statement.Expression);[m
[32m+[m[32m                                    statements = statements.Remove(statement);[m
[32m+[m[32m                                    continue;[m
[32m+[m[32m                                }[m
[32m+[m
[32m+[m[32m                                var expressionStart = expression.Expression as MemberAccessExpressionSyntax;[m
[32m+[m[32m                                if (expressionStart == null || expressionStart.Name == null)[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    ReportDiagnostic(context, InvalidStatementRule, statement.GetLocation(), statement.Expression);[m
[32m+[m[32m                                    statements = statements.Remove(statement);[m
[32m+[m[32m                                    continue;[m
[32m+[m[32m                                }[m
[32m+[m
[32m+[m[32m                                var preExpressionStart = expressionStart.Expression as IdentifierNameSyntax;[m
[32m+[m[32m                                if (preExpressionStart == null || preExpressionStart.Identifier == null ||[m
[32m+[m[32m                                    preExpressionStart.Identifier.ValueText != "context")[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    ReportDiagnostic(context, InvalidStatementRule, statement.GetLocation(), statement.Expression);[m
[32m+[m[32m                                    statements = statements.Remove(statement);[m
[32m+[m[32m                                    continue;[m
[32m+[m[32m                                }[m
[32m+[m
[32m+[m[32m                                var name = expressionStart.Name.ToString();[m
[32m+[m[32m                                if (!_branchesDict.ContainsKey(name))[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    ReportDiagnostic(context, InvalidStatementRule, statement.GetLocation(), statement.Expression);[m
[32m+[m[32m                                    statements = statements.Remove(statement);[m
[32m+[m[32m                                    continue;[m
[32m+[m[32m                                }[m
[32m+[m[32m                            }[m
[32m+[m
[32m+[m[32m                            if (statements.Count() > 1)[m
[32m+[m[32m                            {[m
[32m+[m[32m                                //too many statements inside initialize[m
[32m+[m[32m                                ReportDiagnostic(context, TooManyInitStatementsRule, statements[0].GetLocation(), TooManyInitStatementsRule.MessageFormat);[m
[32m+[m[32m                                return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
                     }[m
                     else[m
                     {[m

[33mcommit 5d6b878d2d1aa36cfa4b87f660043bbde7d974cc[m
Author: zoepetard <t-zopet@microsoft.com>
Date:   Tue Jun 16 10:53:10 2015 -0700

    Fixed if statement formatting for consistency

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex a549875..d0ef4c0 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -28,7 +28,7 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
         public const string MissingIdDeclaration = "MetaAnalyzer017";[m
         internal static DiagnosticDescriptor MissingIdDeclarationRule = new DiagnosticDescriptor([m
             id: MissingIdDeclaration,[m
[31m-            title: "The diagnostic id decleration is missing.",[m
[32m+[m[32m            title: "The diagnostic id declaration is missing.",[m
             messageFormat: "This diagnostic id has not been declared.",[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
[36m@@ -599,23 +599,38 @@[m [minternal List<string> CheckRules(List<string> idNames, string branch, string kin[m
                         }[m
 [m
                         var declaratorSyntax = fieldSymbol.DeclaringSyntaxReferences[0].GetSyntax() as VariableDeclaratorSyntax;[m
[31m-                        if (declaratorSyntax == null) return emptyRuleNames;[m
[32m+[m[32m                        if (declaratorSyntax == null)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            return emptyRuleNames;[m
[32m+[m[32m                        }[m
[32m+[m
                         var objectCreationSyntax = declaratorSyntax.Initializer.Value as ObjectCreationExpressionSyntax;[m
[31m-                        if (objectCreationSyntax == null) return emptyRuleNames;[m
[32m+[m[32m                        if (objectCreationSyntax == null)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            return emptyRuleNames;[m
[32m+[m[32m                        }[m
[32m+[m
                         var ruleArgumentList = objectCreationSyntax.ArgumentList;[m
 [m
                         for (int i = 0; i < ruleArgumentList.Arguments.Count; i++)[m
                         {[m
                             var currentArg = ruleArgumentList.Arguments[i];[m
[31m-                            if (currentArg == null) return emptyRuleNames;[m
[32m+[m[32m                            if (currentArg == null)[m
[32m+[m[32m                            {[m
[32m+[m[32m                                return emptyRuleNames;[m
[32m+[m[32m                            }[m
[32m+[m
                             var currentArgExpr = currentArg.Expression;[m
[31m-                            if (currentArgExpr == null) return emptyRuleNames;[m
[32m+[m[32m                            if (currentArgExpr == null)[m
[32m+[m[32m                            {[m
[32m+[m[32m                                return emptyRuleNames;[m
[32m+[m[32m                            }[m
 [m
                             if (currentArg.NameColon != null)[m
                             {[m
                                 string currentArgName = currentArg.NameColon.Name.Identifier.Text;[m
 [m
[31m-                                if (currentArgName == "isEnabledByDefault" && currentArgExpr.ToString() != "true")[m
[32m+[m[32m                                if (currentArgName == "isEnabledByDefault" && !currentArgExpr.IsKind(SyntaxKind.TrueLiteralExpression))[m
                                 {[m
                                     ReportDiagnostic(context, EnabledByDefaultErrorRule, currentArgExpr.GetLocation(), EnabledByDefaultErrorRule.MessageFormat);[m
                                     return emptyRuleNames;[m
[36m@@ -623,30 +638,40 @@[m [minternal List<string> CheckRules(List<string> idNames, string branch, string kin[m
                                 else if (currentArgName == "defaultSeverity")[m
                                 {[m
                                     var memberAccessExpr = currentArgExpr as MemberAccessExpressionSyntax;[m
[31m-                                    if (memberAccessExpr == null) return emptyRuleNames;[m
[32m+[m[32m                                    if (memberAccessExpr == null)[m
[32m+[m[32m                                    {[m
[32m+[m[32m                                        return emptyRuleNames;[m
[32m+[m[32m                                    }[m
[32m+[m
                                     if (memberAccessExpr.Expression != null && memberAccessExpr.Name != null)[m
                                     {[m
                                         string identifierExpr = memberAccessExpr.Expression.ToString();[m
                                         string identifierName = memberAccessExpr.Name.Identifier.Text;[m
[31m-[m
                                         if (identifierExpr != "DiagnosticSeverity" && (identifierName != "Warning" || identifierName != "Error" || identifierName != "Hidden" || identifierName != "Info"))[m
                                         {[m
                                             ReportDiagnostic(context, DefaultSeverityErrorRule, currentArgExpr.GetLocation(), DefaultSeverityErrorRule.MessageFormat);[m
                                             return emptyRuleNames;[m
                                         }[m
                                     }[m
[31m-                                    else return emptyRuleNames;[m
[32m+[m[32m                                    else[m
[32m+[m[32m                                    {[m
[32m+[m[32m                                        return emptyRuleNames;[m
[32m+[m[32m                                    }[m
                                 }[m
                                 else if (currentArgName == "id")[m
                                 {[m
[31m-                                    var stringLiteral = currentArgExpr as LiteralExpressionSyntax;[m
[31m-                                    if (stringLiteral != null)[m
[32m+[m[32m                                    if (currentArgExpr.IsKind(SyntaxKind.StringLiteralExpression))[m
                                     {[m
                                         ReportDiagnostic(context, IdDeclTypeErrorRule, currentArgExpr.GetLocation(), IdDeclTypeErrorRule.MessageFormat);[m
                                         return emptyRuleNames;[m
                                     }[m
[32m+[m
[32m+[m[32m                                    if (fieldSymbol.Name == null)[m
[32m+[m[32m                                    {[m
[32m+[m[32m                                        return emptyRuleNames;[m
[32m+[m[32m                                    }[m
[32m+[m
                                     var foundId = currentArgExpr.ToString();[m
[31m-                                    if (fieldSymbol.Name == null) return emptyRuleNames;[m
                                     var foundRule = fieldSymbol.Name.ToString();[m
                                     bool ruleIdFound = false;[m
 [m
[36m@@ -654,7 +679,6 @@[m [minternal List<string> CheckRules(List<string> idNames, string branch, string kin[m
                                     {[m
                                         if (idName == foundId)[m
                                         {[m
[31m-[m
                                             ruleNames.Add(foundRule);[m
                                             ruleIdFound = true;[m
                                         }[m

[33mcommit 11709f3a9fb945c3390d431a2033c5695e073ec1[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Tue Jun 16 10:36:41 2015 -0700

    Revert "work on unit tests"
    
    This reverts commit ca0824962b0e2a0219736e4816a94fcac9bd4b7f.

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/DiagnosticVerifier.Helper.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/DiagnosticVerifier.Helper.cs[m
[1mindex 708cba1..12b93c2 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/DiagnosticVerifier.Helper.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/DiagnosticVerifier.Helper.cs[m
[36m@@ -20,8 +20,6 @@[m [mpublic abstract partial class DiagnosticVerifier[m
         private static readonly MetadataReference SystemCoreReference = MetadataReference.CreateFromAssembly(typeof(Enumerable).Assembly);[m
         private static readonly MetadataReference CSharpSymbolsReference = MetadataReference.CreateFromAssembly(typeof(CSharpCompilation).Assembly);[m
         private static readonly MetadataReference CodeAnalysisReference = MetadataReference.CreateFromAssembly(typeof(Compilation).Assembly);[m
[31m-        private static readonly MetadataReference SystemCollectionsImmutableReference = MetadataReference.CreateFromAssembly(typeof(ImmutableArray).Assembly);[m
[31m-        private static readonly MetadataReference RuntimeReference = MetadataReference.CreateFromFile(System.IO.Path.Combine(System.IO.Path.GetDirectoryName(typeof(object).Assembly.Location), "System.Runtime.dll"));[m
 [m
         internal static string DefaultFilePathPrefix = "Test";[m
         internal static string CSharpDefaultFileExt = "cs";[m
[36m@@ -163,9 +161,7 @@[m [mprivate static Project CreateProject(string[] sources, string language = Languag[m
                 .AddMetadataReference(projectId, CorlibReference)[m
                 .AddMetadataReference(projectId, SystemCoreReference)[m
                 .AddMetadataReference(projectId, CSharpSymbolsReference)[m
[31m-                .AddMetadataReference(projectId, CodeAnalysisReference)[m
[31m-                .AddMetadataReference(projectId, SystemCollectionsImmutableReference)[m
[31m-                .AddMetadataReference(projectId, RuntimeReference);[m
[32m+[m[32m                .AddMetadataReference(projectId, CodeAnalysisReference);[m
 [m
             int count = 0;[m
             foreach (var source in sources)[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex e8004f0..8856006 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -157,7 +157,8 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
                 context.ReportDiagnostic(diagnostic);[m
             }[m
         }[m
[31m-    }";[m
[32m+[m[32m    }[m
[32m+[m[32m";[m
             var expected = new DiagnosticResult[m
             {[m
                 Id = MetaCompilationAnalyzer.MissingId,[m
[36m@@ -168,24 +169,26 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
 [m
             VerifyCSharpDiagnostic(test, expected);[m
 [m
[31m-            var fixtest = @"using System;[m
[31m-using System.Collections.Generic;[m
[31m-            using System.Collections.Immutable;[m
[31m-            using System.Linq;[m
[31m-            using System.Threading;[m
[31m-            using Microsoft.CodeAnalysis;[m
[31m-            using Microsoft.CodeAnalysis.CSharp;[m
[31m-            using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[31m-            using Microsoft.CodeAnalysis.Diagnostics;[m
[31m-            using Microsoft.CodeAnalysis.Text;[m
[32m+[m[32m           /* var fixtest = @"[m
[32m+[m[32m    using System;[m
[32m+[m[32m    using System.Collections.Generic;[m
[32m+[m[32m    using System.Collections.Immutable;[m
[32m+[m[32m    using System.Linq;[m
[32m+[m[32m    using System.Threading;[m
[32m+[m[32m    using Microsoft.CodeAnalysis;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.Text;[m
 [m
[31m-namespace SyntaxNodeAnalyzer[m
[32m+[m[32m    namespace SyntaxNodeAnalyzer[m
     {[m
         [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[31m-        public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m        public class SyntaxNodeAnalyzer : DiagnosticAnalyzer[m
         {[m
[31m-        public const string spacingRuleId = ""IfSpacing"";[m
[31m-        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m            public const string SpacingRuleId = ""IfSpacing"";[m
[32m+[m
[32m+[m[32m            internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
                 id: spacingRuleId, //make the id specific[m
                 title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
                 messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[36m@@ -195,42 +198,42 @@[m [mpublic class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
 [m
             public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
             {[m
[31m-                get[m
[31m-                {[m
[31m-                    return ImmutableArray.Create(Rule);[m
[31m-                }[m
[32m+[m[32m                    get[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return ImmutableArray.Create(Rule);[m
[32m+[m[32m                    }[m
             }[m
 [m
             public override void Initialize(AnalysisContext context)[m
             {[m
[31m-                context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[32m+[m[32m                    context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
             }[m
 [m
             private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
             {[m
[31m-                var ifStatement = (IfStatementSyntax)context.Node;[m
[31m-                var ifKeyword = ifStatement.IfKeyword;[m
[31m-                var openParen = ifStatement.OpenParenToken;[m
[31m-                var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[31m-[m
[31m-                if (ifKeyword.HasTrailingTrivia)[m
[31m-                {[m
[31m-                    var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[31m-                    if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                    var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m                    var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m                    var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m                    var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m[41m            [m
[32m+[m[32m                    if (ifKeyword.HasTrailingTrivia)[m
                     {[m
[31m-                        if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                        var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                        if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
                         {[m
[31m-                            return;[m
[32m+[m[32m                                if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    return;[m
[32m+[m[32m                                }[m
                         }[m
                     }[m
[31m-                }[m
 [m
[31m-                var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-                context.ReportDiagnostic(diagnostic);[m
[32m+[m[32m                    var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m                    context.ReportDiagnostics(diagnostic);[m
             }[m
         }[m
     }";[m
[31m-            VerifyCSharpFix(test, fixtest);[m
[32m+[m[32m            VerifyCSharpFix(test, fixtest);*/[m
         }[m
 [m
         // test for missing Initialize method[m
[36m@@ -238,6 +241,7 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
         public void TestMethod4()[m
         {[m
             var test = @"using System;[m
[32m+[m[32musing System.Runtime;[m
 using System.Collections.Generic;[m
             using System.Collections;[m
             using System.Linq;[m
[36m@@ -300,15 +304,15 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
                 Id = MetaCompilationAnalyzer.MissingInit,[m
                 Message = "You are missing the required Initialize method",[m
                 Severity = DiagnosticSeverity.Error,[m
[31m-                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 15, 22) }[m
[32m+[m[32m                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 16, 22) }[m
             };[m
 [m
             VerifyCSharpDiagnostic(test, expected);[m
 [m
[31m-            var fixtest = @"[m
[32m+[m[32m           /* var fixtest = @"[m
     using System;[m
     using System.Collections.Generic;[m
[31m-    using System.Collections;[m
[32m+[m[32m    using System.Collections.Immutable;[m
     using System.Linq;[m
     using System.Threading;[m
     using Microsoft.CodeAnalysis;[m
[36m@@ -369,10 +373,9 @@[m [mpublic override void Initialize(AnalsisContext context)[m
             }[m
         }[m
     }";[m
[31m-            VerifyCSharpFix(test, fixtest);[m
[32m+[m[32m            VerifyCSharpFix(test, fixtest);*/[m
         }[m
 [m
[31m-        // Check that initialize registers an action[m
         [TestMethod][m
         public void TestMethod5()[m
         {[m
[36m@@ -447,72 +450,6 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
             };[m
 [m
             VerifyCSharpDiagnostic(test, expected);[m
[31m-[m
[31m-            var fixtest = @"using System;[m
[31m-using System.Collections.Generic;[m
[31m-using System.Collections.Immutable;[m
[31m-using System.Linq;[m
[31m-using System.Threading;[m
[31m-using Microsoft.CodeAnalysis;[m
[31m-using Microsoft.CodeAnalysis.CSharp;[m
[31m-using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[31m-using Microsoft.CodeAnalysis.Diagnostics;[m
[31m-using Microsoft.CodeAnalysis.Text;[m
[31m-[m
[31m-namespace SyntaxNodeAnalyzer[m
[31m-{[m
[31m-    [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[31m-    public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[31m-    {[m
[31m-        public const string spacingRuleId = ""IfSpacing"";[m
[31m-[m
[31m-        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[31m-            id: spacingRuleId, //make the id specific[m
[31m-            title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[31m-            messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[31m-            category: ""Syntax"", //make the category specific[m
[31m-            defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[31m-            isEnabledByDefault: true);[m
[31m-[m
[31m-        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[31m-        {[m
[31m-            get[m
[31m-            {[m
[31m-                return ImmutableArray.Create(Rule);[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        public override void Initialize(AnalysisContext context)[m
[31m-        {[m
[31m-            throw new NotImplementedException();[m
[31m-        }[m
[31m-[m
[31m-        private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[31m-        {[m
[31m-            var ifStatement = (IfStatementSyntax)context.Node;[m
[31m-            var ifKeyword = ifStatement.IfKeyword;[m
[31m-            var openParen = ifStatement.OpenParenToken;[m
[31m-            var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[31m-[m
[31m-            if (ifKeyword.HasTrailingTrivia)[m
[31m-            {[m
[31m-                var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[31m-                if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[31m-                {[m
[31m-                    if (trailingTrivia.ToString() == "" "")[m
[31m-                    {[m
[31m-                        return;[m
[31m-                    }[m
[31m-                }[m
[31m-            }[m
[31m-[m
[31m-            var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-            context.ReportDiagnostic(diagnostic);[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[31m-";[m
[31m-            VerifyCSharpFix(test, fixtest);[m
         }[m
 [m
         protected override CodeFixProvider GetCSharpCodeFixProvider()[m

[33mcommit 39eddb600ebc193bad7a6d4c6dd2e0144fd50575[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Tue Jun 16 10:36:31 2015 -0700

    Revert "shortened unit tests"
    
    This reverts commit d4b53d328b46f711d64c164ff54ef9988b505750.

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex dd4550c..e8004f0 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -113,10 +113,49 @@[m [mnamespace SyntaxNodeAnalyzer[m
         [DiagnosticAnalyzer(LanguageNames.CSharp)][m
         public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
         {[m
[32m+[m[32m            internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m                id: spacingRuleId, //make the id specific[m
[32m+[m[32m                title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[32m+[m[32m                messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[32m+[m[32m                category: ""Syntax"", //make the category specific[m
[32m+[m[32m                defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m                isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m            public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[32m+[m[32m            {[m
[32m+[m[32m                get[m
[32m+[m[32m                {[m
[32m+[m[32m                    return ImmutableArray.Create(Rule);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
             public override void Initialize(AnalysisContext context)[m
             {[m
                 context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
             }[m
[32m+[m
[32m+[m[32m            private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m                var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m                var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m                var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m
[32m+[m[32m                if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m                {[m
[32m+[m[32m                    var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                    if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                        {[m
[32m+[m[32m                            return;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m                context.ReportDiagnostic(diagnostic);[m
[32m+[m[32m            }[m
         }[m
     }";[m
             var expected = new DiagnosticResult[m
[36m@@ -146,11 +185,49 @@[m [mnamespace SyntaxNodeAnalyzer[m
         public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
         {[m
         public const string spacingRuleId = ""IfSpacing"";[m
[32m+[m[32m        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m                id: spacingRuleId, //make the id specific[m
[32m+[m[32m                title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[32m+[m[32m                messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[32m+[m[32m                category: ""Syntax"", //make the category specific[m
[32m+[m[32m                defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m                isEnabledByDefault: true);[m
 [m
[31m-        public override void Initialize(AnalysisContext context)[m
[32m+[m[32m            public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[32m+[m[32m            {[m
[32m+[m[32m                get[m
[32m+[m[32m                {[m
[32m+[m[32m                    return ImmutableArray.Create(Rule);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            public override void Initialize(AnalysisContext context)[m
             {[m
                 context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
             }[m
[32m+[m
[32m+[m[32m            private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m                var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m                var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m                var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m
[32m+[m[32m                if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m                {[m
[32m+[m[32m                    var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                    if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                        {[m
[32m+[m[32m                            return;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m                context.ReportDiagnostic(diagnostic);[m
[32m+[m[32m            }[m
         }[m
     }";[m
             VerifyCSharpFix(test, fixtest);[m
[36m@@ -176,13 +253,46 @@[m [mnamespace SyntaxNodeAnalyzer[m
         [DiagnosticAnalyzer(LanguageNames.CSharp)][m
         public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
         {[m
[32m+[m[32m            public const string spacingRuleId = ""IfSpacing"";[m
[32m+[m
[32m+[m[32m            internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m                id: spacingRuleId, //make the id specific[m
[32m+[m[32m                title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[32m+[m[32m                messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[32m+[m[32m                category: ""Syntax"", //make the category specific[m
[32m+[m[32m                defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m                isEnabledByDefault: true);[m
[32m+[m
             public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
             {[m
                 get[m
                 {[m
[31m-                    throw new NotImplementedException();[m
[32m+[m[32m                    return ImmutableArray.Create(Rule);[m
                 }[m
             }[m
[32m+[m
[32m+[m[32m            private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m                var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m                var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m                var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m
[32m+[m[32m                if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m                {[m
[32m+[m[32m                    var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                    if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                        {[m
[32m+[m[32m                            return;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m                context.ReportDiagnostic(diagnostic);[m
[32m+[m[32m            }[m
         }[m
     }";[m
             var expected = new DiagnosticResult[m
[36m@@ -212,14 +322,47 @@[m [mnamespace SyntaxNodeAnalyzer[m
         [DiagnosticAnalyzer(LanguageNames.CSharp)][m
         public class SyntaxNodeAnalyzer : DiagnosticAnalyzer[m
         {[m
[32m+[m[32m            public const string SpacingRuleId = ""IfSpacing"";[m
[32m+[m
[32m+[m[32m            internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m                id: spacingRuleId, //make the id specific[m
[32m+[m[32m                title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[32m+[m[32m                messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[32m+[m[32m                category: ""Syntax"", //make the category specific[m
[32m+[m[32m                defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m                isEnabledByDefault: true);[m
[32m+[m
             public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
             {[m
[31m-                get[m
[31m-                {[m
[31m-                    throw new NotImplementedException();[m
[31m-                }[m
[32m+[m[32m                    get[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return ImmutableArray.Create(Rule);[m
[32m+[m[32m                    }[m
             }[m
 [m
[32m+[m[32m            private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                    var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m                    var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m                    var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m                    var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m[41m            [m
[32m+[m[32m                    if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                        if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                        {[m
[32m+[m[32m                                if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    return;[m
[32m+[m[32m                                }[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m                    context.ReportDiagnostics(diagnostic);[m
[32m+[m[32m            }[m
[32m+[m[41m            [m
             public override void Initialize(AnalsisContext context)[m
             {[m
                 context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[36m@@ -249,11 +392,21 @@[m [mnamespace SyntaxNodeAnalyzer[m
     [DiagnosticAnalyzer(LanguageNames.CSharp)][m
     public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
     {[m
[32m+[m[32m        public const string spacingRuleId = ""IfSpacing"";[m
[32m+[m
[32m+[m[32m        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m            id: spacingRuleId, //make the id specific[m
[32m+[m[32m            title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[32m+[m[32m            messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[32m+[m[32m            category: ""Syntax"", //make the category specific[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
         public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
         {[m
             get[m
             {[m
[31m-                throw new NotImplementedException();[m
[32m+[m[32m                return ImmutableArray.Create(Rule);[m
             }[m
         }[m
 [m
[36m@@ -261,9 +414,27 @@[m [mpublic override void Initialize(AnalysisContext context)[m
         {[m
         }[m
 [m
[31m-        public void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m        private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
         {[m
[31m-            throw new NotImplementedException();[m
[32m+[m[32m            var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m            var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m            var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m            var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m
[32m+[m[32m            if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m            {[m
[32m+[m[32m                var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m            context.ReportDiagnostic(diagnostic);[m
         }[m
     }[m
 }";[m
[36m@@ -272,7 +443,7 @@[m [mpublic void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
                 Id = MetaCompilationAnalyzer.MissingRegisterStatement,[m
                 Message = "You need to register an action within the Initialize method",[m
                 Severity = DiagnosticSeverity.Error,[m
[31m-                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 25, 30) }[m
[32m+[m[32m                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 35, 30) }[m
             };[m
 [m
             VerifyCSharpDiagnostic(test, expected);[m
[36m@@ -293,25 +464,54 @@[m [mnamespace SyntaxNodeAnalyzer[m
     [DiagnosticAnalyzer(LanguageNames.CSharp)][m
     public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
     {[m
[32m+[m[32m        public const string spacingRuleId = ""IfSpacing"";[m
[32m+[m
[32m+[m[32m        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m            id: spacingRuleId, //make the id specific[m
[32m+[m[32m            title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[32m+[m[32m            messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[32m+[m[32m            category: ""Syntax"", //make the category specific[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
         public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
         {[m
             get[m
             {[m
[31m-                throw new NotImplementedException();[m
[32m+[m[32m                return ImmutableArray.Create(Rule);[m
             }[m
         }[m
 [m
         public override void Initialize(AnalysisContext context)[m
         {[m
[31m-            context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[31m-        }[m
[31m-[m
[31m-        public void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[31m-        {[m
             throw new NotImplementedException();[m
         }[m
[32m+[m
[32m+[m[32m        private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m        {[m
[32m+[m[32m            var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m            var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m            var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m            var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m
[32m+[m[32m            if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m            {[m
[32m+[m[32m                var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m            context.ReportDiagnostic(diagnostic);[m
[32m+[m[32m        }[m
     }[m
[31m-}";[m
[32m+[m[32m}[m
[32m+[m[32m";[m
             VerifyCSharpFix(test, fixtest);[m
         }[m
 [m

[33mcommit d12feae2aa13f26e4fe43d4361dafa80956a8abe[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Tue Jun 16 10:36:21 2015 -0700

    Revert "fix tests"
    
    This reverts commit cebcb4b8d651d3f220ecf360b1ce6501a1bbf725.

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex 4be8207..dd4550c 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -161,21 +161,20 @@[m [mpublic override void Initialize(AnalysisContext context)[m
         public void TestMethod4()[m
         {[m
             var test = @"using System;[m
[31m-    using System.Collections.Generic;[m
[31m-    using System.Collections.Immutable;[m
[31m-    using System.Collections;[m
[31m-    using System.Linq;[m
[31m-    using System.Threading;[m
[31m-    using Microsoft.CodeAnalysis;[m
[31m-    using Microsoft.CodeAnalysis.CSharp;[m
[31m-    using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[31m-    using Microsoft.CodeAnalysis.Diagnostics;[m
[31m-    using Microsoft.CodeAnalysis.Text;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32m            using System.Collections;[m
[32m+[m[32m            using System.Linq;[m
[32m+[m[32m            using System.Threading;[m
[32m+[m[32m            using Microsoft.CodeAnalysis;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.Text;[m
 [m
[31m-    namespace SyntaxNodeAnalyzer[m
[32m+[m[32mnamespace SyntaxNodeAnalyzer[m
     {[m
         [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[31m-        public class SyntaxNodeAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m        public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
         {[m
             public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
             {[m
[36m@@ -191,14 +190,14 @@[m [mpublic override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
                 Id = MetaCompilationAnalyzer.MissingInit,[m
                 Message = "You are missing the required Initialize method",[m
                 Severity = DiagnosticSeverity.Error,[m
[31m-                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 16, 22) }[m
[32m+[m[32m                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 15, 22) }[m
             };[m
 [m
             VerifyCSharpDiagnostic(test, expected);[m
 [m
[31m-            var fixtest = @"using System;[m
[32m+[m[32m            var fixtest = @"[m
[32m+[m[32m    using System;[m
     using System.Collections.Generic;[m
[31m-    using System.Collections.Immutable;[m
     using System.Collections;[m
     using System.Linq;[m
     using System.Threading;[m
[36m@@ -221,11 +220,11 @@[m [mpublic override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
                 }[m
             }[m
 [m
[31m-        public override void Initialize(AnalysisContext context)[m
[31m-        {[m
[31m-            throw new NotImplementedException();[m
[32m+[m[32m            public override void Initialize(AnalsisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[32m+[m[32m            }[m
         }[m
[31m-    }[m
     }";[m
             VerifyCSharpFix(test, fixtest);[m
         }[m

[33mcommit 734871c4b805449df4f531a8ccd61c4fd60b1d0e[m
Merge: cebcb4b a8657fb
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Tue Jun 16 10:14:29 2015 -0700

    Merge remote-tracking branch 'dotnet/master'

[33mcommit fc1167c720f1cb95c7ef5e001147358ce2d354ae[m
Author: zoepetard <t-zopet@microsoft.com>
Date:   Tue Jun 16 10:07:22 2015 -0700

    Updated access checks for checkRules()

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 160cd19..a549875 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -16,10 +16,19 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
     {[m
         #region rule rules[m
 [m
[32m+[m[32m        public const string IdDeclTypeError = "MetaAnalyzer018";[m
[32m+[m[32m        internal static DiagnosticDescriptor IdDeclTypeErrorRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: IdDeclTypeError,[m
[32m+[m[32m            title: "Thise diagnostic id type is incorrect.",[m
[32m+[m[32m            messageFormat: "The diagnostic id should not be a string literal.",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
         public const string MissingIdDeclaration = "MetaAnalyzer017";[m
         internal static DiagnosticDescriptor MissingIdDeclarationRule = new DiagnosticDescriptor([m
             id: MissingIdDeclaration,[m
[31m-            title: "This diagnostic id has not been declared.",[m
[32m+[m[32m            title: "The diagnostic id decleration is missing.",[m
             messageFormat: "This diagnostic id has not been declared.",[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
[36m@@ -28,7 +37,7 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
         public const string DefaultSeverityError = "MetaAnalyzer016";[m
         internal static DiagnosticDescriptor DefaultSeverityErrorRule = new DiagnosticDescriptor([m
             id: DefaultSeverityError,[m
[31m-            title: "defaultSeverity must be of the form: DiagnosticSeverity.[severity].",[m
[32m+[m[32m            title: "defaultSeverity is incorrectly declared.",[m
             messageFormat: "defaultSeverity must be of the form: DiagnosticSeverity.[severity].",[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
[36m@@ -196,7 +205,8 @@[m [mpublic override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
                                              MissingIdDeclarationRule, [m
                                              EnabledByDefaultErrorRule, [m
                                              DefaultSeverityErrorRule, [m
[31m-                                             InternalAndStaticErrorRule);[m
[32m+[m[32m                                             InternalAndStaticErrorRule,[m
[32m+[m[32m                                             IdDeclTypeErrorRule);[m
             }[m
         }[m
 [m
[36m@@ -576,52 +586,67 @@[m [minternal List<object> SuppDiagReturnSymbol(CompilationAnalysisContext context, S[m
             internal List<string> CheckRules(List<string> idNames, string branch, string kind, CompilationAnalysisContext context)[m
             {[m
                 List<string> ruleNames = new List<string>();[m
[32m+[m[32m                List<string> emptyRuleNames = new List<string>();[m
 [m
                 foreach (var fieldSymbol in _analyzerFieldSymbols)[m
                 {[m
[31m-                    if (fieldSymbol.Type.MetadataName == "DiagnosticDescriptor")[m
[32m+[m[32m                    if (fieldSymbol.Type != null &&  fieldSymbol.Type.MetadataName == "DiagnosticDescriptor")[m
                     {[m
                         if (fieldSymbol.DeclaredAccessibility != Accessibility.Internal || !fieldSymbol.IsStatic)[m
                         {[m
                             ReportDiagnostic(context, InternalAndStaticErrorRule, fieldSymbol.Locations[0], InternalAndStaticErrorRule.MessageFormat);[m
[31m-                            return ruleNames;[m
[32m+[m[32m                            return emptyRuleNames;[m
                         }[m
 [m
                         var declaratorSyntax = fieldSymbol.DeclaringSyntaxReferences[0].GetSyntax() as VariableDeclaratorSyntax;[m
[32m+[m[32m                        if (declaratorSyntax == null) return emptyRuleNames;[m
                         var objectCreationSyntax = declaratorSyntax.Initializer.Value as ObjectCreationExpressionSyntax;[m
[32m+[m[32m                        if (objectCreationSyntax == null) return emptyRuleNames;[m
                         var ruleArgumentList = objectCreationSyntax.ArgumentList;[m
 [m
                         for (int i = 0; i < ruleArgumentList.Arguments.Count; i++)[m
                         {[m
                             var currentArg = ruleArgumentList.Arguments[i];[m
[32m+[m[32m                            if (currentArg == null) return emptyRuleNames;[m
[32m+[m[32m                            var currentArgExpr = currentArg.Expression;[m
[32m+[m[32m                            if (currentArgExpr == null) return emptyRuleNames;[m
 [m
[31m-                            if (!currentArg.Expression.IsMissing && !currentArg.NameColon.Name.Identifier.IsMissing)[m
[32m+[m[32m                            if (currentArg.NameColon != null)[m
                             {[m
                                 string currentArgName = currentArg.NameColon.Name.Identifier.Text;[m
 [m
[31m-                                if (currentArgName == "isEnabledByDefault" && currentArg.Expression.ToString() != "true")[m
[32m+[m[32m                                if (currentArgName == "isEnabledByDefault" && currentArgExpr.ToString() != "true")[m
                                 {[m
[31m-                                    ReportDiagnostic(context, EnabledByDefaultErrorRule, currentArg.Expression.GetLocation(), EnabledByDefaultErrorRule.MessageFormat);[m
[31m-                                    return ruleNames;[m
[32m+[m[32m                                    ReportDiagnostic(context, EnabledByDefaultErrorRule, currentArgExpr.GetLocation(), EnabledByDefaultErrorRule.MessageFormat);[m
[32m+[m[32m                                    return emptyRuleNames;[m
                                 }[m
                                 else if (currentArgName == "defaultSeverity")[m
                                 {[m
[31m-                                    var memberAccessExpr = currentArg.Expression as MemberAccessExpressionSyntax;[m
[31m-                                    if (!memberAccessExpr.Expression.IsMissing && !memberAccessExpr.Name.Identifier.IsMissing)[m
[32m+[m[32m                                    var memberAccessExpr = currentArgExpr as MemberAccessExpressionSyntax;[m
[32m+[m[32m                                    if (memberAccessExpr == null) return emptyRuleNames;[m
[32m+[m[32m                                    if (memberAccessExpr.Expression != null && memberAccessExpr.Name != null)[m
                                     {[m
                                         string identifierExpr = memberAccessExpr.Expression.ToString();[m
                                         string identifierName = memberAccessExpr.Name.Identifier.Text;[m
 [m
                                         if (identifierExpr != "DiagnosticSeverity" && (identifierName != "Warning" || identifierName != "Error" || identifierName != "Hidden" || identifierName != "Info"))[m
                                         {[m
[31m-                                            ReportDiagnostic(context, DefaultSeverityErrorRule, currentArg.Expression.GetLocation(), DefaultSeverityErrorRule.MessageFormat);[m
[31m-                                            return ruleNames;[m
[32m+[m[32m                                            ReportDiagnostic(context, DefaultSeverityErrorRule, currentArgExpr.GetLocation(), DefaultSeverityErrorRule.MessageFormat);[m
[32m+[m[32m                                            return emptyRuleNames;[m
                                         }[m
                                     }[m
[32m+[m[32m                                    else return emptyRuleNames;[m
                                 }[m
                                 else if (currentArgName == "id")[m
                                 {[m
[31m-                                    var foundId = currentArg.Expression.ToString();[m
[32m+[m[32m                                    var stringLiteral = currentArgExpr as LiteralExpressionSyntax;[m
[32m+[m[32m                                    if (stringLiteral != null)[m
[32m+[m[32m                                    {[m
[32m+[m[32m                                        ReportDiagnostic(context, IdDeclTypeErrorRule, currentArgExpr.GetLocation(), IdDeclTypeErrorRule.MessageFormat);[m
[32m+[m[32m                                        return emptyRuleNames;[m
[32m+[m[32m                                    }[m
[32m+[m[32m                                    var foundId = currentArgExpr.ToString();[m
[32m+[m[32m                                    if (fieldSymbol.Name == null) return emptyRuleNames;[m
                                     var foundRule = fieldSymbol.Name.ToString();[m
                                     bool ruleIdFound = false;[m
 [m
[36m@@ -629,6 +654,7 @@[m [minternal List<string> CheckRules(List<string> idNames, string branch, string kin[m
                                     {[m
                                         if (idName == foundId)[m
                                         {[m
[32m+[m
                                             ruleNames.Add(foundRule);[m
                                             ruleIdFound = true;[m
                                         }[m
[36m@@ -636,11 +662,10 @@[m [minternal List<string> CheckRules(List<string> idNames, string branch, string kin[m
 [m
                                     if (!ruleIdFound)[m
                                     {[m
[31m-                                        ReportDiagnostic(context, MissingIdDeclarationRule, currentArg.Expression.GetLocation(), MissingIdDeclarationRule.MessageFormat);[m
[31m-                                        List<string> emptyRuleNames = new List<string>();[m
[32m+[m[32m                                        ReportDiagnostic(context, MissingIdDeclarationRule, currentArgExpr.GetLocation(), MissingIdDeclarationRule.MessageFormat);[m
                                         return emptyRuleNames;[m
                                     }[m
[31m-                                } [m
[32m+[m[32m                                }[m
                             }[m
                         }[m
                     }[m

[33mcommit a8657fb58380624d073a7893a09aa95b00e61843[m
Merge: c8e6523 de4708d
Author: Daniel King <daniel.king2014@gmail.com>
Date:   Tue Jun 16 09:35:00 2015 -0700

    Merge pull request #21 from daking2014/syntax-node-analyzer-update
    
    Update to the user-written analyzer

[33mcommit c8e65233fb6a0f899f99f26a32aac6c8e27c2ceb[m
Merge: 601eaab 54d88ff
Author: Daniel King <daniel.king2014@gmail.com>
Date:   Tue Jun 16 09:23:46 2015 -0700

    Merge pull request #19 from daking2014/Fix-Supported-Diagnostics
    
    Fixed CheckSupportedDiagnostics bug

[33mcommit de4708dfc5e2975099411e3d66269ab9daa9b58c[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Mon Jun 15 17:05:27 2015 -0700

    Update to the user-written analyzer

[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[1mindex 224a0b4..84b803e 100644[m
[1m--- a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[36m@@ -41,12 +41,11 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
         {[m
             var ifStatement = (IfStatementSyntax)context.Node;[m
             var ifKeyword = ifStatement.IfKeyword;[m
[31m-            var openParen = ifStatement.OpenParenToken;[m
[31m-            var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
 [m
             if (ifKeyword.HasTrailingTrivia)[m
             {[m
                 var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m
                 if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
                 {[m
                     if (trailingTrivia.ToString() == " ")[m
[36m@@ -56,6 +55,11 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
                 }[m
             }[m
 [m
[32m+[m[32m            var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m            var startDiagnosticSpan = ifKeyword.Span.Start;[m
[32m+[m[32m            var endDiagnosticSpan = openParen.Span.Start;[m
[32m+[m[32m            var diagnosticSpan = TextSpan.FromBounds(startDiagnosticSpan, endDiagnosticSpan);[m
[32m+[m[32m            var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, diagnosticSpan);[m
             var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
             context.ReportDiagnostic(diagnostic);[m
         }[m

[33mcommit cebcb4b8d651d3f220ecf360b1ce6501a1bbf725[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Mon Jun 15 16:32:11 2015 -0700

    fix tests

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex dd4550c..4be8207 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -161,20 +161,21 @@[m [mpublic override void Initialize(AnalysisContext context)[m
         public void TestMethod4()[m
         {[m
             var test = @"using System;[m
[31m-using System.Collections.Generic;[m
[31m-            using System.Collections;[m
[31m-            using System.Linq;[m
[31m-            using System.Threading;[m
[31m-            using Microsoft.CodeAnalysis;[m
[31m-            using Microsoft.CodeAnalysis.CSharp;[m
[31m-            using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[31m-            using Microsoft.CodeAnalysis.Diagnostics;[m
[31m-            using Microsoft.CodeAnalysis.Text;[m
[32m+[m[32m    using System.Collections.Generic;[m
[32m+[m[32m    using System.Collections.Immutable;[m
[32m+[m[32m    using System.Collections;[m
[32m+[m[32m    using System.Linq;[m
[32m+[m[32m    using System.Threading;[m
[32m+[m[32m    using Microsoft.CodeAnalysis;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.Text;[m
 [m
[31m-namespace SyntaxNodeAnalyzer[m
[32m+[m[32m    namespace SyntaxNodeAnalyzer[m
     {[m
         [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[31m-        public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m        public class SyntaxNodeAnalyzer : DiagnosticAnalyzer[m
         {[m
             public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
             {[m
[36m@@ -190,14 +191,14 @@[m [mpublic override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
                 Id = MetaCompilationAnalyzer.MissingInit,[m
                 Message = "You are missing the required Initialize method",[m
                 Severity = DiagnosticSeverity.Error,[m
[31m-                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 15, 22) }[m
[32m+[m[32m                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 16, 22) }[m
             };[m
 [m
             VerifyCSharpDiagnostic(test, expected);[m
 [m
[31m-            var fixtest = @"[m
[31m-    using System;[m
[32m+[m[32m            var fixtest = @"using System;[m
     using System.Collections.Generic;[m
[32m+[m[32m    using System.Collections.Immutable;[m
     using System.Collections;[m
     using System.Linq;[m
     using System.Threading;[m
[36m@@ -220,11 +221,11 @@[m [mpublic override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
                 }[m
             }[m
 [m
[31m-            public override void Initialize(AnalsisContext context)[m
[31m-            {[m
[31m-                context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[31m-            }[m
[32m+[m[32m        public override void Initialize(AnalysisContext context)[m
[32m+[m[32m        {[m
[32m+[m[32m            throw new NotImplementedException();[m
         }[m
[32m+[m[32m    }[m
     }";[m
             VerifyCSharpFix(test, fixtest);[m
         }[m

[33mcommit 8db051c58369d8e97ec46f6ffee7cde531dc584e[m
Author: zoepetard <t-zopet@microsoft.com>
Date:   Mon Jun 15 16:32:01 2015 -0700

    Added missing property checks

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 5782370..160cd19 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -594,47 +594,53 @@[m [minternal List<string> CheckRules(List<string> idNames, string branch, string kin[m
                         for (int i = 0; i < ruleArgumentList.Arguments.Count; i++)[m
                         {[m
                             var currentArg = ruleArgumentList.Arguments[i];[m
[31m-                            string currentArgName = currentArg.NameColon.Name.Identifier.Text;[m
 [m
[31m-                            if (currentArgName == "isEnabledByDefault" && currentArg.Expression.ToString() != "true")[m
[32m+[m[32m                            if (!currentArg.Expression.IsMissing && !currentArg.NameColon.Name.Identifier.IsMissing)[m
                             {[m
[31m-                                ReportDiagnostic(context, EnabledByDefaultErrorRule, currentArg.Expression.GetLocation(), EnabledByDefaultErrorRule.MessageFormat);[m
[31m-                                return ruleNames;[m
[31m-                            }[m
[31m-                            else if (currentArgName == "defaultSeverity")[m
[31m-                            {[m
[31m-                                var memberAccessExpr = currentArg.Expression as MemberAccessExpressionSyntax;[m
[31m-                                string identifierExpr = memberAccessExpr.Expression.ToString();[m
[31m-                                string identifierName = memberAccessExpr.Name.Identifier.Text;[m
[32m+[m[32m                                string currentArgName = currentArg.NameColon.Name.Identifier.Text;[m
 [m
[31m-                                if (identifierExpr != "DiagnosticSeverity" && (identifierName != "Warning" || identifierName != "Error" || identifierName != "Hidden" || identifierName != "Info"))[m
[32m+[m[32m                                if (currentArgName == "isEnabledByDefault" && currentArg.Expression.ToString() != "true")[m
                                 {[m
[31m-                                    ReportDiagnostic(context, DefaultSeverityErrorRule, currentArg.Expression.GetLocation(), DefaultSeverityErrorRule.MessageFormat);[m
[32m+[m[32m                                    ReportDiagnostic(context, EnabledByDefaultErrorRule, currentArg.Expression.GetLocation(), EnabledByDefaultErrorRule.MessageFormat);[m
                                     return ruleNames;[m
                                 }[m
[31m-                            }[m
[31m-                            else if (currentArgName == "id")[m
[31m-                            {[m
[31m-                                var foundId = currentArg.Expression.ToString();[m
[31m-                                var foundRule = fieldSymbol.Name.ToString();[m
[31m-                                [m
[31m-                                bool ruleIdFound = false;[m
[31m-[m
[31m-                                foreach (string idName in idNames)[m
[32m+[m[32m                                else if (currentArgName == "defaultSeverity")[m
                                 {[m
[31m-                                    if (idName == foundId)[m
[32m+[m[32m                                    var memberAccessExpr = currentArg.Expression as MemberAccessExpressionSyntax;[m
[32m+[m[32m                                    if (!memberAccessExpr.Expression.IsMissing && !memberAccessExpr.Name.Identifier.IsMissing)[m
                                     {[m
[31m-                                        ruleNames.Add(foundRule);[m
[31m-                                        ruleIdFound = true;[m
[32m+[m[32m                                        string identifierExpr = memberAccessExpr.Expression.ToString();[m
[32m+[m[32m                                        string identifierName = memberAccessExpr.Name.Identifier.Text;[m
[32m+[m
[32m+[m[32m                                        if (identifierExpr != "DiagnosticSeverity" && (identifierName != "Warning" || identifierName != "Error" || identifierName != "Hidden" || identifierName != "Info"))[m
[32m+[m[32m                                        {[m
[32m+[m[32m                                            ReportDiagnostic(context, DefaultSeverityErrorRule, currentArg.Expression.GetLocation(), DefaultSeverityErrorRule.MessageFormat);[m
[32m+[m[32m                                            return ruleNames;[m
[32m+[m[32m                                        }[m
                                     }[m
                                 }[m
[31m-[m
[31m-                                if (!ruleIdFound)[m
[32m+[m[32m                                else if (currentArgName == "id")[m
                                 {[m
[31m-                                    ReportDiagnostic(context, MissingIdDeclarationRule, currentArg.Expression.GetLocation(), MissingIdDeclarationRule.MessageFormat);[m
[31m-                                    List<string> emptyRuleNames = new List<string>();[m
[31m-                                    return emptyRuleNames;[m
[31m-                                }[m
[32m+[m[32m                                    var foundId = currentArg.Expression.ToString();[m
[32m+[m[32m                                    var foundRule = fieldSymbol.Name.ToString();[m
[32m+[m[32m                                    bool ruleIdFound = false;[m
[32m+[m
[32m+[m[32m                                    foreach (string idName in idNames)[m
[32m+[m[32m                                    {[m
[32m+[m[32m                                        if (idName == foundId)[m
[32m+[m[32m                                        {[m
[32m+[m[32m                                            ruleNames.Add(foundRule);[m
[32m+[m[32m                                            ruleIdFound = true;[m
[32m+[m[32m                                        }[m
[32m+[m[32m                                    }[m
[32m+[m
[32m+[m[32m                                    if (!ruleIdFound)[m
[32m+[m[32m                                    {[m
[32m+[m[32m                                        ReportDiagnostic(context, MissingIdDeclarationRule, currentArg.Expression.GetLocation(), MissingIdDeclarationRule.MessageFormat);[m
[32m+[m[32m                                        List<string> emptyRuleNames = new List<string>();[m
[32m+[m[32m                                        return emptyRuleNames;[m
[32m+[m[32m                                    }[m
[32m+[m[32m                                }[m[41m [m
                             }[m
                         }[m
                     }[m

[33mcommit d4b53d328b46f711d64c164ff54ef9988b505750[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Mon Jun 15 15:40:16 2015 -0700

    shortened unit tests

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex e8004f0..dd4550c 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -113,49 +113,10 @@[m [mnamespace SyntaxNodeAnalyzer[m
         [DiagnosticAnalyzer(LanguageNames.CSharp)][m
         public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
         {[m
[31m-            internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[31m-                id: spacingRuleId, //make the id specific[m
[31m-                title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[31m-                messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[31m-                category: ""Syntax"", //make the category specific[m
[31m-                defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[31m-                isEnabledByDefault: true);[m
[31m-[m
[31m-            public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[31m-            {[m
[31m-                get[m
[31m-                {[m
[31m-                    return ImmutableArray.Create(Rule);[m
[31m-                }[m
[31m-            }[m
[31m-[m
             public override void Initialize(AnalysisContext context)[m
             {[m
                 context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
             }[m
[31m-[m
[31m-            private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[31m-            {[m
[31m-                var ifStatement = (IfStatementSyntax)context.Node;[m
[31m-                var ifKeyword = ifStatement.IfKeyword;[m
[31m-                var openParen = ifStatement.OpenParenToken;[m
[31m-                var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[31m-[m
[31m-                if (ifKeyword.HasTrailingTrivia)[m
[31m-                {[m
[31m-                    var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[31m-                    if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[31m-                    {[m
[31m-                        if (trailingTrivia.ToString() == "" "")[m
[31m-                        {[m
[31m-                            return;[m
[31m-                        }[m
[31m-                    }[m
[31m-                }[m
[31m-[m
[31m-                var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-                context.ReportDiagnostic(diagnostic);[m
[31m-            }[m
         }[m
     }";[m
             var expected = new DiagnosticResult[m
[36m@@ -185,49 +146,11 @@[m [mnamespace SyntaxNodeAnalyzer[m
         public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
         {[m
         public const string spacingRuleId = ""IfSpacing"";[m
[31m-        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[31m-                id: spacingRuleId, //make the id specific[m
[31m-                title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[31m-                messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[31m-                category: ""Syntax"", //make the category specific[m
[31m-                defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[31m-                isEnabledByDefault: true);[m
 [m
[31m-            public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[31m-            {[m
[31m-                get[m
[31m-                {[m
[31m-                    return ImmutableArray.Create(Rule);[m
[31m-                }[m
[31m-            }[m
[31m-[m
[31m-            public override void Initialize(AnalysisContext context)[m
[32m+[m[32m        public override void Initialize(AnalysisContext context)[m
             {[m
                 context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
             }[m
[31m-[m
[31m-            private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[31m-            {[m
[31m-                var ifStatement = (IfStatementSyntax)context.Node;[m
[31m-                var ifKeyword = ifStatement.IfKeyword;[m
[31m-                var openParen = ifStatement.OpenParenToken;[m
[31m-                var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[31m-[m
[31m-                if (ifKeyword.HasTrailingTrivia)[m
[31m-                {[m
[31m-                    var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[31m-                    if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[31m-                    {[m
[31m-                        if (trailingTrivia.ToString() == "" "")[m
[31m-                        {[m
[31m-                            return;[m
[31m-                        }[m
[31m-                    }[m
[31m-                }[m
[31m-[m
[31m-                var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-                context.ReportDiagnostic(diagnostic);[m
[31m-            }[m
         }[m
     }";[m
             VerifyCSharpFix(test, fixtest);[m
[36m@@ -253,46 +176,13 @@[m [mnamespace SyntaxNodeAnalyzer[m
         [DiagnosticAnalyzer(LanguageNames.CSharp)][m
         public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
         {[m
[31m-            public const string spacingRuleId = ""IfSpacing"";[m
[31m-[m
[31m-            internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[31m-                id: spacingRuleId, //make the id specific[m
[31m-                title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[31m-                messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[31m-                category: ""Syntax"", //make the category specific[m
[31m-                defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[31m-                isEnabledByDefault: true);[m
[31m-[m
             public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
             {[m
                 get[m
                 {[m
[31m-                    return ImmutableArray.Create(Rule);[m
[32m+[m[32m                    throw new NotImplementedException();[m
                 }[m
             }[m
[31m-[m
[31m-            private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[31m-            {[m
[31m-                var ifStatement = (IfStatementSyntax)context.Node;[m
[31m-                var ifKeyword = ifStatement.IfKeyword;[m
[31m-                var openParen = ifStatement.OpenParenToken;[m
[31m-                var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[31m-[m
[31m-                if (ifKeyword.HasTrailingTrivia)[m
[31m-                {[m
[31m-                    var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[31m-                    if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[31m-                    {[m
[31m-                        if (trailingTrivia.ToString() == "" "")[m
[31m-                        {[m
[31m-                            return;[m
[31m-                        }[m
[31m-                    }[m
[31m-                }[m
[31m-[m
[31m-                var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-                context.ReportDiagnostic(diagnostic);[m
[31m-            }[m
         }[m
     }";[m
             var expected = new DiagnosticResult[m
[36m@@ -322,47 +212,14 @@[m [mnamespace SyntaxNodeAnalyzer[m
         [DiagnosticAnalyzer(LanguageNames.CSharp)][m
         public class SyntaxNodeAnalyzer : DiagnosticAnalyzer[m
         {[m
[31m-            public const string SpacingRuleId = ""IfSpacing"";[m
[31m-[m
[31m-            internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[31m-                id: spacingRuleId, //make the id specific[m
[31m-                title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[31m-                messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[31m-                category: ""Syntax"", //make the category specific[m
[31m-                defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[31m-                isEnabledByDefault: true);[m
[31m-[m
             public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
             {[m
[31m-                    get[m
[31m-                    {[m
[31m-                        return ImmutableArray.Create(Rule);[m
[31m-                    }[m
[32m+[m[32m                get[m
[32m+[m[32m                {[m
[32m+[m[32m                    throw new NotImplementedException();[m
[32m+[m[32m                }[m
             }[m
 [m
[31m-            private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[31m-            {[m
[31m-                    var ifStatement = (IfStatementSyntax)context.Node;[m
[31m-                    var ifKeyword = ifStatement.IfKeyword;[m
[31m-                    var openParen = ifStatement.OpenParenToken;[m
[31m-                    var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[31m-            [m
[31m-                    if (ifKeyword.HasTrailingTrivia)[m
[31m-                    {[m
[31m-                        var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[31m-                        if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[31m-                        {[m
[31m-                                if (trailingTrivia.ToString() == "" "")[m
[31m-                                {[m
[31m-                                    return;[m
[31m-                                }[m
[31m-                        }[m
[31m-                    }[m
[31m-[m
[31m-                    var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-                    context.ReportDiagnostics(diagnostic);[m
[31m-            }[m
[31m-            [m
             public override void Initialize(AnalsisContext context)[m
             {[m
                 context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[36m@@ -392,21 +249,11 @@[m [mnamespace SyntaxNodeAnalyzer[m
     [DiagnosticAnalyzer(LanguageNames.CSharp)][m
     public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
     {[m
[31m-        public const string spacingRuleId = ""IfSpacing"";[m
[31m-[m
[31m-        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[31m-            id: spacingRuleId, //make the id specific[m
[31m-            title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[31m-            messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[31m-            category: ""Syntax"", //make the category specific[m
[31m-            defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[31m-            isEnabledByDefault: true);[m
[31m-[m
         public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
         {[m
             get[m
             {[m
[31m-                return ImmutableArray.Create(Rule);[m
[32m+[m[32m                throw new NotImplementedException();[m
             }[m
         }[m
 [m
[36m@@ -414,27 +261,9 @@[m [mpublic override void Initialize(AnalysisContext context)[m
         {[m
         }[m
 [m
[31m-        private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m        public void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
         {[m
[31m-            var ifStatement = (IfStatementSyntax)context.Node;[m
[31m-            var ifKeyword = ifStatement.IfKeyword;[m
[31m-            var openParen = ifStatement.OpenParenToken;[m
[31m-            var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[31m-[m
[31m-            if (ifKeyword.HasTrailingTrivia)[m
[31m-            {[m
[31m-                var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[31m-                if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[31m-                {[m
[31m-                    if (trailingTrivia.ToString() == "" "")[m
[31m-                    {[m
[31m-                        return;[m
[31m-                    }[m
[31m-                }[m
[31m-            }[m
[31m-[m
[31m-            var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-            context.ReportDiagnostic(diagnostic);[m
[32m+[m[32m            throw new NotImplementedException();[m
         }[m
     }[m
 }";[m
[36m@@ -443,7 +272,7 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
                 Id = MetaCompilationAnalyzer.MissingRegisterStatement,[m
                 Message = "You need to register an action within the Initialize method",[m
                 Severity = DiagnosticSeverity.Error,[m
[31m-                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 35, 30) }[m
[32m+[m[32m                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 25, 30) }[m
             };[m
 [m
             VerifyCSharpDiagnostic(test, expected);[m
[36m@@ -464,54 +293,25 @@[m [mnamespace SyntaxNodeAnalyzer[m
     [DiagnosticAnalyzer(LanguageNames.CSharp)][m
     public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
     {[m
[31m-        public const string spacingRuleId = ""IfSpacing"";[m
[31m-[m
[31m-        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[31m-            id: spacingRuleId, //make the id specific[m
[31m-            title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[31m-            messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[31m-            category: ""Syntax"", //make the category specific[m
[31m-            defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[31m-            isEnabledByDefault: true);[m
[31m-[m
         public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
         {[m
             get[m
             {[m
[31m-                return ImmutableArray.Create(Rule);[m
[32m+[m[32m                throw new NotImplementedException();[m
             }[m
         }[m
 [m
         public override void Initialize(AnalysisContext context)[m
         {[m
[32m+[m[32m            context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m        {[m
             throw new NotImplementedException();[m
         }[m
[31m-[m
[31m-        private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[31m-        {[m
[31m-            var ifStatement = (IfStatementSyntax)context.Node;[m
[31m-            var ifKeyword = ifStatement.IfKeyword;[m
[31m-            var openParen = ifStatement.OpenParenToken;[m
[31m-            var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[31m-[m
[31m-            if (ifKeyword.HasTrailingTrivia)[m
[31m-            {[m
[31m-                var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[31m-                if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[31m-                {[m
[31m-                    if (trailingTrivia.ToString() == "" "")[m
[31m-                    {[m
[31m-                        return;[m
[31m-                    }[m
[31m-                }[m
[31m-            }[m
[31m-[m
[31m-            var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-            context.ReportDiagnostic(diagnostic);[m
[31m-        }[m
     }[m
[31m-}[m
[31m-";[m
[32m+[m[32m}";[m
             VerifyCSharpFix(test, fixtest);[m
         }[m
 [m

[33mcommit 54d88ff675973409adb27667fea351d338ce1ddd[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Mon Jun 15 15:35:24 2015 -0700

    Fixed CheckSupportedDiagnostics bug

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex d826c87..d5f9e2a 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -439,7 +439,7 @@[m [minternal PropertyDeclarationSyntax SuppDiagPropertySymbol(CompilationAnalysisCon[m
                 }[m
 [m
                 if (_propertySymbol.Name != "SupportedDiagnostics" || _propertySymbol.DeclaredAccessibility != Accessibility.Public ||[m
[31m-                    !_propertySymbol.IsOverride || _propertySymbol.OverriddenProperty.Name != "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics")[m
[32m+[m[32m                    !_propertySymbol.IsOverride)[m
                 {[m
                     ReportDiagnostic(context, IncorrectSigSuppDiagRule, _propertySymbol.Locations[0], IncorrectSigSuppDiagRule.MessageFormat);[m
                     return null;[m

[33mcommit a7126549ea6d1fb88592d5e209d072759c0a3dbd[m
Merge: ca08249 601eaab
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Mon Jun 15 14:53:47 2015 -0700

    Merge remote-tracking branch 'dotnet/master' into TestMissingId

[33mcommit ca0824962b0e2a0219736e4816a94fcac9bd4b7f[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Mon Jun 15 14:52:03 2015 -0700

    work on unit tests

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/DiagnosticVerifier.Helper.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/DiagnosticVerifier.Helper.cs[m
[1mindex 12b93c2..708cba1 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/DiagnosticVerifier.Helper.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/DiagnosticVerifier.Helper.cs[m
[36m@@ -20,6 +20,8 @@[m [mpublic abstract partial class DiagnosticVerifier[m
         private static readonly MetadataReference SystemCoreReference = MetadataReference.CreateFromAssembly(typeof(Enumerable).Assembly);[m
         private static readonly MetadataReference CSharpSymbolsReference = MetadataReference.CreateFromAssembly(typeof(CSharpCompilation).Assembly);[m
         private static readonly MetadataReference CodeAnalysisReference = MetadataReference.CreateFromAssembly(typeof(Compilation).Assembly);[m
[32m+[m[32m        private static readonly MetadataReference SystemCollectionsImmutableReference = MetadataReference.CreateFromAssembly(typeof(ImmutableArray).Assembly);[m
[32m+[m[32m        private static readonly MetadataReference RuntimeReference = MetadataReference.CreateFromFile(System.IO.Path.Combine(System.IO.Path.GetDirectoryName(typeof(object).Assembly.Location), "System.Runtime.dll"));[m
 [m
         internal static string DefaultFilePathPrefix = "Test";[m
         internal static string CSharpDefaultFileExt = "cs";[m
[36m@@ -161,7 +163,9 @@[m [mprivate static Project CreateProject(string[] sources, string language = Languag[m
                 .AddMetadataReference(projectId, CorlibReference)[m
                 .AddMetadataReference(projectId, SystemCoreReference)[m
                 .AddMetadataReference(projectId, CSharpSymbolsReference)[m
[31m-                .AddMetadataReference(projectId, CodeAnalysisReference);[m
[32m+[m[32m                .AddMetadataReference(projectId, CodeAnalysisReference)[m
[32m+[m[32m                .AddMetadataReference(projectId, SystemCollectionsImmutableReference)[m
[32m+[m[32m                .AddMetadataReference(projectId, RuntimeReference);[m
 [m
             int count = 0;[m
             foreach (var source in sources)[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex 689ec6f..9b2f94b 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -157,8 +157,7 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
                 context.ReportDiagnostic(diagnostic);[m
             }[m
         }[m
[31m-    }[m
[31m-";[m
[32m+[m[32m    }";[m
             var expected = new DiagnosticResult[m
             {[m
                 Id = MetaCompilationAnalyzer.MissingId,[m
[36m@@ -169,26 +168,24 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
 [m
             VerifyCSharpDiagnostic(test, expected);[m
 [m
[31m-           /* var fixtest = @"[m
[31m-    using System;[m
[31m-    using System.Collections.Generic;[m
[31m-    using System.Collections.Immutable;[m
[31m-    using System.Linq;[m
[31m-    using System.Threading;[m
[31m-    using Microsoft.CodeAnalysis;[m
[31m-    using Microsoft.CodeAnalysis.CSharp;[m
[31m-    using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[31m-    using Microsoft.CodeAnalysis.Diagnostics;[m
[31m-    using Microsoft.CodeAnalysis.Text;[m
[32m+[m[32m            var fixtest = @"using System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32m            using System.Collections.Immutable;[m
[32m+[m[32m            using System.Linq;[m
[32m+[m[32m            using System.Threading;[m
[32m+[m[32m            using Microsoft.CodeAnalysis;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.Text;[m
 [m
[31m-    namespace SyntaxNodeAnalyzer[m
[32m+[m[32mnamespace SyntaxNodeAnalyzer[m
     {[m
         [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[31m-        public class SyntaxNodeAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m        public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
         {[m
[31m-            public const string SpacingRuleId = ""IfSpacing"";[m
[31m-[m
[31m-            internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m        public const string spacingRuleId = ""IfSpacing"";[m
[32m+[m[32m        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
                 id: spacingRuleId, //make the id specific[m
                 title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
                 messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[36m@@ -198,42 +195,42 @@[m [mpublic class SyntaxNodeAnalyzer : DiagnosticAnalyzer[m
 [m
             public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
             {[m
[31m-                    get[m
[31m-                    {[m
[31m-                        return ImmutableArray.Create(Rule);[m
[31m-                    }[m
[32m+[m[32m                get[m
[32m+[m[32m                {[m
[32m+[m[32m                    return ImmutableArray.Create(Rule);[m
[32m+[m[32m                }[m
             }[m
 [m
             public override void Initialize(AnalysisContext context)[m
             {[m
[31m-                    context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[32m+[m[32m                context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
             }[m
 [m
             private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
             {[m
[31m-                    var ifStatement = (IfStatementSyntax)context.Node;[m
[31m-                    var ifKeyword = ifStatement.IfKeyword;[m
[31m-                    var openParen = ifStatement.OpenParenToken;[m
[31m-                    var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[31m-            [m
[31m-                    if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m                var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m                var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m                var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m                var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m
[32m+[m[32m                if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m                {[m
[32m+[m[32m                    var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                    if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
                     {[m
[31m-                        var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[31m-                        if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                        if (trailingTrivia.ToString() == "" "")[m
                         {[m
[31m-                                if (trailingTrivia.ToString() == "" "")[m
[31m-                                {[m
[31m-                                    return;[m
[31m-                                }[m
[32m+[m[32m                            return;[m
                         }[m
                     }[m
[32m+[m[32m                }[m
 [m
[31m-                    var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-                    context.ReportDiagnostics(diagnostic);[m
[32m+[m[32m                var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m                context.ReportDiagnostic(diagnostic);[m
             }[m
         }[m
     }";[m
[31m-            VerifyCSharpFix(test, fixtest);*/[m
[32m+[m[32m            VerifyCSharpFix(test, fixtest);[m
         }[m
 [m
         // test for missing Initialize method[m
[36m@@ -241,7 +238,6 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
         public void TestMethod4()[m
         {[m
             var test = @"using System;[m
[31m-using System.Runtime;[m
 using System.Collections.Generic;[m
             using System.Collections;[m
             using System.Linq;[m
[36m@@ -304,15 +300,15 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
                 Id = MetaCompilationAnalyzer.MissingInit,[m
                 Message = "You are missing the required Initialize method",[m
                 Severity = DiagnosticSeverity.Error,[m
[31m-                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 16, 22) }[m
[32m+[m[32m                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 15, 22) }[m
             };[m
 [m
             VerifyCSharpDiagnostic(test, expected);[m
 [m
[31m-           /* var fixtest = @"[m
[32m+[m[32m            var fixtest = @"[m
     using System;[m
     using System.Collections.Generic;[m
[31m-    using System.Collections.Immutable;[m
[32m+[m[32m    using System.Collections;[m
     using System.Linq;[m
     using System.Threading;[m
     using Microsoft.CodeAnalysis;[m
[36m@@ -373,9 +369,10 @@[m [mpublic override void Initialize(AnalsisContext context)[m
             }[m
         }[m
     }";[m
[31m-            VerifyCSharpFix(test, fixtest);*/[m
[32m+[m[32m            VerifyCSharpFix(test, fixtest);[m
         }[m
 [m
[32m+[m[32m        // Check that initialize registers an action[m
         [TestMethod][m
         public void TestMethod5()[m
         {[m
[36m@@ -450,6 +447,72 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
             };[m
 [m
             VerifyCSharpDiagnostic(test, expected);[m
[32m+[m
[32m+[m[32m            var fixtest = @"using System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Collections.Immutable;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m[32musing Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Text;[m
[32m+[m
[32m+[m[32mnamespace SyntaxNodeAnalyzer[m
[32m+[m[32m{[m
[32m+[m[32m    [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[32m+[m[32m    public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m    {[m
[32m+[m[32m        public const string spacingRuleId = ""IfSpacing"";[m
[32m+[m
[32m+[m[32m        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m            id: spacingRuleId, //make the id specific[m
[32m+[m[32m            title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[32m+[m[32m            messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[32m+[m[32m            category: ""Syntax"", //make the category specific[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return ImmutableArray.Create(Rule);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public override void Initialize(AnalysisContext context)[m
[32m+[m[32m        {[m
[32m+[m[32m            throw new NotImplementedException();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m        {[m
[32m+[m[32m            var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m            var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m            var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m            var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m
[32m+[m[32m            if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m            {[m
[32m+[m[32m                var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m            context.ReportDiagnostic(diagnostic);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m[32m";[m
[32m+[m[32m            VerifyCSharpFix(test, fixtest);[m
         }[m
 [m
         protected override CodeFixProvider GetCSharpCodeFixProvider()[m

[33mcommit 601eaabbc5c94e8cfdf2ee3efab02d4f906626b9[m
Merge: 7668601 75216d1
Author: Daniel King <daniel.king2014@gmail.com>
Date:   Mon Jun 15 14:47:18 2015 -0700

    Merge pull request #18 from daking2014/NoRulesDiagnostic
    
    Add a diagnostic for when there are no rules

[33mcommit 75216d1d3bb6c7faab725de784163e9926907c2c[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Mon Jun 15 14:44:30 2015 -0700

    Add a diagnostic for when there are no rules

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 5782370..d826c87 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -51,6 +51,15 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public const string MissingRule = "MetaAnalyzer019";[m
[32m+[m[32m        internal static DiagnosticDescriptor MissingRuleRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: MissingRule,[m
[32m+[m[32m            title: "Missing a rule",[m
[32m+[m[32m            messageFormat: "You need to have at least one DiagnosticDescriptor rule",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
         #endregion[m
 [m
         #region id rules[m
[36m@@ -324,7 +333,8 @@[m [minternal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context[m
                             }[m
                             else[m
                             {[m
[31m-                                //diagnostic[m
[32m+[m[32m                                var analyzerClass = _analyzerClassSymbol.DeclaringSyntaxReferences[0].GetSyntax() as ClassDeclarationSyntax;[m
[32m+[m[32m                                ReportDiagnostic(context, MissingRuleRule, analyzerClass.Identifier.GetLocation(), MissingRuleRule.MessageFormat);[m
                             }[m
                         }[m
                         else[m

[33mcommit 7668601ae7f29dc0566b0addfb1999f39c4a641a[m
Merge: 9578337 01b5498
Author: zoepetard <t-zopet@microsoft.com>
Date:   Mon Jun 15 10:12:39 2015 -0700

    Merge pull request #15 from zoepetard/CheckRulesMethod
    
    Check rules method

[33mcommit 01b549886cefbaf3e44b8f52812084ad0588c305[m
Merge: a9e0334 e280b41
Author: zoepetard <t-zopet@microsoft.com>
Date:   Mon Jun 15 10:11:11 2015 -0700

    Merge branch 'zoepetard-CheckRulesMethod' into CheckRulesMethod

[33mcommit e280b41216a79f02799dbd54d0f5482bdd08cd03[m
Merge: 9578337 a9e0334
Author: zoepetard <t-zopet@microsoft.com>
Date:   Mon Jun 15 10:10:28 2015 -0700

    Fixed merge conflict

[33mcommit 9578337f6af93ef840657269108562133a679683[m
Merge: a9a354e eb627bf
Author: Daniel King <daniel.king2014@gmail.com>
Date:   Mon Jun 15 10:00:12 2015 -0700

    Merge pull request #12 from daking2014/check-supported-diagnostics
    
    Check supported diagnostics

[33mcommit eb627bfcbec4457c16db7e4d4db3823c638b29e2[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Mon Jun 15 09:59:43 2015 -0700

    Fix spacing

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 3eb4a40..4f695c8 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -394,6 +394,7 @@[m [minternal PropertyDeclarationSyntax SuppDiagPropertySymbol(CompilationAnalysisCon[m
 [m
                 return _propertySymbol.DeclaringSyntaxReferences[0].GetSyntax() as PropertyDeclarationSyntax;[m
             }[m
[32m+[m
             internal SyntaxList<StatementSyntax> SuppDiagAccessor(CompilationAnalysisContext context, PropertyDeclarationSyntax propertyDeclaration)[m
             {[m
                 SyntaxList<StatementSyntax> emptyResult = new SyntaxList<StatementSyntax>();[m
[36m@@ -432,6 +433,7 @@[m [minternal SyntaxList<StatementSyntax> SuppDiagAccessor(CompilationAnalysisContext[m
 [m
                 return accessorBody.Statements;[m
             }[m
[32m+[m
             internal void SuppDiagReturnCheck(CompilationAnalysisContext context, InvocationExpressionSyntax valueClause, Location returnDeclarationLocation, List<string> ruleNames)[m
             {[m
                 if (valueClause == null)[m
[36m@@ -478,6 +480,7 @@[m [minternal void SuppDiagReturnCheck(CompilationAnalysisContext context, Invocation[m
                     }[m
                 }[m
             }[m
[32m+[m
             internal List<object> SuppDiagReturnSymbol(CompilationAnalysisContext context, SymbolInfo returnSymbolInfo, Location getAccessorKeywordLocation)[m
             {[m
                 List<object> result = new List<object>();[m
[36m@@ -668,6 +671,7 @@[m [minternal BlockSyntax InitializeOverview(CompilationAnalysisContext context)[m
 [m
                 return codeBlock;[m
             }[m
[32m+[m
             internal List<object> InitializeBody(CompilationAnalysisContext context, SyntaxList<StatementSyntax> statements)[m
             {[m
                 var statement = statements[0] as ExpressionStatementSyntax;[m

[33mcommit 9cf3452cb501072f4b5201a7e11236b9f392766b[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Mon Jun 15 09:58:38 2015 -0700

    replace ToString() where obvious

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 4d3e6d9..3eb4a40 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -239,22 +239,22 @@[m [minternal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context[m
                     return;[m
                 }[m
                 //interpret initialize info[m
[31m-                if (_branchesDict.ContainsKey(registerSymbol.Name.ToString()))[m
[32m+[m[32m                if (_branchesDict.ContainsKey(registerSymbol.Name))[m
                 {[m
                     string kindName = null;[m
                     if (kind != null)[m
                     {[m
[31m-                        kindName = kind.Name.ToString();[m
[32m+[m[32m                        kindName = kind.Name;[m
                     }[m
 [m
                     if (kindName == null || allowedKinds.Contains(kindName))[m
                     {[m
                         //look for and interpret id fields[m
[31m-                        List<string> idNames = CheckIds(_branchesDict[registerSymbol.Name.ToString()], kindName, context);[m
[32m+[m[32m                        List<string> idNames = CheckIds(_branchesDict[registerSymbol.Name], kindName, context);[m
                         if (idNames.Count > 0)[m
                         {[m
                             //look for and interpret rule fields[m
[31m-                            List<string> ruleNames = CheckRules(idNames, _branchesDict[registerSymbol.Name.ToString()], kindName, context);[m
[32m+[m[32m                            List<string> ruleNames = CheckRules(idNames, _branchesDict[registerSymbol.Name], kindName, context);[m
 [m
                             if (ruleNames.Count > 0)[m
                             {[m
[36m@@ -264,7 +264,7 @@[m [minternal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context[m
                                 if (supportedDiagnosticsCorrect)[m
                                 {[m
                                     //check the SyntaxNode, Symbol, Compilation, CodeBlock, etc analysis method(s)[m
[31m-                                    bool analysisCorrect = CheckAnalysis(_branchesDict[registerSymbol.Name.ToString()], kindName, ruleNames, context);[m
[32m+[m[32m                                    bool analysisCorrect = CheckAnalysis(_branchesDict[registerSymbol.Name], kindName, ruleNames, context);[m
                                     if (analysisCorrect)[m
                                     {[m
                                         //diagnostic to go to code fix[m
[36m@@ -288,7 +288,7 @@[m [minternal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context[m
                         {[m
                             // diagnostic for missing id names[m
                            var analyzerClassSyntax = _analyzerClassSymbol.DeclaringSyntaxReferences[0].GetSyntax() as ClassDeclarationSyntax;[m
[31m-                           ReportDiagnostic(context, MissingIdRule, analyzerClassSyntax.Identifier.GetLocation(), analyzerClassSyntax.Identifier.ToString());[m
[32m+[m[32m                           ReportDiagnostic(context, MissingIdRule, analyzerClassSyntax.Identifier.GetLocation(), MissingIdRule.MessageFormat);[m
                         }[m
                     }[m
                     else[m
[36m@@ -385,8 +385,8 @@[m [minternal PropertyDeclarationSyntax SuppDiagPropertySymbol(CompilationAnalysisCon[m
                     return null;[m
                 }[m
 [m
[31m-                if (_propertySymbol.Name.ToString() != "SupportedDiagnostics" || _propertySymbol.DeclaredAccessibility != Accessibility.Public ||[m
[31m-                    !_propertySymbol.IsOverride || _propertySymbol.OverriddenProperty.ToString() != "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics")[m
[32m+[m[32m                if (_propertySymbol.Name != "SupportedDiagnostics" || _propertySymbol.DeclaredAccessibility != Accessibility.Public ||[m
[32m+[m[32m                    !_propertySymbol.IsOverride || _propertySymbol.OverriddenProperty.Name != "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics")[m
                 {[m
                     ReportDiagnostic(context, IncorrectSigSuppDiagRule, _propertySymbol.Locations[0], IncorrectSigSuppDiagRule.MessageFormat);[m
                     return null;[m
[36m@@ -498,7 +498,7 @@[m [minternal List<object> SuppDiagReturnSymbol(CompilationAnalysisContext context, S[m
                     return result;[m
                 }[m
 [m
[31m-                if (returnSymbol.Type.ToString() != "System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.DiagnosticDescriptor>")[m
[32m+[m[32m                if (returnSymbol.Type.Name != "System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.DiagnosticDescriptor>")[m
                 {[m
                     ReportDiagnostic(context, IncorrectAccessorReturnRule, returnSymbol.Locations[0], IncorrectAccessorReturnRule.MessageFormat);[m
                     return result;[m
[36m@@ -544,7 +544,7 @@[m [minternal List<string> CheckIds(string branch, string kind, CompilationAnalysisCo[m
                         {[m
                             continue;[m
                         }[m
[31m-                        idNames.Add(field.Name.ToString());[m
[32m+[m[32m                        idNames.Add(field.Name);[m
                     }[m
                 }[m
                 return idNames;[m
[36m@@ -647,7 +647,7 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
             internal BlockSyntax InitializeOverview(CompilationAnalysisContext context)[m
             {[m
                 ImmutableArray<IParameterSymbol> parameters = _initializeSymbol.Parameters;[m
[31m-                if (parameters.Count() != 1 || parameters[0].Type != context.Compilation.GetTypeByMetadataName("Microsoft.CodeAnalysis.Diagnostics.AnalysisContext") || parameters[0].Name.ToString() != "context" || _initializeSymbol.DeclaredAccessibility != Accessibility.Public || !_initializeSymbol.IsOverride || !_initializeSymbol.ReturnsVoid)[m
[32m+[m[32m                if (parameters.Count() != 1 || parameters[0].Type != context.Compilation.GetTypeByMetadataName("Microsoft.CodeAnalysis.Diagnostics.AnalysisContext") || parameters[0].Name != "context" || _initializeSymbol.DeclaredAccessibility != Accessibility.Public || !_initializeSymbol.IsOverride || !_initializeSymbol.ReturnsVoid)[m
                 {[m
                     ReportDiagnostic(context, IncorrectInitSigRule, _initializeSymbol.Locations[0], MissingInitRule.MessageFormat);[m
                     return null;[m
[36m@@ -697,7 +697,7 @@[m [minternal List<object> InitializeBody(CompilationAnalysisContext context, SyntaxL[m
                     ReportDiagnostic(context, IncorrectInitStatementRule, memberExpr.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
                     return null;[m
                 }[m
[31m-                if (memberExprContext.Identifier.ToString() != "context")[m
[32m+[m[32m                if (memberExprContext.Identifier.Text != "context")[m
                 {[m
                     ReportDiagnostic(context, IncorrectInitStatementRule, memberExprContext.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
                     return null;[m
[36m@@ -745,7 +745,7 @@[m [minternal void AddMethod(SymbolAnalysisContext context)[m
                     return;[m
                 }[m
 [m
[31m-                if (sym.Name.ToString() == "Initialize")[m
[32m+[m[32m                if (sym.Name == "Initialize")[m
                 {[m
                     _initializeSymbol = sym;[m
                     return;[m
[36m@@ -779,7 +779,7 @@[m [minternal void AddProperty(SymbolAnalysisContext context)[m
                     return;[m
                 }[m
 [m
[31m-                if (sym.Name.ToString() == "SupportedDiagnostics")[m
[32m+[m[32m                if (sym.Name == "SupportedDiagnostics")[m
                 {[m
                     _propertySymbol = sym;[m
                     return;[m

[33mcommit a9e03341e8a804e1959501c572d9d2142be7e5f6[m
Author: zoepetard <t-zopet@microsoft.com>
Date:   Mon Jun 15 09:51:15 2015 -0700

    Final check rules method to merge

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex ad3e1d9..d473c2a 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -20,8 +20,8 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
         public const string MissingIdDeclaration = "MetaAnalyzer017";[m
         internal static DiagnosticDescriptor MissingIdDeclarationRule = new DiagnosticDescriptor([m
             id: MissingIdDeclaration,[m
[31m-            title: "This diagnoctic id has not been declared.",[m
[31m-            messageFormat: "This diagnoctic id has not been declared.",[m
[32m+[m[32m            title: "This diagnostic id has not been declared.",[m
[32m+[m[32m            messageFormat: "This diagnostic id has not been declared.",[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
[36m@@ -307,19 +307,18 @@[m [minternal List<string> CheckRules(List<string> idNames, string branch, string kin[m
                         for (int i = 0; i < ruleArgumentList.Arguments.Count; i++)[m
                         {[m
                             var currentArg = ruleArgumentList.Arguments[i];[m
[31m-                            string currentArgName = currentArg.NameColon.Name.ToString();[m
[31m-                        [m
[32m+[m[32m                            string currentArgName = currentArg.NameColon.Name.Identifier.Text;[m
[32m+[m
                             if (currentArgName == "isEnabledByDefault" && currentArg.Expression.ToString() != "true")[m
                             {[m
                                 ReportDiagnostic(context, EnabledByDefaultErrorRule, currentArg.Expression.GetLocation(), EnabledByDefaultErrorRule.MessageFormat);[m
                                 return ruleNames;[m
                             }[m
[31m-[m
                             else if (currentArgName == "defaultSeverity")[m
                             {[m
                                 var memberAccessExpr = currentArg.Expression as MemberAccessExpressionSyntax;[m
                                 string identifierExpr = memberAccessExpr.Expression.ToString();[m
[31m-                                string identifierName = memberAccessExpr.Name.ToString();[m
[32m+[m[32m                                string identifierName = memberAccessExpr.Name.Identifier.Text;[m
 [m
                                 if (identifierExpr != "DiagnosticSeverity" && (identifierName != "Warning" || identifierName != "Error" || identifierName != "Hidden" || identifierName != "Info"))[m
                                 {[m
[36m@@ -327,7 +326,6 @@[m [minternal List<string> CheckRules(List<string> idNames, string branch, string kin[m
                                     return ruleNames;[m
                                 }[m
                             }[m
[31m-                            [m
                             else if (currentArgName == "id")[m
                             {[m
                                 var foundId = currentArg.Expression.ToString();[m

[33mcommit c18437e081691d070913fb527fa1a3ed7d3b8cd3[m
Author: zoepetard <t-zopet@microsoft.com>
Date:   Fri Jun 12 17:04:05 2015 -0700

    updated checkRules

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex ab75924..ad3e1d9 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -288,8 +288,6 @@[m [minternal bool CheckSupportedDiagnostics(List<string> ruleNames, CompilationAnaly[m
             //returns a list of rule names[m
             internal List<string> CheckRules(List<string> idNames, string branch, string kind, CompilationAnalysisContext context)[m
             {[m
[31m-                Dictionary<string, string> foundRules = new Dictionary<string, string>(); //Dicitonary(Rule Id, Rule)[m
[31m-                [m
                 List<string> ruleNames = new List<string>();[m
 [m
                 foreach (var fieldSymbol in _analyzerFieldSymbols)[m
[36m@@ -299,6 +297,7 @@[m [minternal List<string> CheckRules(List<string> idNames, string branch, string kin[m
                         if (fieldSymbol.DeclaredAccessibility != Accessibility.Internal || !fieldSymbol.IsStatic)[m
                         {[m
                             ReportDiagnostic(context, InternalAndStaticErrorRule, fieldSymbol.Locations[0], InternalAndStaticErrorRule.MessageFormat);[m
[32m+[m[32m                            return ruleNames;[m
                         }[m
 [m
                         var declaratorSyntax = fieldSymbol.DeclaringSyntaxReferences[0].GetSyntax() as VariableDeclaratorSyntax;[m
[36m@@ -309,11 +308,11 @@[m [minternal List<string> CheckRules(List<string> idNames, string branch, string kin[m
                         {[m
                             var currentArg = ruleArgumentList.Arguments[i];[m
                             string currentArgName = currentArg.NameColon.Name.ToString();[m
[31m-                            string currentArgExpr = currentArg.Expression.ToString();[m
[31m-[m
[31m-                            if (currentArgName == "isEnabledByDefault" && currentArgExpr != "true")[m
[32m+[m[41m                        [m
[32m+[m[32m                            if (currentArgName == "isEnabledByDefault" && currentArg.Expression.ToString() != "true")[m
                             {[m
                                 ReportDiagnostic(context, EnabledByDefaultErrorRule, currentArg.Expression.GetLocation(), EnabledByDefaultErrorRule.MessageFormat);[m
[32m+[m[32m                                return ruleNames;[m
                             }[m
 [m
                             else if (currentArgName == "defaultSeverity")[m
[36m@@ -325,27 +324,31 @@[m [minternal List<string> CheckRules(List<string> idNames, string branch, string kin[m
                                 if (identifierExpr != "DiagnosticSeverity" && (identifierName != "Warning" || identifierName != "Error" || identifierName != "Hidden" || identifierName != "Info"))[m
                                 {[m
                                     ReportDiagnostic(context, DefaultSeverityErrorRule, currentArg.Expression.GetLocation(), DefaultSeverityErrorRule.MessageFormat);[m
[32m+[m[32m                                    return ruleNames;[m
                                 }[m
                             }[m
[31m-[m
[32m+[m[41m                            [m
                             else if (currentArgName == "id")[m
                             {[m
[31m-                                foundRules.Add(currentArgExpr, fieldSymbol.Name.ToString());[m
[32m+[m[32m                                var foundId = currentArg.Expression.ToString();[m
[32m+[m[32m                                var foundRule = fieldSymbol.Name.ToString();[m
[32m+[m[41m                                [m
                                 bool ruleIdFound = false;[m
 [m
                                 foreach (string idName in idNames)[m
                                 {[m
[31m-                                    if (idName == foundRules.Last().Key)[m
[32m+[m[32m                                    if (idName == foundId)[m
                                     {[m
[31m-                                        ruleNames.Add(foundRules.Last().Value);[m
[32m+[m[32m                                        ruleNames.Add(foundRule);[m
                                         ruleIdFound = true;[m
                                     }[m
                                 }[m
 [m
                                 if (!ruleIdFound)[m
                                 {[m
[31m-                                    var ruleNotFound = foundRules.Last().Value;[m
                                     ReportDiagnostic(context, MissingIdDeclarationRule, currentArg.Expression.GetLocation(), MissingIdDeclarationRule.MessageFormat);[m
[32m+[m[32m                                    List<string> emptyRuleNames = new List<string>();[m
[32m+[m[32m                                    return emptyRuleNames;[m
                                 }[m
                             }[m
                         }[m

[33mcommit a899faabddcb547d2a316189eb36d36527199291[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Fri Jun 12 16:28:37 2015 -0700

    Replacing comments

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex eb53ea6..4d3e6d9 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -276,7 +276,7 @@[m [minternal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context[m
                                 }[m
                                 else[m
                                 {[m
[31m-                                    //diagnostic[m
[32m+[m[32m                                    return;[m
                                 }[m
                             }[m
                             else[m
[36m@@ -298,7 +298,7 @@[m [minternal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context[m
                 }[m
                 else[m
                 {[m
[31m-                    //diagnostic[m
[32m+[m[32m                    return;[m
                 }[m
             }[m
 [m
[36m@@ -465,7 +465,6 @@[m [minternal void SuppDiagReturnCheck(CompilationAnalysisContext context, Invocation[m
                     return;[m
                 }[m
 [m
[31m-[m
                 foreach (ArgumentSyntax arg in valueArgs)[m
                 {[m
                     if (ruleNames.Count == 0)[m
[36m@@ -530,11 +529,7 @@[m [minternal List<object> SuppDiagReturnSymbol(CompilationAnalysisContext context, S[m
             //returns a list of rule names[m
             internal List<string> CheckRules(List<string> idNames, string branch, string kind, CompilationAnalysisContext context)[m
             {[m
[31m-                //TODO: change back to not implemented[m
[31m-                var result = new List<string>();[m
[31m-                result.Add("Rule");[m
[31m-                return result;[m
[31m-[m
[32m+[m[32m                throw new NotImplementedException();[m
             }[m
             [m
             //returns a list of id names, empty if none found[m
[36m@@ -563,7 +558,6 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                 IMethodSymbol registerCall = null;[m
                 List<ISymbol> registerArgs = new List<ISymbol>();[m
                 InvocationExpressionSyntax invocExpr = null;[m
[31m-[m
                 [m
                 if (_initializeSymbol == null)[m
                 {[m

[33mcommit d5bd3342d7e8699fd062c2e828ffaedfe764fcda[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Fri Jun 12 16:17:23 2015 -0700

    Add test for MissingRegisterStatement diagnostic

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex c3b05d0..689ec6f 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -169,24 +169,24 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
 [m
             VerifyCSharpDiagnostic(test, expected);[m
 [m
[31m-           /* var fixtest = @"using System;[m
[31m-using System.Runtime;[m
[31m-using System.Collections.Generic;[m
[31m-            using System.Collections.Immutable;[m
[31m-            using System.Linq;[m
[31m-            using System.Threading;[m
[31m-            using Microsoft.CodeAnalysis;[m
[31m-            using Microsoft.CodeAnalysis.CSharp;[m
[31m-            using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[31m-            using Microsoft.CodeAnalysis.Diagnostics;[m
[31m-            using Microsoft.CodeAnalysis.Text;[m
[32m+[m[32m           /* var fixtest = @"[m
[32m+[m[32m    using System;[m
[32m+[m[32m    using System.Collections.Generic;[m
[32m+[m[32m    using System.Collections.Immutable;[m
[32m+[m[32m    using System.Linq;[m
[32m+[m[32m    using System.Threading;[m
[32m+[m[32m    using Microsoft.CodeAnalysis;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.Text;[m
 [m
[31m-namespace SyntaxNodeAnalyzer[m
[32m+[m[32m    namespace SyntaxNodeAnalyzer[m
     {[m
         [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[31m-        public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m        public class SyntaxNodeAnalyzer : DiagnosticAnalyzer[m
         {[m
[31m-            public const string spacingRuleId = ""IfSpacing"";[m
[32m+[m[32m            public const string SpacingRuleId = ""IfSpacing"";[m
 [m
             internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
                 id: spacingRuleId, //make the id specific[m
[36m@@ -198,42 +198,41 @@[m [mpublic class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
 [m
             public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
             {[m
[31m-                get[m
[31m-                {[m
[31m-                    return ImmutableArray.Create(Rule);[m
[31m-                }[m
[32m+[m[32m                    get[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return ImmutableArray.Create(Rule);[m
[32m+[m[32m                    }[m
             }[m
 [m
             public override void Initialize(AnalysisContext context)[m
             {[m
[31m-                context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[32m+[m[32m                    context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
             }[m
 [m
             private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
             {[m
[31m-                var ifStatement = (IfStatementSyntax)context.Node;[m
[31m-                var ifKeyword = ifStatement.IfKeyword;[m
[31m-                var openParen = ifStatement.OpenParenToken;[m
[31m-                var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[31m-[m
[31m-                if (ifKeyword.HasTrailingTrivia)[m
[31m-                {[m
[31m-                    var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[31m-                    if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                    var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m                    var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m                    var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m                    var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m[41m            [m
[32m+[m[32m                    if (ifKeyword.HasTrailingTrivia)[m
                     {[m
[31m-                        if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                        var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                        if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
                         {[m
[31m-                            return;[m
[32m+[m[32m                                if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    return;[m
[32m+[m[32m                                }[m
                         }[m
                     }[m
[31m-                }[m
 [m
[31m-                var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-                context.ReportDiagnostic(diagnostic);[m
[32m+[m[32m                    var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m                    context.ReportDiagnostics(diagnostic);[m
             }[m
         }[m
[31m-    }[m
[31m-";[m
[32m+[m[32m    }";[m
             VerifyCSharpFix(test, fixtest);*/[m
         }[m
 [m
[36m@@ -310,71 +309,147 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
 [m
             VerifyCSharpDiagnostic(test, expected);[m
 [m
[31m-                   /* var fixTest = @"using System;[m
[31m-        using System.Runtime, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a;[m
[31m-        using System.Collections.Generic;[m
[31m-                    using System.Collections.Immutable;[m
[31m-                    using System.Linq;[m
[31m-                    using System.Threading;[m
[31m-                    using Microsoft.CodeAnalysis;[m
[31m-                    using Microsoft.CodeAnalysis.CSharp;[m
[31m-                    using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[31m-                    using Microsoft.CodeAnalysis.Diagnostics;[m
[31m-                    using Microsoft.CodeAnalysis.Text;[m
[32m+[m[32m           /* var fixtest = @"[m
[32m+[m[32m    using System;[m
[32m+[m[32m    using System.Collections.Generic;[m
[32m+[m[32m    using System.Collections.Immutable;[m
[32m+[m[32m    using System.Linq;[m
[32m+[m[32m    using System.Threading;[m
[32m+[m[32m    using Microsoft.CodeAnalysis;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32m    using Microsoft.CodeAnalysis.Text;[m
 [m
[31m-        namespace SyntaxNodeAnalyzer[m
[32m+[m[32m    namespace SyntaxNodeAnalyzer[m
[32m+[m[32m    {[m
[32m+[m[32m        [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[32m+[m[32m        public class SyntaxNodeAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m        {[m
[32m+[m[32m            public const string SpacingRuleId = ""IfSpacing"";[m
[32m+[m
[32m+[m[32m            internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m                id: spacingRuleId, //make the id specific[m
[32m+[m[32m                title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[32m+[m[32m                messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[32m+[m[32m                category: ""Syntax"", //make the category specific[m
[32m+[m[32m                defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m                isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m            public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
             {[m
[31m-                [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[31m-                public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[31m-                {[m
[31m-                    public const string spacingRuleId = ""IfSpacing"";[m
[31m-[m
[31m-                    internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[31m-                        id: spacingRuleId, //make the id specific[m
[31m-                        title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[31m-                        messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[31m-                        category: ""Syntax"", //make the category specific[m
[31m-                        defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[31m-                        isEnabledByDefault: true);[m
[31m-[m
[31m-                    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[32m+[m[32m                    get[m
                     {[m
[31m-                        get[m
[31m-                        {[m
[31m-                            return ImmutableArray.Create(Rule);[m
[31m-                        }[m
[32m+[m[32m                        return ImmutableArray.Create(Rule);[m
                     }[m
[32m+[m[32m            }[m
 [m
[31m-                    private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m            private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                    var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m                    var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m                    var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m                    var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m[41m            [m
[32m+[m[32m                    if (ifKeyword.HasTrailingTrivia)[m
                     {[m
[31m-                        var ifStatement = (IfStatementSyntax)context.Node;[m
[31m-                        var ifKeyword = ifStatement.IfKeyword;[m
[31m-                        var openParen = ifStatement.OpenParenToken;[m
[31m-                        var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[31m-[m
[31m-                        if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m                        var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                        if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
                         {[m
[31m-                            var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[31m-                            if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[31m-                            {[m
                                 if (trailingTrivia.ToString() == "" "")[m
                                 {[m
                                     return;[m
                                 }[m
[31m-                            }[m
                         }[m
[31m-[m
[31m-                        var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-                        context.ReportDiagnostic(diagnostic);[m
                     }[m
 [m
[31m-                    public override void Initialize(AnalysisContext context)[m
[32m+[m[32m                    var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m                    context.ReportDiagnostics(diagnostic);[m
[32m+[m[32m            }[m
[32m+[m[41m            [m
[32m+[m[32m            public override void Initialize(AnalsisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }";[m
[32m+[m[32m            VerifyCSharpFix(test, fixtest);*/[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        [TestMethod][m
[32m+[m[32m        public void TestMethod5()[m
[32m+[m[32m        {[m
[32m+[m[32m            var test = @"using System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Collections.Immutable;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m[32musing Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Text;[m
[32m+[m
[32m+[m[32mnamespace SyntaxNodeAnalyzer[m
[32m+[m[32m{[m
[32m+[m[32m    [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[32m+[m[32m    public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m    {[m
[32m+[m[32m        public const string spacingRuleId = ""IfSpacing"";[m
[32m+[m
[32m+[m[32m        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m            id: spacingRuleId, //make the id specific[m
[32m+[m[32m            title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[32m+[m[32m            messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[32m+[m[32m            category: ""Syntax"", //make the category specific[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return ImmutableArray.Create(Rule);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public override void Initialize(AnalysisContext context)[m
[32m+[m[32m        {[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m        {[m
[32m+[m[32m            var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m            var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m            var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m            var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m
[32m+[m[32m            if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m            {[m
[32m+[m[32m                var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (trailingTrivia.ToString() == "" "")[m
                     {[m
[31m-                        throw new NotImplementedException();[m
[32m+[m[32m                        return;[m
                     }[m
                 }[m
[31m-            }";[m
[31m-                    VerifyCSharpFix(test, fixTest);*/[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m            context.ReportDiagnostic(diagnostic);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}";[m
[32m+[m[32m            var expected = new DiagnosticResult[m
[32m+[m[32m            {[m
[32m+[m[32m                Id = MetaCompilationAnalyzer.MissingRegisterStatement,[m
[32m+[m[32m                Message = "You need to register an action within the Initialize method",[m
[32m+[m[32m                Severity = DiagnosticSeverity.Error,[m
[32m+[m[32m                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 35, 30) }[m
[32m+[m[32m            };[m
[32m+[m
[32m+[m[32m            VerifyCSharpDiagnostic(test, expected);[m
         }[m
 [m
         protected override CodeFixProvider GetCSharpCodeFixProvider()[m

[33mcommit 09a4b3a33635d49b815f018aea309bc32348802f[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Fri Jun 12 16:07:13 2015 -0700

    Replacing GetType() and ToString() where possible

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 288f20a..eb53ea6 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -347,13 +347,13 @@[m [minternal bool CheckSupportedDiagnostics(List<string> ruleNames, CompilationAnaly[m
                     return false;[m
                 }[m
 [m
[31m-                if (returnExpression.GetType().ToString() == "Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax")[m
[32m+[m[32m                if (returnExpression is InvocationExpressionSyntax)[m
                 {[m
                     var valueClause = returnExpression as InvocationExpressionSyntax;[m
                     var returnDeclaration = returnStatement as ReturnStatementSyntax;[m
                     SuppDiagReturnCheck(context, valueClause, returnDeclaration.GetLocation(), ruleNames);[m
                 }[m
[31m-                else if (returnExpression.GetType().ToString() == "Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax")[m
[32m+[m[32m                else if (returnExpression is IdentifierNameSyntax)[m
                 {[m
                     SymbolInfo returnSymbolInfo = context.Compilation.GetSemanticModel(returnStatement.SyntaxTree).GetSymbolInfo(returnExpression as IdentifierNameSyntax);[m
                     List<object> symbolResult = SuppDiagReturnSymbol(context, returnSymbolInfo, getAccessorKeywordLocation);[m
[36m@@ -417,7 +417,7 @@[m [minternal SyntaxList<StatementSyntax> SuppDiagAccessor(CompilationAnalysisContext[m
                 }[m
 [m
                 var getAccessor = accessors.First() as AccessorDeclarationSyntax;[m
[31m-                if (getAccessor == null || getAccessor.Keyword.ToString() != "get")[m
[32m+[m[32m                if (getAccessor == null || getAccessor.Keyword.Kind() != SyntaxKind.GetKeyword)[m
                 {[m
                     ReportDiagnostic(context, MissingAccessorRule, propertyDeclaration.GetLocation(), MissingAccessorRule.MessageFormat);[m
                     return emptyResult;[m
[36m@@ -543,7 +543,7 @@[m [minternal List<string> CheckIds(string branch, string kind, CompilationAnalysisCo[m
                 List<string> idNames = new List<string>();[m
                 foreach (IFieldSymbol field in _analyzerFieldSymbols)[m
                 {[m
[31m-                    if (field.IsConst && field.IsStatic && field.DeclaredAccessibility == Accessibility.Public && field.Type.ToString() == "string")[m
[32m+[m[32m                    if (field.IsConst && field.IsStatic && field.DeclaredAccessibility == Accessibility.Public && field.Type.SpecialType == SpecialType.System_String)[m
                     {[m
                         if (field.Name == null)[m
                         {[m
[36m@@ -653,7 +653,7 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
             internal BlockSyntax InitializeOverview(CompilationAnalysisContext context)[m
             {[m
                 ImmutableArray<IParameterSymbol> parameters = _initializeSymbol.Parameters;[m
[31m-                if (parameters.Count() != 1 || parameters[0].Type.ToString() != "Microsoft.CodeAnalysis.Diagnostics.AnalysisContext" || parameters[0].Name.ToString() != "context" || _initializeSymbol.DeclaredAccessibility != Accessibility.Public || !_initializeSymbol.IsOverride || !_initializeSymbol.ReturnsVoid)[m
[32m+[m[32m                if (parameters.Count() != 1 || parameters[0].Type != context.Compilation.GetTypeByMetadataName("Microsoft.CodeAnalysis.Diagnostics.AnalysisContext") || parameters[0].Name.ToString() != "context" || _initializeSymbol.DeclaredAccessibility != Accessibility.Public || !_initializeSymbol.IsOverride || !_initializeSymbol.ReturnsVoid)[m
                 {[m
                     ReportDiagnostic(context, IncorrectInitSigRule, _initializeSymbol.Locations[0], MissingInitRule.MessageFormat);[m
                     return null;[m
[36m@@ -742,7 +742,7 @@[m [minternal void AddMethod(SymbolAnalysisContext context)[m
                 {[m
                     return;[m
                 }[m
[31m-                if (sym.ContainingType.BaseType.ToString() != "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer")[m
[32m+[m[32m                if (sym.ContainingType.BaseType != context.Compilation.GetTypeByMetadataName("Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"))[m
                 {[m
                     return;[m
                 }[m
[36m@@ -776,7 +776,7 @@[m [minternal void AddProperty(SymbolAnalysisContext context)[m
                 {[m
                     return;[m
                 }[m
[31m-                if (sym.ContainingType.BaseType.ToString() != "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer")[m
[32m+[m[32m                if (sym.ContainingType.BaseType != context.Compilation.GetTypeByMetadataName("Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"))[m
                 {[m
                     return;[m
                 }[m
[36m@@ -810,7 +810,7 @@[m [minternal void AddField(SymbolAnalysisContext context)[m
                 {[m
                     return;[m
                 }[m
[31m-                if (sym.ContainingType.BaseType.ToString() != "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer")[m
[32m+[m[32m                if (sym.ContainingType.BaseType != context.Compilation.GetTypeByMetadataName("Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"))[m
                 {[m
                     return;[m
                 }[m
[36m@@ -834,7 +834,7 @@[m [minternal void AddClass(SymbolAnalysisContext context)[m
                 {[m
                     return;[m
                 }[m
[31m-                if (sym.BaseType.ToString() != "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer")[m
[32m+[m[32m                if (sym.BaseType != context.Compilation.GetTypeByMetadataName("Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"))[m
                 {[m
                     if (sym.ContainingType == null)[m
                     {[m
[36m@@ -844,7 +844,7 @@[m [minternal void AddClass(SymbolAnalysisContext context)[m
                     {[m
                         return;[m
                     }[m
[31m-                    if (sym.ContainingType.BaseType.ToString() == "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer")[m
[32m+[m[32m                    if (sym.ContainingType.BaseType == context.Compilation.GetTypeByMetadataName("Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"))[m
                     {[m
                         if (_otherClassSymbols.Contains(sym))[m
                         {[m

[33mcommit b4fe4ac74d6e674b7247355bf14811036b9cc7f2[m
Author: zoepetard <t-zopet@microsoft.com>
Date:   Fri Jun 12 15:48:11 2015 -0700

    Formatted checkrules method

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 0a849b0..ab75924 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -284,11 +284,12 @@[m [minternal bool CheckSupportedDiagnostics(List<string> ruleNames, CompilationAnaly[m
             {[m
                 throw new NotImplementedException();[m
             }[m
[31m-            [m
[32m+[m
             //returns a list of rule names[m
             internal List<string> CheckRules(List<string> idNames, string branch, string kind, CompilationAnalysisContext context)[m
             {[m
                 Dictionary<string, string> foundRules = new Dictionary<string, string>(); //Dicitonary(Rule Id, Rule)[m
[32m+[m[41m                [m
                 List<string> ruleNames = new List<string>();[m
 [m
                 foreach (var fieldSymbol in _analyzerFieldSymbols)[m
[36m@@ -307,28 +308,27 @@[m [minternal List<string> CheckRules(List<string> idNames, string branch, string kin[m
                         for (int i = 0; i < ruleArgumentList.Arguments.Count; i++)[m
                         {[m
                             var currentArg = ruleArgumentList.Arguments[i];[m
[31m-                            var currentArgName = currentArg.NameColon.Name.ToString();[m
[31m-                            var currentArgExpr = currentArg.Expression.ToString();[m
[32m+[m[32m                            string currentArgName = currentArg.NameColon.Name.ToString();[m
[32m+[m[32m                            string currentArgExpr = currentArg.Expression.ToString();[m
 [m
                             if (currentArgName == "isEnabledByDefault" && currentArgExpr != "true")[m
                             {[m
                                 ReportDiagnostic(context, EnabledByDefaultErrorRule, currentArg.Expression.GetLocation(), EnabledByDefaultErrorRule.MessageFormat);[m
[31m-                            };[m
[32m+[m[32m                            }[m
 [m
[31m-                            if (currentArgName == "defaultSeverity")[m
[32m+[m[32m                            else if (currentArgName == "defaultSeverity")[m
                             {[m
[31m-[m
                                 var memberAccessExpr = currentArg.Expression as MemberAccessExpressionSyntax;[m
[31m-                                var identifierExpr = memberAccessExpr.Expression.ToString();[m
[31m-                                var identifierName = memberAccessExpr.Name.ToString();[m
[31m-                                if (identifierExpr != "DiagnosticSeverity" || identifierName == null)[m
[32m+[m[32m                                string identifierExpr = memberAccessExpr.Expression.ToString();[m
[32m+[m[32m                                string identifierName = memberAccessExpr.Name.ToString();[m
[32m+[m
[32m+[m[32m                                if (identifierExpr != "DiagnosticSeverity" && (identifierName != "Warning" || identifierName != "Error" || identifierName != "Hidden" || identifierName != "Info"))[m
                                 {[m
                                     ReportDiagnostic(context, DefaultSeverityErrorRule, currentArg.Expression.GetLocation(), DefaultSeverityErrorRule.MessageFormat);[m
                                 }[m
[31m-[m
                             }[m
 [m
[31m-                            if (currentArgName == "id")[m
[32m+[m[32m                            else if (currentArgName == "id")[m
                             {[m
                                 foundRules.Add(currentArgExpr, fieldSymbol.Name.ToString());[m
                                 bool ruleIdFound = false;[m
[36m@@ -354,7 +354,7 @@[m [minternal List<string> CheckRules(List<string> idNames, string branch, string kin[m
                 return ruleNames;[m
 [m
             }[m
[31m-            [m
[32m+[m
             //returns a list of id names, empty if none found[m
             internal List<string> CheckIds(string branch, string kind, CompilationAnalysisContext context)[m
             {[m

[33mcommit 8427a88252b014e82c4ffb6e17f9e39cec17e69f[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Fri Jun 12 15:45:40 2015 -0700

    Break down CheckInitialize

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex c22b70a..288f20a 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -574,21 +574,7 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                 else[m
                 {[m
                     //checking method signature[m
[31m-                    ImmutableArray<IParameterSymbol> parameters = _initializeSymbol.Parameters;[m
[31m-                    if (parameters.Count() != 1 || parameters[0].Type.ToString() != "Microsoft.CodeAnalysis.Diagnostics.AnalysisContext" || parameters[0].Name.ToString() != "context" || _initializeSymbol.DeclaredAccessibility != Accessibility.Public || !_initializeSymbol.IsOverride || !_initializeSymbol.ReturnsVoid)[m
[31m-                    {[m
[31m-                        ReportDiagnostic(context, IncorrectInitSigRule, _initializeSymbol.Locations[0], MissingInitRule.MessageFormat);[m
[31m-                        return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
[31m-                    }[m
[31m-                    [m
[31m-                    //looking at the contents of the initialize method[m
[31m-                    var initializeMethod = _initializeSymbol.DeclaringSyntaxReferences[0].GetSyntax() as MethodDeclarationSyntax;[m
[31m-                    if (initializeMethod == null)[m
[31m-                    {[m
[31m-                        return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
[31m-                    }[m
[31m-[m
[31m-                    var codeBlock = initializeMethod.Body as BlockSyntax;[m
[32m+[m[32m                    var codeBlock = InitializeOverview(context) as BlockSyntax;[m
                     if (codeBlock == null)[m
                     {[m
                         return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
[36m@@ -610,52 +596,15 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                     else[m
                     {[m
                         //only one statement inside initialize[m
[31m-                        var statement = statements[0] as ExpressionStatementSyntax;[m
[31m-                        if (statement == null)[m
[32m+[m[32m                        List<object> bodyResults = InitializeBody(context, statements);[m
[32m+[m[32m                        if (bodyResults == null)[m
                         {[m
[31m-                            ReportDiagnostic(context, IncorrectInitStatementRule, statements[0].GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[31m-                            return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
[31m-                        }[m
[31m-[m
[31m-                        var invocationExpr = statement.Expression as InvocationExpressionSyntax;[m
[31m-                        if (invocationExpr == null)[m
[31m-                        {[m
[31m-                            ReportDiagnostic(context, IncorrectInitStatementRule, statement.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
                             return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
[32m+[m[32m                        var invocationExpr = bodyResults[0] as InvocationExpressionSyntax;[m
[32m+[m[32m                        var memberExpr = bodyResults[1] as MemberAccessExpressionSyntax;[m
                         invocExpr = invocationExpr;[m
 [m
[31m-                        var memberExpr = invocationExpr.Expression as MemberAccessExpressionSyntax;[m
[31m-                        if (memberExpr == null)[m
[31m-                        {[m
[31m-                            ReportDiagnostic(context, IncorrectInitStatementRule, invocationExpr.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[31m-                            return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
[31m-                        }[m
[31m-[m
[31m-                        var memberExprContext = memberExpr.Expression as IdentifierNameSyntax;[m
[31m-                        if (memberExprContext == null)[m
[31m-                        {[m
[31m-                            ReportDiagnostic(context, IncorrectInitStatementRule, memberExpr.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[31m-                            return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
[31m-                        }[m
[31m-                        if (memberExprContext.Identifier.ToString() != "context")[m
[31m-                        {[m
[31m-                            ReportDiagnostic(context, IncorrectInitStatementRule, memberExprContext.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[31m-                            return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
[31m-                        }[m
[31m-[m
[31m-                        var memberExprRegister = memberExpr.Name as IdentifierNameSyntax;[m
[31m-                        if (memberExprRegister == null)[m
[31m-                        {[m
[31m-                            ReportDiagnostic(context, IncorrectInitStatementRule, memberExpr.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[31m-                            return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
[31m-                        }[m
[31m-                        if (!_branchesDict.ContainsKey(memberExprRegister.ToString()))[m
[31m-                        {[m
[31m-                            ReportDiagnostic(context, IncorrectInitStatementRule, memberExprRegister.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[31m-                            return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
[31m-                        }[m
[31m-[m
                         if (context.Compilation.GetSemanticModel(invocationExpr.SyntaxTree).GetSymbolInfo(memberExpr).CandidateSymbols.Count() == 0)[m
                         {[m
                             registerCall = context.Compilation.GetSemanticModel(memberExpr.SyntaxTree).GetSymbolInfo(memberExpr).Symbol as IMethodSymbol;[m
[36m@@ -700,6 +649,82 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                 return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
             }[m
 [m
[32m+[m[32m            #region CheckInitialize helpers[m
[32m+[m[32m            internal BlockSyntax InitializeOverview(CompilationAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                ImmutableArray<IParameterSymbol> parameters = _initializeSymbol.Parameters;[m
[32m+[m[32m                if (parameters.Count() != 1 || parameters[0].Type.ToString() != "Microsoft.CodeAnalysis.Diagnostics.AnalysisContext" || parameters[0].Name.ToString() != "context" || _initializeSymbol.DeclaredAccessibility != Accessibility.Public || !_initializeSymbol.IsOverride || !_initializeSymbol.ReturnsVoid)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectInitSigRule, _initializeSymbol.Locations[0], MissingInitRule.MessageFormat);[m
[32m+[m[32m                    return null;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                //looking at the contents of the initialize method[m
[32m+[m[32m                var initializeMethod = _initializeSymbol.DeclaringSyntaxReferences[0].GetSyntax() as MethodDeclarationSyntax;[m
[32m+[m[32m                if (initializeMethod == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return null;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var codeBlock = initializeMethod.Body as BlockSyntax;[m
[32m+[m[32m                if (codeBlock == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return null;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                return codeBlock;[m
[32m+[m[32m            }[m
[32m+[m[32m            internal List<object> InitializeBody(CompilationAnalysisContext context, SyntaxList<StatementSyntax> statements)[m
[32m+[m[32m            {[m
[32m+[m[32m                var statement = statements[0] as ExpressionStatementSyntax;[m
[32m+[m[32m                if (statement == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectInitStatementRule, statements[0].GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                    return null;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var invocationExpr = statement.Expression as InvocationExpressionSyntax;[m
[32m+[m[32m                if (invocationExpr == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectInitStatementRule, statement.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                    return null;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var memberExpr = invocationExpr.Expression as MemberAccessExpressionSyntax;[m
[32m+[m[32m                if (memberExpr == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectInitStatementRule, invocationExpr.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                    return null;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var memberExprContext = memberExpr.Expression as IdentifierNameSyntax;[m
[32m+[m[32m                if (memberExprContext == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectInitStatementRule, memberExpr.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                    return null;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (memberExprContext.Identifier.ToString() != "context")[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectInitStatementRule, memberExprContext.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                    return null;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var memberExprRegister = memberExpr.Name as IdentifierNameSyntax;[m
[32m+[m[32m                if (memberExprRegister == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectInitStatementRule, memberExpr.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                    return null;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (!_branchesDict.ContainsKey(memberExprRegister.ToString()))[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectInitStatementRule, memberExprRegister.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                    return null;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                return new List<object>(new object[] { invocationExpr, memberExpr });[m
[32m+[m[32m            }[m
[32m+[m[32m            #endregion[m
[32m+[m
             #region symbol collectors[m
             internal void AddMethod(SymbolAnalysisContext context)[m
             {[m

[33mcommit 8a21f9dd669a509e5567d1889847fcdae28e89a1[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Fri Jun 12 15:34:04 2015 -0700

    Add code fix for MissingRegisterStatement, fixes in test

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex 714cc0e..c3b05d0 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -5,6 +5,7 @@[m
 using Microsoft.CodeAnalysis.Diagnostics;[m
 using Microsoft.VisualStudio.TestTools.UnitTesting;[m
 using TestHelper;[m
[32m+[m[32musing System.Runtime;[m
 using MetaCompilation;[m
 [m
 namespace MetaCompilation.Test[m
[36m@@ -93,6 +94,7 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
         }[m
 [m
         //check missingId code fix and diagnostic[m
[32m+[m[32m        [TestMethod][m
         public void TestMethod3()[m
         {[m
             var test = @"using System;[m
[36m@@ -152,7 +154,7 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
                 }[m
 [m
                 var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-                obj.ReportDiagnostic(diagnostic);[m
[32m+[m[32m                context.ReportDiagnostic(diagnostic);[m
             }[m
         }[m
     }[m
[36m@@ -160,14 +162,15 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
             var expected = new DiagnosticResult[m
             {[m
                 Id = MetaCompilationAnalyzer.MissingId,[m
[31m-                Message = "You are missing a diagnostic Id",[m
[32m+[m[32m                Message = "You are missing a diagnostic id",[m
                 Severity = DiagnosticSeverity.Error,[m
                 Locations = new[] { new DiagnosticResultLocation("Test0.cs", 15, 22) }[m
             };[m
 [m
             VerifyCSharpDiagnostic(test, expected);[m
 [m
[31m-            var fixtest = @"using System;[m
[32m+[m[32m           /* var fixtest = @"using System;[m
[32m+[m[32musing System.Runtime;[m
 using System.Collections.Generic;[m
             using System.Collections.Immutable;[m
             using System.Linq;[m
[36m@@ -226,20 +229,22 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
                 }[m
 [m
                 var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-                obj.ReportDiagnostic(diagnostic);[m
[32m+[m[32m                context.ReportDiagnostic(diagnostic);[m
             }[m
         }[m
     }[m
 ";[m
[31m-            VerifyCSharpFix(test, fixtest);[m
[32m+[m[32m            VerifyCSharpFix(test, fixtest);*/[m
         }[m
 [m
         // test for missing Initialize method[m
[32m+[m[32m        [TestMethod][m
         public void TestMethod4()[m
         {[m
             var test = @"using System;[m
[32m+[m[32musing System.Runtime;[m
 using System.Collections.Generic;[m
[31m-            using System.Collections.Immutable;[m
[32m+[m[32m            using System.Collections;[m
             using System.Linq;[m
             using System.Threading;[m
             using Microsoft.CodeAnalysis;[m
[36m@@ -291,7 +296,7 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
                 }[m
 [m
                 var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-                obj.ReportDiagnostic(diagnostic);[m
[32m+[m[32m                context.ReportDiagnostic(diagnostic);[m
             }[m
         }[m
     }";[m
[36m@@ -300,75 +305,76 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
                 Id = MetaCompilationAnalyzer.MissingInit,[m
                 Message = "You are missing the required Initialize method",[m
                 Severity = DiagnosticSeverity.Error,[m
[31m-                Locations = new[] { new DiagnosticResultLocation("Test1.cs", 15, 22) }[m
[32m+[m[32m                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 16, 22) }[m
             };[m
 [m
             VerifyCSharpDiagnostic(test, expected);[m
 [m
[31m-            var fixTest = @"using System;[m
[31m-using System.Collections.Generic;[m
[31m-            using System.Collections.Immutable;[m
[31m-            using System.Linq;[m
[31m-            using System.Threading;[m
[31m-            using Microsoft.CodeAnalysis;[m
[31m-            using Microsoft.CodeAnalysis.CSharp;[m
[31m-            using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[31m-            using Microsoft.CodeAnalysis.Diagnostics;[m
[31m-            using Microsoft.CodeAnalysis.Text;[m
[32m+[m[32m                   /* var fixTest = @"using System;[m
[32m+[m[32m        using System.Runtime, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a;[m
[32m+[m[32m        using System.Collections.Generic;[m
[32m+[m[32m                    using System.Collections.Immutable;[m
[32m+[m[32m                    using System.Linq;[m
[32m+[m[32m                    using System.Threading;[m
[32m+[m[32m                    using Microsoft.CodeAnalysis;[m
[32m+[m[32m                    using Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32m                    using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32m                    using Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32m                    using Microsoft.CodeAnalysis.Text;[m
 [m
[31m-namespace SyntaxNodeAnalyzer[m
[31m-    {[m
[31m-        [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[31m-        public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[31m-        {[m
[31m-            public const string spacingRuleId = ""IfSpacing"";[m
[31m-[m
[31m-            internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[31m-                id: spacingRuleId, //make the id specific[m
[31m-                title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[31m-                messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[31m-                category: ""Syntax"", //make the category specific[m
[31m-                defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[31m-                isEnabledByDefault: true);[m
[31m-[m
[31m-            public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[32m+[m[32m        namespace SyntaxNodeAnalyzer[m
             {[m
[31m-                get[m
[32m+[m[32m                [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[32m+[m[32m                public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
                 {[m
[31m-                    return ImmutableArray.Create(Rule);[m
[31m-                }[m
[31m-            }[m
[32m+[m[32m                    public const string spacingRuleId = ""IfSpacing"";[m
 [m
[31m-            private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[31m-            {[m
[31m-                var ifStatement = (IfStatementSyntax)context.Node;[m
[31m-                var ifKeyword = ifStatement.IfKeyword;[m
[31m-                var openParen = ifStatement.OpenParenToken;[m
[31m-                var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m[32m                    internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m                        id: spacingRuleId, //make the id specific[m
[32m+[m[32m                        title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[32m+[m[32m                        messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[32m+[m[32m                        category: ""Syntax"", //make the category specific[m
[32m+[m[32m                        defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m                        isEnabledByDefault: true);[m
 [m
[31m-                if (ifKeyword.HasTrailingTrivia)[m
[31m-                {[m
[31m-                    var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[31m-                    if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
                     {[m
[31m-                        if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                        get[m
                         {[m
[31m-                            return;[m
[32m+[m[32m                            return ImmutableArray.Create(Rule);[m
                         }[m
                     }[m
[32m+[m
[32m+[m[32m                    private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m                        var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m                        var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m                        var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m
[32m+[m[32m                        if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                            if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                            {[m
[32m+[m[32m                                if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    return;[m
[32m+[m[32m                                }[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m                        context.ReportDiagnostic(diagnostic);[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    public override void Initialize(AnalysisContext context)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        throw new NotImplementedException();[m
[32m+[m[32m                    }[m
                 }[m
[31m-[m
[31m-                var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-                obj.ReportDiagnostic(diagnostic);[m
[31m-            }[m
[31m-[m
[31m-            public override void Initialize(AnalysisContext context)[m
[31m-            {[m
[31m-                throw new NotImplementedException();[m
[31m-            }[m
[31m-        }[m
[31m-    }";[m
[31m-            VerifyCSharpFix(test, fixTest);[m
[32m+[m[32m            }";[m
[32m+[m[32m                    VerifyCSharpFix(test, fixTest);*/[m
         }[m
 [m
         protected override CodeFixProvider GetCSharpCodeFixProvider()[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1mindex b01a18b..e68edcd 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[36m@@ -25,7 +25,7 @@[m [mpublic override ImmutableArray<string> FixableDiagnosticIds[m
             get[m
             {[m
                 //TODO: add any new rules[m
[31m-                return ImmutableArray.Create(MetaCompilationAnalyzer.MissingId, MetaCompilationAnalyzer.MissingInit);[m
[32m+[m[32m                return ImmutableArray.Create(MetaCompilationAnalyzer.MissingId, MetaCompilationAnalyzer.MissingInit, MetaCompilationAnalyzer.MissingRegisterStatement);[m
             }[m
         }[m
 [m
[36m@@ -54,6 +54,12 @@[m [mpublic sealed override FixAllProvider GetFixAllProvider()[m
                     ClassDeclarationSyntax declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<ClassDeclarationSyntax>().First();[m
                     context.RegisterCodeFix(CodeAction.Create("Each analyzer must have an Initialize method to register actions to be performed when changes occur", c => MissingInitAsync(context.Document, declaration, c)), diagnostic);[m
                 }[m
[32m+[m
[32m+[m[32m                if (diagnostic.Id.Equals(MetaCompilationAnalyzer.MissingRegisterStatement))[m
[32m+[m[32m                {[m
[32m+[m[32m                    MethodDeclarationSyntax declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<MethodDeclarationSyntax>().First();[m
[32m+[m[32m                    context.RegisterCodeFix(CodeAction.Create("The Initialize method must register an action to be performed when changes occur", c => MissingRegisterAsync(context.Document, declaration, c)), diagnostic);[m
[32m+[m[32m                }[m
             }[m
         }[m
 [m
[36m@@ -114,5 +120,19 @@[m [mpublic sealed override FixAllProvider GetFixAllProvider()[m
 [m
             return newDocument;[m
         }[m
[32m+[m
[32m+[m[32m        private async Task<Document> MissingRegisterAsync(Document document, MethodDeclarationSyntax declaration, CancellationToken c)[m
[32m+[m[32m        {[m
[32m+[m[32m            var registerExpression = SyntaxFactory.ExpressionStatement(SyntaxFactory.ParseExpression("context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement)"));[m
[32m+[m
[32m+[m[32m            var newInitBlock = SyntaxFactory.Block(registerExpression);[m
[32m+[m[32m            var newInitDeclaration = declaration.WithBody(newInitBlock);[m
[32m+[m
[32m+[m[32m            var root = await document.GetSyntaxRootAsync();[m
[32m+[m[32m            var newRoot = root.ReplaceNode(declaration, newInitDeclaration);[m
[32m+[m[32m            var newDocument = document.WithSyntaxRoot(newRoot);[m
[32m+[m
[32m+[m[32m            return newDocument;[m
[32m+[m[32m        }[m
     }[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[1mindex b2b2142..00b8af5 100644[m
[1m--- a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[36m@@ -58,7 +58,7 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
             }[m
 [m
             var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-            obj.ReportDiagnostic(diagnostic);[m
[32m+[m[32m            context.ReportDiagnostic(diagnostic);[m
         }[m
     }[m
 }[m

[33mcommit 331ae337f00bf66e7656495b3cc840ec78a9b6af[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Fri Jun 12 15:27:06 2015 -0700

    Break down CheckSupportedDiagnostics

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex 7c5c1e9..0c2ef77 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -86,7 +86,7 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
                 }[m
 [m
                 var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-                obj.ReportDiagnostic(diagnostic);[m
[32m+[m[32m                context.ReportDiagnostic(diagnostic);[m
             }[m
         }[m
     }[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex d86c132..c22b70a 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -310,83 +310,40 @@[m [minternal bool CheckAnalysis(string branch, string kind, List<string> ruleNames,[m
             //returns a boolean based on whether or not the SupportedDiagnostics property is correct[m
             internal bool CheckSupportedDiagnostics(List<string> ruleNames, CompilationAnalysisContext context)[m
             {[m
[31m-                if (_propertySymbol == null)[m
[31m-                {[m
[31m-                    ReportDiagnostic(context, MissingSuppDiagRule, _analyzerClassSymbol.Locations[0], MissingSuppDiagRule.MessageFormat);[m
[31m-                    return false;[m
[31m-                }[m
[31m-[m
[31m-                if (_propertySymbol.Name.ToString() != "SupportedDiagnostics" || _propertySymbol.DeclaredAccessibility != Accessibility.Public || [m
[31m-                    !_propertySymbol.IsOverride || _propertySymbol.OverriddenProperty.ToString() != "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics" [m
[31m-                    || _propertySymbol.Type.ToString() != "System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.DiagnosticDescriptor>")[m
[31m-                {[m
[31m-                    ReportDiagnostic(context, IncorrectSigSuppDiagRule, _propertySymbol.Locations[0], IncorrectSigSuppDiagRule.MessageFormat);[m
[31m-                    return false;[m
[31m-                }[m
[31m-[m
[31m-                var propertyDeclaration = _propertySymbol.DeclaringSyntaxReferences[0].GetSyntax() as PropertyDeclarationSyntax;[m
[32m+[m[32m                var propertyDeclaration = SuppDiagPropertySymbol(context);[m
                 if (propertyDeclaration == null)[m
                 {[m
                     return false;[m
                 }[m
 [m
[31m-                AccessorListSyntax accessorList = propertyDeclaration.AccessorList;[m
[31m-                if (accessorList == null)[m
[31m-                {[m
[31m-                    return false;[m
[31m-                }[m
[32m+[m[32m                SyntaxList<StatementSyntax> statements = SuppDiagAccessor(context, propertyDeclaration);[m
 [m
[31m-                SyntaxList<AccessorDeclarationSyntax> accessors = accessorList.Accessors;[m
[31m-                if (accessors == null || accessors.Count == 0)[m
[31m-                {[m
[31m-                    ReportDiagnostic(context, MissingAccessorRule, propertyDeclaration.GetLocation(), MissingAccessorRule.MessageFormat);[m
[31m-                    return false;[m
[31m-                }[m
[31m-                if (accessors.Count > 1)[m
[31m-                {[m
[31m-                    ReportDiagnostic(context, TooManyAccessorsRule, accessorList.GetLocation(), TooManyAccessorsRule.MessageFormat);[m
[31m-                    return false;[m
[31m-                }[m
[31m-[m
[31m-                var getAccessor = accessors.First() as AccessorDeclarationSyntax;[m
[31m-                if (getAccessor == null || getAccessor.Keyword.ToString() != "get")[m
[31m-                {[m
[31m-                    ReportDiagnostic(context, MissingAccessorRule, propertyDeclaration.GetLocation(), MissingAccessorRule.MessageFormat);[m
[31m-                    return false;[m
[31m-                }[m
[31m-[m
[31m-                var accessorBody = getAccessor.Body as BlockSyntax;[m
[31m-                if (accessorBody == null)[m
[31m-                {[m
[31m-                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessor.Keyword.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[31m-                    return false;[m
[31m-                }[m
[31m-[m
[31m-                SyntaxList<StatementSyntax> statements = accessorBody.Statements;[m
                 if (statements.Count == 0)[m
                 {[m
[31m-                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessor.Keyword.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, propertyDeclaration.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
                     return false;[m
                 }[m
 [m
[32m+[m[32m                var getAccessorKeywordLocation = propertyDeclaration.AccessorList.Accessors.First().GetLocation();[m
[32m+[m
                 IEnumerable<ReturnStatementSyntax> returnStatements = statements.OfType<ReturnStatementSyntax>();[m
                 if (returnStatements.Count() == 0)[m
                 {[m
[31m-                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessor.Keyword.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessorKeywordLocation, IncorrectAccessorReturnRule.MessageFormat);[m
                     return false;[m
                 }[m
 [m
                 ReturnStatementSyntax returnStatement = returnStatements.First();[m
                 if (returnStatement == null)[m
                 {[m
[31m-                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessor.Keyword.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessorKeywordLocation, IncorrectAccessorReturnRule.MessageFormat);[m
                     return false;[m
                 }[m
 [m
                 var returnExpression = returnStatement.Expression;[m
                 if (returnExpression == null)[m
                 {[m
[31m-                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessor.Keyword.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessorKeywordLocation, IncorrectAccessorReturnRule.MessageFormat);[m
                     return false;[m
                 }[m
 [m
[36m@@ -394,152 +351,189 @@[m [minternal bool CheckSupportedDiagnostics(List<string> ruleNames, CompilationAnaly[m
                 {[m
                     var valueClause = returnExpression as InvocationExpressionSyntax;[m
                     var returnDeclaration = returnStatement as ReturnStatementSyntax;[m
[31m-                    if (valueClause == null)[m
[31m-                    {[m
[31m-                        ReportDiagnostic(context, IncorrectAccessorReturnRule, returnDeclaration.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[31m-                        return false;[m
[31m-                    }[m
[31m-[m
[31m-                    var valueExpression = valueClause.Expression as MemberAccessExpressionSyntax;[m
[31m-                    if (valueExpression == null)[m
[31m-                    {[m
[31m-                        ReportDiagnostic(context, IncorrectAccessorReturnRule, returnDeclaration.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[31m-                        return false;[m
[31m-                    }[m
[31m-[m
[31m-                    if (valueExpression.ToString() != "ImmutableArray.Create")[m
[31m-                    {[m
[31m-                        ReportDiagnostic(context, SuppDiagReturnValueRule, returnDeclaration.GetLocation(), SuppDiagReturnValueRule.MessageFormat);[m
[31m-                        return false;[m
[31m-                    }[m
[31m-[m
[31m-                    var valueArguments = valueClause.ArgumentList as ArgumentListSyntax;[m
[31m-                    if (valueArguments == null)[m
[31m-                    {[m
[31m-                        return false;[m
[31m-                    }[m
[31m-[m
[31m-                    SeparatedSyntaxList<ArgumentSyntax> valueArgs = valueArguments.Arguments;[m
[31m-                    if (valueArgs == null)[m
[31m-                    {[m
[31m-                        return false;[m
[31m-                    }[m
[31m-[m
[31m-[m
[31m-                    foreach (ArgumentSyntax arg in valueArgs)[m
[31m-                    {[m
[31m-                        if (ruleNames.Count == 0)[m
[31m-                        {[m
[31m-                            ReportDiagnostic(context, SupportedRulesRule, valueExpression.GetLocation(), SupportedRulesRule.MessageFormat);[m
[31m-                            return false;[m
[31m-                        }[m
[31m-                        if (ruleNames.Contains(arg.ToString()))[m
[31m-                        {[m
[31m-                            ruleNames.Remove(arg.ToString());[m
[31m-                        }[m
[31m-                    }[m
[32m+[m[32m                    SuppDiagReturnCheck(context, valueClause, returnDeclaration.GetLocation(), ruleNames);[m
                 }[m
                 else if (returnExpression.GetType().ToString() == "Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax")[m
                 {[m
[31m-                    var returnSymbolInfo = context.Compilation.GetSemanticModel(returnStatement.SyntaxTree).GetSymbolInfo(returnExpression as IdentifierNameSyntax);[m
[31m-                    ILocalSymbol returnSymbol = null;[m
[31m-                    if (returnSymbolInfo.CandidateSymbols.Count() == 0)[m
[31m-                    {[m
[31m-                        returnSymbol = returnSymbolInfo.Symbol as ILocalSymbol;[m
[31m-                    }[m
[31m-                    else[m
[31m-                    {[m
[31m-                        returnSymbol = returnSymbolInfo.CandidateSymbols[0] as ILocalSymbol;[m
[31m-                    }[m
[31m-[m
[31m-                    if (returnSymbol == null)[m
[31m-                    {[m
[31m-                        ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessor.Keyword.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[31m-                        return false;[m
[31m-                    }[m
[31m-[m
[31m-                    if (returnSymbol.Type.ToString() != "System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.DiagnosticDescriptor>")[m
[31m-                    {[m
[31m-                        ReportDiagnostic(context, IncorrectAccessorReturnRule, returnSymbol.Locations[0], IncorrectAccessorReturnRule.MessageFormat);[m
[31m-                        return false;[m
[31m-                    }[m
[31m-[m
[31m-                    var returnDeclaration = returnSymbol.DeclaringSyntaxReferences[0].GetSyntax() as VariableDeclaratorSyntax;[m
[31m-                    if (returnDeclaration == null)[m
[31m-                    {[m
[31m-                        ReportDiagnostic(context, IncorrectAccessorReturnRule, returnSymbol.Locations[0], IncorrectAccessorReturnRule.MessageFormat);[m
[31m-                        return false;[m
[31m-                    }[m
[31m-[m
[31m-                    var equalsValueClause = returnDeclaration.Initializer as EqualsValueClauseSyntax;[m
[31m-                    if (equalsValueClause == null)[m
[31m-                    {[m
[31m-                        ReportDiagnostic(context, IncorrectAccessorReturnRule, returnDeclaration.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[31m-                        return false;[m
[31m-                    }[m
[31m-[m
[31m-                    var valueClause = equalsValueClause.Value as InvocationExpressionSyntax;[m
[31m-                    if (valueClause == null)[m
[31m-                    {[m
[31m-                        ReportDiagnostic(context, IncorrectAccessorReturnRule, returnDeclaration.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[31m-                        return false;[m
[31m-                    }[m
[31m-[m
[31m-                    var valueExpression = valueClause.Expression as MemberAccessExpressionSyntax;[m
[31m-                    if (valueExpression == null)[m
[31m-                    {[m
[31m-                        ReportDiagnostic(context, IncorrectAccessorReturnRule, returnDeclaration.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[31m-                        return false;[m
[31m-                    }[m
[31m-[m
[31m-                    if (valueExpression.ToString() != "ImmutableArray.Create")[m
[31m-                    {[m
[31m-                        ReportDiagnostic(context, SuppDiagReturnValueRule, returnDeclaration.GetLocation(), SuppDiagReturnValueRule.MessageFormat);[m
[31m-                        return false;[m
[31m-                    }[m
[31m-[m
[31m-                    var valueArguments = valueClause.ArgumentList as ArgumentListSyntax;[m
[31m-                    if (valueArguments == null)[m
[32m+[m[32m                    SymbolInfo returnSymbolInfo = context.Compilation.GetSemanticModel(returnStatement.SyntaxTree).GetSymbolInfo(returnExpression as IdentifierNameSyntax);[m
[32m+[m[32m                    List<object> symbolResult = SuppDiagReturnSymbol(context, returnSymbolInfo, getAccessorKeywordLocation);[m
[32m+[m[32m                    if (symbolResult.Count == 0)[m
                     {[m
                         return false;[m
                     }[m
 [m
[31m-                    SeparatedSyntaxList<ArgumentSyntax> valueArgs = valueArguments.Arguments;[m
[31m-                    if (valueArgs == null)[m
[31m-                    {[m
[31m-                        return false;[m
[31m-                    }[m
[31m-[m
[31m-                    [m
[31m-                    foreach (ArgumentSyntax arg in valueArgs)[m
[31m-                    {[m
[31m-                        if (ruleNames.Count == 0)[m
[31m-                        {[m
[31m-                            ReportDiagnostic(context, SupportedRulesRule, valueExpression.GetLocation(), SupportedRulesRule.MessageFormat);[m
[31m-                            return false;[m
[31m-                        }[m
[31m-                        if (ruleNames.Contains(arg.ToString()))[m
[31m-                        {[m
[31m-                            ruleNames.Remove(arg.ToString());[m
[31m-                        }[m
[31m-                    }[m
[31m-[m
[31m-[m
[32m+[m[32m                    InvocationExpressionSyntax valueClause = symbolResult[0] as InvocationExpressionSyntax;[m
[32m+[m[32m                    VariableDeclaratorSyntax returnDeclaration = symbolResult[1] as VariableDeclaratorSyntax;[m
[32m+[m[32m                    SuppDiagReturnCheck(context, valueClause, returnDeclaration.GetLocation(), ruleNames);[m
                 }[m
                 else[m
                 {[m
[31m-                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessor.Keyword.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessorKeywordLocation, IncorrectAccessorReturnRule.MessageFormat);[m
                     return false;[m
                 }[m
 [m
                 return true;[m
 [m
             }[m
[31m-            [m
[32m+[m
[32m+[m[32m            #region CheckSupportedDiagnostics helpers[m
[32m+[m[32m            internal PropertyDeclarationSyntax SuppDiagPropertySymbol(CompilationAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (_propertySymbol == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, MissingSuppDiagRule, _analyzerClassSymbol.Locations[0], MissingSuppDiagRule.MessageFormat);[m
[32m+[m[32m                    return null;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (_propertySymbol.Name.ToString() != "SupportedDiagnostics" || _propertySymbol.DeclaredAccessibility != Accessibility.Public ||[m
[32m+[m[32m                    !_propertySymbol.IsOverride || _propertySymbol.OverriddenProperty.ToString() != "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics")[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectSigSuppDiagRule, _propertySymbol.Locations[0], IncorrectSigSuppDiagRule.MessageFormat);[m
[32m+[m[32m                    return null;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                return _propertySymbol.DeclaringSyntaxReferences[0].GetSyntax() as PropertyDeclarationSyntax;[m
[32m+[m[32m            }[m
[32m+[m[32m            internal SyntaxList<StatementSyntax> SuppDiagAccessor(CompilationAnalysisContext context, PropertyDeclarationSyntax propertyDeclaration)[m
[32m+[m[32m            {[m
[32m+[m[32m                SyntaxList<StatementSyntax> emptyResult = new SyntaxList<StatementSyntax>();[m
[32m+[m
[32m+[m[32m                AccessorListSyntax accessorList = propertyDeclaration.AccessorList;[m
[32m+[m[32m                if (accessorList == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return emptyResult;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                SyntaxList<AccessorDeclarationSyntax> accessors = accessorList.Accessors;[m
[32m+[m[32m                if (accessors == null || accessors.Count == 0)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, MissingAccessorRule, propertyDeclaration.GetLocation(), MissingAccessorRule.MessageFormat);[m
[32m+[m[32m                    return emptyResult;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (accessors.Count > 1)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, TooManyAccessorsRule, accessorList.GetLocation(), TooManyAccessorsRule.MessageFormat);[m
[32m+[m[32m                    return emptyResult;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var getAccessor = accessors.First() as AccessorDeclarationSyntax;[m
[32m+[m[32m                if (getAccessor == null || getAccessor.Keyword.ToString() != "get")[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, MissingAccessorRule, propertyDeclaration.GetLocation(), MissingAccessorRule.MessageFormat);[m
[32m+[m[32m                    return emptyResult;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var accessorBody = getAccessor.Body as BlockSyntax;[m
[32m+[m[32m                if (accessorBody == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessor.Keyword.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    return emptyResult;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                return accessorBody.Statements;[m
[32m+[m[32m            }[m
[32m+[m[32m            internal void SuppDiagReturnCheck(CompilationAnalysisContext context, InvocationExpressionSyntax valueClause, Location returnDeclarationLocation, List<string> ruleNames)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (valueClause == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, returnDeclarationLocation, IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var valueExpression = valueClause.Expression as MemberAccessExpressionSyntax;[m
[32m+[m[32m                if (valueExpression == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, returnDeclarationLocation, IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (valueExpression.ToString() != "ImmutableArray.Create")[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, SuppDiagReturnValueRule, returnDeclarationLocation, SuppDiagReturnValueRule.MessageFormat);[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var valueArguments = valueClause.ArgumentList as ArgumentListSyntax;[m
[32m+[m[32m                if (valueArguments == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                SeparatedSyntaxList<ArgumentSyntax> valueArgs = valueArguments.Arguments;[m
[32m+[m[32m                if (valueArgs == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m
[32m+[m[32m                foreach (ArgumentSyntax arg in valueArgs)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (ruleNames.Count == 0)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ReportDiagnostic(context, SupportedRulesRule, valueExpression.GetLocation(), SupportedRulesRule.MessageFormat);[m
[32m+[m[32m                        return;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (ruleNames.Contains(arg.ToString()))[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ruleNames.Remove(arg.ToString());[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            internal List<object> SuppDiagReturnSymbol(CompilationAnalysisContext context, SymbolInfo returnSymbolInfo, Location getAccessorKeywordLocation)[m
[32m+[m[32m            {[m
[32m+[m[32m                List<object> result = new List<object>();[m
[32m+[m
[32m+[m[32m                ILocalSymbol returnSymbol = null;[m
[32m+[m[32m                if (returnSymbolInfo.CandidateSymbols.Count() == 0)[m
[32m+[m[32m                {[m
[32m+[m[32m                    returnSymbol = returnSymbolInfo.Symbol as ILocalSymbol;[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    returnSymbol = returnSymbolInfo.CandidateSymbols[0] as ILocalSymbol;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (returnSymbol == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessorKeywordLocation, IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    return result;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (returnSymbol.Type.ToString() != "System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.DiagnosticDescriptor>")[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, returnSymbol.Locations[0], IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    return result;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var returnDeclaration = returnSymbol.DeclaringSyntaxReferences[0].GetSyntax() as VariableDeclaratorSyntax;[m
[32m+[m[32m                if (returnDeclaration == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, returnSymbol.Locations[0], IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    return result;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var equalsValueClause = returnDeclaration.Initializer as EqualsValueClauseSyntax;[m
[32m+[m[32m                if (equalsValueClause == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, returnDeclaration.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    return result;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var valueClause = equalsValueClause.Value as InvocationExpressionSyntax;[m
[32m+[m
[32m+[m[32m                result.Add(valueClause);[m
[32m+[m[32m                result.Add(returnDeclaration);[m
[32m+[m[32m                return result;[m
[32m+[m[32m            }[m
[32m+[m[32m            #endregion[m
[32m+[m
             //returns a list of rule names[m
             internal List<string> CheckRules(List<string> idNames, string branch, string kind, CompilationAnalysisContext context)[m
             {[m
[31m-                throw new NotImplementedException();[m
[32m+[m[32m                //TODO: change back to not implemented[m
[32m+[m[32m                var result = new List<string>();[m
[32m+[m[32m                result.Add("Rule");[m
[32m+[m[32m                return result;[m
 [m
             }[m
             [m

[33mcommit 62b57a3f40362a3bdd60967aa3886a329d689185[m
Merge: 843f29f a9a354e
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Fri Jun 12 15:13:29 2015 -0700

    Merge remote-tracking branch 'dotnet/master' into TestMissingId

[33mcommit 8bd436bf2e5fb4b4d17a89551cd8e614e39b8439[m
Author: zoepetard <t-zopet@microsoft.com>
Date:   Fri Jun 12 15:00:22 2015 -0700

    check rules method

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 45afc7f..0a849b0 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -15,6 +15,46 @@[m [mnamespace MetaCompilation[m
     public class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
     {[m
 [m
[32m+[m[32m        #region rule rules[m
[32m+[m
[32m+[m[32m        public const string MissingIdDeclaration = "MetaAnalyzer017";[m
[32m+[m[32m        internal static DiagnosticDescriptor MissingIdDeclarationRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: MissingIdDeclaration,[m
[32m+[m[32m            title: "This diagnoctic id has not been declared.",[m
[32m+[m[32m            messageFormat: "This diagnoctic id has not been declared.",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public const string DefaultSeverityError = "MetaAnalyzer016";[m
[32m+[m[32m        internal static DiagnosticDescriptor DefaultSeverityErrorRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: DefaultSeverityError,[m
[32m+[m[32m            title: "defaultSeverity must be of the form: DiagnosticSeverity.[severity].",[m
[32m+[m[32m            messageFormat: "defaultSeverity must be of the form: DiagnosticSeverity.[severity].",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public const string EnabledByDefaultError = "MetaAnalyzer015";[m
[32m+[m[32m        internal static DiagnosticDescriptor EnabledByDefaultErrorRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: EnabledByDefaultError,[m
[32m+[m[32m            title: "isEnabledByDefault should be set to true.",[m
[32m+[m[32m            messageFormat: "isEnabledByDefault should be set to true.",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public const string InternalAndStaticError = "MetaAnalyzer014";[m
[32m+[m[32m        internal static DiagnosticDescriptor InternalAndStaticErrorRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: InternalAndStaticError,[m
[32m+[m[32m            title: "The DiagnosticDescriptor should be internal and static.",[m
[32m+[m[32m            messageFormat: "The DiagnosticDescriptor should be internal and static.",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m[32m        #endregion[m
[32m+[m
[32m+[m
         #region id rules[m
         public const string MissingId = "missingId";[m
         internal static DiagnosticDescriptor MissingIdRule = new DiagnosticDescriptor([m
[36m@@ -77,7 +117,16 @@[m [mpublic override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
         {[m
             get[m
             {[m
[31m-                return ImmutableArray.Create(MissingIdRule, MissingInitRule, MissingRegisterRule, TooManyInitStatementsRule, IncorrectInitStatementRule, IncorrectInitSigRule);[m
[32m+[m[32m                return ImmutableArray.Create(MissingIdRule,[m[41m [m
[32m+[m[32m                                             MissingInitRule,[m[41m [m
[32m+[m[32m                                             MissingRegisterRule,[m[41m [m
[32m+[m[32m                                             TooManyInitStatementsRule,[m[41m [m
[32m+[m[32m                                             IncorrectInitStatementRule,[m[41m [m
[32m+[m[32m                                             IncorrectInitSigRule,[m
[32m+[m[32m                                             MissingIdDeclarationRule,[m[41m [m
[32m+[m[32m                                             EnabledByDefaultErrorRule,[m[41m [m
[32m+[m[32m                                             DefaultSeverityErrorRule,[m[41m [m
[32m+[m[32m                                             InternalAndStaticErrorRule);[m
             }[m
         }[m
 [m
[36m@@ -239,7 +288,70 @@[m [minternal bool CheckSupportedDiagnostics(List<string> ruleNames, CompilationAnaly[m
             //returns a list of rule names[m
             internal List<string> CheckRules(List<string> idNames, string branch, string kind, CompilationAnalysisContext context)[m
             {[m
[31m-                throw new NotImplementedException();[m
[32m+[m[32m                Dictionary<string, string> foundRules = new Dictionary<string, string>(); //Dicitonary(Rule Id, Rule)[m
[32m+[m[32m                List<string> ruleNames = new List<string>();[m
[32m+[m
[32m+[m[32m                foreach (var fieldSymbol in _analyzerFieldSymbols)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (fieldSymbol.Type.MetadataName == "DiagnosticDescriptor")[m
[32m+[m[32m                    {[m
[32m+[m[32m                        if (fieldSymbol.DeclaredAccessibility != Accessibility.Internal || !fieldSymbol.IsStatic)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            ReportDiagnostic(context, InternalAndStaticErrorRule, fieldSymbol.Locations[0], InternalAndStaticErrorRule.MessageFormat);[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        var declaratorSyntax = fieldSymbol.DeclaringSyntaxReferences[0].GetSyntax() as VariableDeclaratorSyntax;[m
[32m+[m[32m                        var objectCreationSyntax = declaratorSyntax.Initializer.Value as ObjectCreationExpressionSyntax;[m
[32m+[m[32m                        var ruleArgumentList = objectCreationSyntax.ArgumentList;[m
[32m+[m
[32m+[m[32m                        for (int i = 0; i < ruleArgumentList.Arguments.Count; i++)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            var currentArg = ruleArgumentList.Arguments[i];[m
[32m+[m[32m                            var currentArgName = currentArg.NameColon.Name.ToString();[m
[32m+[m[32m                            var currentArgExpr = currentArg.Expression.ToString();[m
[32m+[m
[32m+[m[32m                            if (currentArgName == "isEnabledByDefault" && currentArgExpr != "true")[m
[32m+[m[32m                            {[m
[32m+[m[32m                                ReportDiagnostic(context, EnabledByDefaultErrorRule, currentArg.Expression.GetLocation(), EnabledByDefaultErrorRule.MessageFormat);[m
[32m+[m[32m                            };[m
[32m+[m
[32m+[m[32m                            if (currentArgName == "defaultSeverity")[m
[32m+[m[32m                            {[m
[32m+[m
[32m+[m[32m                                var memberAccessExpr = currentArg.Expression as MemberAccessExpressionSyntax;[m
[32m+[m[32m                                var identifierExpr = memberAccessExpr.Expression.ToString();[m
[32m+[m[32m                                var identifierName = memberAccessExpr.Name.ToString();[m
[32m+[m[32m                                if (identifierExpr != "DiagnosticSeverity" || identifierName == null)[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    ReportDiagnostic(context, DefaultSeverityErrorRule, currentArg.Expression.GetLocation(), DefaultSeverityErrorRule.MessageFormat);[m
[32m+[m[32m                                }[m
[32m+[m
[32m+[m[32m                            }[m
[32m+[m
[32m+[m[32m                            if (currentArgName == "id")[m
[32m+[m[32m                            {[m
[32m+[m[32m                                foundRules.Add(currentArgExpr, fieldSymbol.Name.ToString());[m
[32m+[m[32m                                bool ruleIdFound = false;[m
[32m+[m
[32m+[m[32m                                foreach (string idName in idNames)[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    if (idName == foundRules.Last().Key)[m
[32m+[m[32m                                    {[m
[32m+[m[32m                                        ruleNames.Add(foundRules.Last().Value);[m
[32m+[m[32m                                        ruleIdFound = true;[m
[32m+[m[32m                                    }[m
[32m+[m[32m                                }[m
[32m+[m
[32m+[m[32m                                if (!ruleIdFound)[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    var ruleNotFound = foundRules.Last().Value;[m
[32m+[m[32m                                    ReportDiagnostic(context, MissingIdDeclarationRule, currentArg.Expression.GetLocation(), MissingIdDeclarationRule.MessageFormat);[m
[32m+[m[32m                                }[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                return ruleNames;[m
 [m
             }[m
             [m

[33mcommit 843f29f8e7cf1a061fa630306a6fb8da757f257f[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Fri Jun 12 14:09:11 2015 -0700

    Added test for missing Initializer

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex 2868678..714cc0e 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -234,6 +234,143 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
             VerifyCSharpFix(test, fixtest);[m
         }[m
 [m
[32m+[m[32m        // test for missing Initialize method[m
[32m+[m[32m        public void TestMethod4()[m
[32m+[m[32m        {[m
[32m+[m[32m            var test = @"using System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32m            using System.Collections.Immutable;[m
[32m+[m[32m            using System.Linq;[m
[32m+[m[32m            using System.Threading;[m
[32m+[m[32m            using Microsoft.CodeAnalysis;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.Text;[m
[32m+[m
[32m+[m[32mnamespace SyntaxNodeAnalyzer[m
[32m+[m[32m    {[m
[32m+[m[32m        [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[32m+[m[32m        public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m        {[m
[32m+[m[32m            public const string spacingRuleId = ""IfSpacing"";[m
[32m+[m
[32m+[m[32m            internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m                id: spacingRuleId, //make the id specific[m
[32m+[m[32m                title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[32m+[m[32m                messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[32m+[m[32m                category: ""Syntax"", //make the category specific[m
[32m+[m[32m                defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m                isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m            public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[32m+[m[32m            {[m
[32m+[m[32m                get[m
[32m+[m[32m                {[m
[32m+[m[32m                    return ImmutableArray.Create(Rule);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m                var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m                var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m                var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m
[32m+[m[32m                if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m                {[m
[32m+[m[32m                    var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                    if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                        {[m
[32m+[m[32m                            return;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m                obj.ReportDiagnostic(diagnostic);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }";[m
[32m+[m[32m            var expected = new DiagnosticResult[m
[32m+[m[32m            {[m
[32m+[m[32m                Id = MetaCompilationAnalyzer.MissingInit,[m
[32m+[m[32m                Message = "You are missing the required Initialize method",[m
[32m+[m[32m                Severity = DiagnosticSeverity.Error,[m
[32m+[m[32m                Locations = new[] { new DiagnosticResultLocation("Test1.cs", 15, 22) }[m
[32m+[m[32m            };[m
[32m+[m
[32m+[m[32m            VerifyCSharpDiagnostic(test, expected);[m
[32m+[m
[32m+[m[32m            var fixTest = @"using System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32m            using System.Collections.Immutable;[m
[32m+[m[32m            using System.Linq;[m
[32m+[m[32m            using System.Threading;[m
[32m+[m[32m            using Microsoft.CodeAnalysis;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.Text;[m
[32m+[m
[32m+[m[32mnamespace SyntaxNodeAnalyzer[m
[32m+[m[32m    {[m
[32m+[m[32m        [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[32m+[m[32m        public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m        {[m
[32m+[m[32m            public const string spacingRuleId = ""IfSpacing"";[m
[32m+[m
[32m+[m[32m            internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m                id: spacingRuleId, //make the id specific[m
[32m+[m[32m                title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[32m+[m[32m                messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[32m+[m[32m                category: ""Syntax"", //make the category specific[m
[32m+[m[32m                defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m                isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m            public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[32m+[m[32m            {[m
[32m+[m[32m                get[m
[32m+[m[32m                {[m
[32m+[m[32m                    return ImmutableArray.Create(Rule);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m                var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m                var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m                var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m
[32m+[m[32m                if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m                {[m
[32m+[m[32m                    var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                    if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                        {[m
[32m+[m[32m                            return;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m                obj.ReportDiagnostic(diagnostic);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            public override void Initialize(AnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new NotImplementedException();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }";[m
[32m+[m[32m            VerifyCSharpFix(test, fixTest);[m
[32m+[m[32m        }[m
[32m+[m
         protected override CodeFixProvider GetCSharpCodeFixProvider()[m
         {[m
             return new MetaCompilationCodeFixProvider();[m

[33mcommit 2232e1d5a3c3e63ac92fcc6c5cab743cba4f1d24[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Fri Jun 12 13:47:12 2015 -0700

    Add Microsoft copyright, code fix for MissingInit

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex 87956ab..2868678 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -1,12 +1,10 @@[m
[31m-﻿using System;[m
[31m-[m
[32m+[m[32m﻿// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.[m
[32m+[m[32musing System;[m
 using Microsoft.CodeAnalysis;[m
 using Microsoft.CodeAnalysis.CodeFixes;[m
 using Microsoft.CodeAnalysis.Diagnostics;[m
 using Microsoft.VisualStudio.TestTools.UnitTesting;[m
[31m-[m
 using TestHelper;[m
[31m-[m
 using MetaCompilation;[m
 [m
 namespace MetaCompilation.Test[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1mindex cde99e8..b01a18b 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[36m@@ -1,11 +1,11 @@[m
[31m-﻿using System;[m
[32m+[m[32m﻿// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.[m
[32m+[m[32musing System;[m
 using System.Collections.Generic;[m
 using System.Collections.Immutable;[m
 using System.Composition;[m
 using System.Linq;[m
 using System.Threading;[m
 using System.Threading.Tasks;[m
[31m-[m
 using Microsoft.CodeAnalysis;[m
 using Microsoft.CodeAnalysis.CodeFixes;[m
 using Microsoft.CodeAnalysis.CodeActions;[m
[36m@@ -13,6 +13,7 @@[m
 using Microsoft.CodeAnalysis.CSharp.Syntax;[m
 using Microsoft.CodeAnalysis.Rename;[m
 using Microsoft.CodeAnalysis.Text;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Editing;[m
 [m
 namespace MetaCompilation[m
 {[m
[36m@@ -24,7 +25,7 @@[m [mpublic override ImmutableArray<string> FixableDiagnosticIds[m
             get[m
             {[m
                 //TODO: add any new rules[m
[31m-                return ImmutableArray.Create(MetaCompilationAnalyzer.MissingId);[m
[32m+[m[32m                return ImmutableArray.Create(MetaCompilationAnalyzer.MissingId, MetaCompilationAnalyzer.MissingInit);[m
             }[m
         }[m
 [m
[36m@@ -44,12 +45,40 @@[m [mpublic sealed override FixAllProvider GetFixAllProvider()[m
                 if (diagnostic.Id.Equals(MetaCompilationAnalyzer.MissingId))[m
                 {[m
                     ClassDeclarationSyntax declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<ClassDeclarationSyntax>().First();[m
[31m-                    context.RegisterCodeFix(CodeAction.Create("Add diagnostic id",[m
[32m+[m[32m                    context.RegisterCodeFix(CodeAction.Create("Each diagnostic must have a unique id identifying it from other diagnostics",[m
                         c => MissingIdAsync(context.Document, declaration, c)), diagnostic);[m
                 }[m
[32m+[m
[32m+[m[32m                if (diagnostic.Id.Equals(MetaCompilationAnalyzer.MissingInit))[m
[32m+[m[32m                {[m
[32m+[m[32m                    ClassDeclarationSyntax declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<ClassDeclarationSyntax>().First();[m
[32m+[m[32m                    context.RegisterCodeFix(CodeAction.Create("Each analyzer must have an Initialize method to register actions to be performed when changes occur", c => MissingInitAsync(context.Document, declaration, c)), diagnostic);[m
[32m+[m[32m                }[m
             }[m
         }[m
 [m
[32m+[m[32m        private async Task<Document> MissingInitAsync(Document document, ClassDeclarationSyntax declaration, CancellationToken c)[m
[32m+[m[32m        {[m
[32m+[m[32m            SyntaxGenerator generator = SyntaxGenerator.GetGenerator(document);[m
[32m+[m[32m            var type = SyntaxFactory.ParseTypeName("AnalysisContext");[m
[32m+[m[32m            List<SyntaxNode> parameter = new List<SyntaxNode>();[m
[32m+[m[32m            parameter.Add(generator.ParameterDeclaration("context", type));[m
[32m+[m[32m            var voidDeclaration = SyntaxFactory.PredefinedType(SyntaxFactory.ParseToken("void"));[m
[32m+[m[32m            var exceptionStatement = SyntaxFactory.ParseExpression("new NotImplementedException()");[m
[32m+[m[32m            List<SyntaxNode> throwStatement = new List<SyntaxNode>();[m
[32m+[m[32m            throwStatement.Add(generator.ThrowStatement(exceptionStatement));[m
[32m+[m[32m            var initializeDeclaration = generator.MethodDeclaration("Initialize", parameters: parameter, returnType: voidDeclaration,[m
[32m+[m[32m                accessibility: Accessibility.Public, modifiers: DeclarationModifiers.Override, statements: throwStatement);[m
[32m+[m
[32m+[m[32m            var newClassDeclaration = generator.AddMembers(declaration, initializeDeclaration);[m
[32m+[m
[32m+[m[32m            var root = await document.GetSyntaxRootAsync();[m
[32m+[m[32m            var newRoot = root.ReplaceNode(declaration, newClassDeclaration);[m
[32m+[m[32m            var newDocument = document.WithSyntaxRoot(newRoot);[m
[32m+[m
[32m+[m[32m            return newDocument;[m
[32m+[m[32m        }[m
[32m+[m
         private async Task<Document> MissingIdAsync(Document document, ClassDeclarationSyntax declaration, CancellationToken c)[m
         {[m
             var idToken = SyntaxFactory.ParseToken("spacingRuleId");[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 45afc7f..1dd85f9 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -1,9 +1,9 @@[m
[32m+[m[32m// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.[m
 using System;[m
 using System.Collections.Generic;[m
 using System.Collections.Immutable;[m
 using System.Linq;[m
 using System.Threading;[m
[31m-[m
 using Microsoft.CodeAnalysis;[m
 using Microsoft.CodeAnalysis.CSharp;[m
 using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/UnitTests.cs b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/UnitTests.cs[m
[1mindex 76292a4..3d113ec 100644[m
[1m--- a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/UnitTests.cs[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/UnitTests.cs[m
[36m@@ -1,4 +1,5 @@[m
[31m-﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32m﻿// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.[m
[32m+[m[32musing Microsoft.CodeAnalysis;[m
 using Microsoft.CodeAnalysis.CodeFixes;[m
 using Microsoft.CodeAnalysis.Diagnostics;[m
 using Microsoft.VisualStudio.TestTools.UnitTesting;[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/CodeFixProvider.cs b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/CodeFixProvider.cs[m
[1mindex 49c1258..7cb8854 100644[m
[1m--- a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/CodeFixProvider.cs[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/CodeFixProvider.cs[m
[36m@@ -1,4 +1,5 @@[m
[31m-﻿using System;[m
[32m+[m[32m﻿// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.[m
[32m+[m[32musing System;[m
 using System.Collections.Generic;[m
 using System.Collections.Immutable;[m
 using System.Composition;[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/DiagnosticAnalyzer.cs b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/DiagnosticAnalyzer.cs[m
[1mindex 35b74d5..3f2a311 100644[m
[1m--- a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/DiagnosticAnalyzer.cs[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/DiagnosticAnalyzer.cs[m
[36m@@ -1,3 +1,4 @@[m
[32m+[m[32m// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.[m
 using System;[m
 using System.Collections.Generic;[m
 using System.Collections.Immutable;[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/CodeFixProvider.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/CodeFixProvider.cs[m
[1mindex 51b78b2..e162f2d 100644[m
[1m--- a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/CodeFixProvider.cs[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/CodeFixProvider.cs[m
[36m@@ -1,4 +1,5 @@[m
[31m-﻿using System;[m
[32m+[m[32m﻿// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.[m
[32m+[m[32musing System;[m
 using System.Collections.Generic;[m
 using System.Collections.Immutable;[m
 using System.Composition;[m
[36m@@ -51,11 +52,8 @@[m [mpublic override ImmutableArray<string> FixableDiagnosticIds[m
 [m
             var newOpenParen = SyntaxFactory.Token(SyntaxFactory.TriviaList(), SyntaxKind.OpenParenToken, openParen.TrailingTrivia);[m
 [m
[31m-[m
             var newIfStatement = SyntaxFactory.IfStatement(newIfKeyword, newOpenParen, ifStatement.Condition, ifStatement.CloseParenToken, ifStatement.Statement, ifStatement.Else);[m
[31m-[m
             [m
[31m-[m
             var root = await document.GetSyntaxRootAsync();[m
             var newRoot = root.ReplaceNode(ifStatement, newIfStatement);[m
             var newDocument = document.WithSyntaxRoot(newRoot);[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[1mindex 69a89e0..b2b2142 100644[m
[1m--- a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[36m@@ -1,3 +1,4 @@[m
[32m+[m[32m// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.[m
 using System;[m
 using System.Collections.Generic;[m
 using System.Collections.Immutable;[m
[36m@@ -33,10 +34,10 @@[m [mpublic override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
         }[m
 [m
         public override void Initialize(AnalysisContext context)[m
[31m-        {[m
[31m-            context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[31m-        }[m
[31m-[m
[32m+[m[32m         {[m
[32m+[m[32m             context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[32m+[m[32m         }[m
[32m+[m[41m         [m
         private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
         {[m
             var ifStatement = (IfStatementSyntax)context.Node;[m

[33mcommit b2b85d245a7152c6352a99b4f841aeee516887a0[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Fri Jun 12 13:35:04 2015 -0700

    Fix SupportedDiagnostics check

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 8bfc069..d86c132 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -392,7 +392,52 @@[m [minternal bool CheckSupportedDiagnostics(List<string> ruleNames, CompilationAnaly[m
 [m
                 if (returnExpression.GetType().ToString() == "Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax")[m
                 {[m
[32m+[m[32m                    var valueClause = returnExpression as InvocationExpressionSyntax;[m
[32m+[m[32m                    var returnDeclaration = returnStatement as ReturnStatementSyntax;[m
[32m+[m[32m                    if (valueClause == null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ReportDiagnostic(context, IncorrectAccessorReturnRule, returnDeclaration.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                        return false;[m
[32m+[m[32m                    }[m
 [m
[32m+[m[32m                    var valueExpression = valueClause.Expression as MemberAccessExpressionSyntax;[m
[32m+[m[32m                    if (valueExpression == null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ReportDiagnostic(context, IncorrectAccessorReturnRule, returnDeclaration.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                        return false;[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    if (valueExpression.ToString() != "ImmutableArray.Create")[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ReportDiagnostic(context, SuppDiagReturnValueRule, returnDeclaration.GetLocation(), SuppDiagReturnValueRule.MessageFormat);[m
[32m+[m[32m                        return false;[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    var valueArguments = valueClause.ArgumentList as ArgumentListSyntax;[m
[32m+[m[32m                    if (valueArguments == null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return false;[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    SeparatedSyntaxList<ArgumentSyntax> valueArgs = valueArguments.Arguments;[m
[32m+[m[32m                    if (valueArgs == null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return false;[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m
[32m+[m[32m                    foreach (ArgumentSyntax arg in valueArgs)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        if (ruleNames.Count == 0)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            ReportDiagnostic(context, SupportedRulesRule, valueExpression.GetLocation(), SupportedRulesRule.MessageFormat);[m
[32m+[m[32m                            return false;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (ruleNames.Contains(arg.ToString()))[m
[32m+[m[32m                        {[m
[32m+[m[32m                            ruleNames.Remove(arg.ToString());[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
                 }[m
                 else if (returnExpression.GetType().ToString() == "Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax")[m
                 {[m

[33mcommit 57da132f4a12e363ffd1a7bf1cd36cc7cee4fa36[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Fri Jun 12 13:09:43 2015 -0700

    Fix accessibility string comparisons

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex d07b708..8bfc069 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -316,7 +316,7 @@[m [minternal bool CheckSupportedDiagnostics(List<string> ruleNames, CompilationAnaly[m
                     return false;[m
                 }[m
 [m
[31m-                if (_propertySymbol.Name.ToString() != "SupportedDiagnostics" || _propertySymbol.DeclaredAccessibility.ToString() != "Public" || [m
[32m+[m[32m                if (_propertySymbol.Name.ToString() != "SupportedDiagnostics" || _propertySymbol.DeclaredAccessibility != Accessibility.Public ||[m[41m [m
                     !_propertySymbol.IsOverride || _propertySymbol.OverriddenProperty.ToString() != "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics" [m
                     || _propertySymbol.Type.ToString() != "System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.DiagnosticDescriptor>")[m
                 {[m
[36m@@ -504,7 +504,7 @@[m [minternal List<string> CheckIds(string branch, string kind, CompilationAnalysisCo[m
                 List<string> idNames = new List<string>();[m
                 foreach (IFieldSymbol field in _analyzerFieldSymbols)[m
                 {[m
[31m-                    if (field.IsConst && field.IsStatic && field.DeclaredAccessibility.ToString() == "Public" && field.Type.ToString() == "string")[m
[32m+[m[32m                    if (field.IsConst && field.IsStatic && field.DeclaredAccessibility == Accessibility.Public && field.Type.ToString() == "string")[m
                     {[m
                         if (field.Name == null)[m
                         {[m
[36m@@ -536,7 +536,7 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                 {[m
                     //checking method signature[m
                     ImmutableArray<IParameterSymbol> parameters = _initializeSymbol.Parameters;[m
[31m-                    if (parameters.Count() != 1 || parameters[0].Type.ToString() != "Microsoft.CodeAnalysis.Diagnostics.AnalysisContext" || parameters[0].Name.ToString() != "context" || _initializeSymbol.DeclaredAccessibility.ToString() != "Public" || !_initializeSymbol.IsOverride || !_initializeSymbol.ReturnsVoid)[m
[32m+[m[32m                    if (parameters.Count() != 1 || parameters[0].Type.ToString() != "Microsoft.CodeAnalysis.Diagnostics.AnalysisContext" || parameters[0].Name.ToString() != "context" || _initializeSymbol.DeclaredAccessibility != Accessibility.Public || !_initializeSymbol.IsOverride || !_initializeSymbol.ReturnsVoid)[m
                     {[m
                         ReportDiagnostic(context, IncorrectInitSigRule, _initializeSymbol.Locations[0], MissingInitRule.MessageFormat);[m
                         return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m

[33mcommit f39f5718943402590304bc3f863083e95138d667[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Fri Jun 12 13:01:36 2015 -0700

    Fix diagnostic ids

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 6b63531..d07b708 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -15,7 +15,7 @@[m [mnamespace MetaCompilation[m
     public class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
     {[m
         #region id rules[m
[31m-        public const string MissingId = "missingId";[m
[32m+[m[32m        public const string MissingId = "MetaAnalyzer001";[m
         internal static DiagnosticDescriptor MissingIdRule = new DiagnosticDescriptor([m
             id: MissingId,[m
             title: "You are missing a diagnostic id",[m
[36m@@ -26,7 +26,7 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
         #endregion[m
 [m
         #region Initialize rules[m
[31m-        public const string MissingInit = "missingInit";[m
[32m+[m[32m        public const string MissingInit = "MetaAnalyzer002";[m
         internal static DiagnosticDescriptor MissingInitRule = new DiagnosticDescriptor([m
             id: MissingInit,[m
             title: "You are missing the required Initialize method",[m
[36m@@ -35,7 +35,7 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
 [m
[31m-        public const string MissingRegisterStatement = "missingRegister";[m
[32m+[m[32m        public const string MissingRegisterStatement = "MetaAnalyzer003";[m
         internal static DiagnosticDescriptor MissingRegisterRule = new DiagnosticDescriptor([m
             id: MissingRegisterStatement,[m
             title: "You need to register an action within the Initialize method",[m
[36m@@ -44,7 +44,7 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
 [m
[31m-        public const string TooManyInitStatements = "incorrectInit001";[m
[32m+[m[32m        public const string TooManyInitStatements = "MetaAnalyzer004";[m
         internal static DiagnosticDescriptor TooManyInitStatementsRule = new DiagnosticDescriptor([m
             id: TooManyInitStatements,[m
             title: "Please only have one statement within Initiailize. You will only be registering one action.",[m
[36m@@ -53,7 +53,7 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
 [m
[31m-        public const string IncorrectInitStatement = "incorrectInit002";[m
[32m+[m[32m        public const string IncorrectInitStatement = "MetaAnalyzer005";[m
         internal static DiagnosticDescriptor IncorrectInitStatementRule = new DiagnosticDescriptor([m
             id: IncorrectInitStatement,[m
             title: "This statement needs to register for a supported action",[m
[36m@@ -62,7 +62,7 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
 [m
[31m-        public const string IncorrectInitSig = "initSignature";[m
[32m+[m[32m        public const string IncorrectInitSig = "MetaAnalyzer006";[m
         internal static DiagnosticDescriptor IncorrectInitSigRule = new DiagnosticDescriptor([m
             id: IncorrectInitSig,[m
             title: "The signature for the Initialize method is incorrect",[m
[36m@@ -73,7 +73,7 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
         #endregion[m
 [m
         #region SupportedDiagnostics rules[m
[31m-        public const string MissingSuppDiag = "missingSuppDiag";[m
[32m+[m[32m        public const string MissingSuppDiag = "MetaAnalyzer007";[m
         internal static DiagnosticDescriptor MissingSuppDiagRule = new DiagnosticDescriptor([m
             id: MissingSuppDiag,[m
             title: "You are missing the required SupportedDiagnostics method",[m
[36m@@ -82,7 +82,7 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
 [m
[31m-        public const string IncorrectSigSuppDiag = "incorrectSignatureSuppDiag";[m
[32m+[m[32m        public const string IncorrectSigSuppDiag = "MetaAnalyzer008";[m
         internal static DiagnosticDescriptor IncorrectSigSuppDiagRule = new DiagnosticDescriptor([m
             id: IncorrectSigSuppDiag,[m
             title: "The signature of the SupportedDiagnostics property is incorrect",[m
[36m@@ -91,7 +91,7 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
 [m
[31m-        public const string MissingAccessor = "missingAccessor";[m
[32m+[m[32m        public const string MissingAccessor = "MetaAnalyzer009";[m
         internal static DiagnosticDescriptor MissingAccessorRule = new DiagnosticDescriptor([m
             id: MissingAccessor,[m
             title: "You are missing a get accessor in your SupportedDiagnostics property",[m
[36m@@ -100,7 +100,7 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
 [m
[31m-        public const string TooManyAccessors = "tooManyAccessors";[m
[32m+[m[32m        public const string TooManyAccessors = "MetaAnalyzer010";[m
         internal static DiagnosticDescriptor TooManyAccessorsRule = new DiagnosticDescriptor([m
             id: TooManyAccessors,[m
             title: "You only need a get accessor for this property",[m
[36m@@ -109,7 +109,7 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
 [m
[31m-        public const string IncorrectAccessorReturn = "incorrectReturn";[m
[32m+[m[32m        public const string IncorrectAccessorReturn = "MetaAnalyzer011";[m
         internal static DiagnosticDescriptor IncorrectAccessorReturnRule = new DiagnosticDescriptor([m
             id: IncorrectAccessorReturn,[m
             title: "The get accessor needs to return an ImmutableArray containing all of your DiagnosticDescriptor rules",[m
[36m@@ -118,7 +118,7 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
 [m
[31m-        public const string SuppDiagReturnValue = "ImmutableArray";[m
[32m+[m[32m        public const string SuppDiagReturnValue = "MetaAnalyzer012";[m
         internal static DiagnosticDescriptor SuppDiagReturnValueRule = new DiagnosticDescriptor([m
             id: SuppDiagReturnValue,[m
             title: "You need to create an immutable array",[m
[36m@@ -127,7 +127,7 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
 [m
[31m-        public const string SupportedRules = "SupportedRules";[m
[32m+[m[32m        public const string SupportedRules = "MetaAnalyzer013";[m
         internal static DiagnosticDescriptor SupportedRulesRule = new DiagnosticDescriptor([m
             id: SupportedRules,[m
             title: "The immutable array should contain every DiagnosticDescriptor rule that was created",[m

[33mcommit a9a354ef09fdcd18b1a071a3ad2622f0f32edcc5[m
Merge: b7af453 ea9a02c
Author: zoepetard <t-zopet@microsoft.com>
Date:   Fri Jun 12 12:58:02 2015 -0700

    Merge pull request #13 from zoepetard/AddGitAttributes
    
    Add .gitattributes

[33mcommit ea9a02ca0d36c6a5edffc1c97d9949ca915e7e1a[m
Author: zoepetard <t-zopet@microsoft.com>
Date:   Fri Jun 12 10:41:05 2015 -0700

    Add .gitattributes

[1mdiff --git a/.gitattributes b/.gitattributes[m
[1mnew file mode 100644[m
[1mindex 0000000..1ff0c42[m
[1m--- /dev/null[m
[1m+++ b/.gitattributes[m
[36m@@ -0,0 +1,63 @@[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m# Set default behavior to automatically normalize line endings.[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m* text=auto[m
[32m+[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m# Set default behavior for command prompt diff.[m
[32m+[m[32m#[m
[32m+[m[32m# This is need for earlier builds of msysgit that does not have it on by[m
[32m+[m[32m# default for csharp files.[m
[32m+[m[32m# Note: This is only used by command line[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m#*.cs     diff=csharp[m
[32m+[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m# Set the merge driver for project and solution files[m
[32m+[m[32m#[m
[32m+[m[32m# Merging from the command prompt will add diff markers to the files if there[m
[32m+[m[32m# are conflicts (Merging from VS is not affected by the settings below, in VS[m
[32m+[m[32m# the diff markers are never inserted). Diff markers may cause the following[m[41m [m
[32m+[m[32m# file extensions to fail to load in VS. An alternative would be to treat[m
[32m+[m[32m# these files as binary and thus will always conflict and require user[m
[32m+[m[32m# intervention with every merge. To do so, just uncomment the entries below[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m#*.sln       merge=binary[m
[32m+[m[32m#*.csproj    merge=binary[m
[32m+[m[32m#*.vbproj    merge=binary[m
[32m+[m[32m#*.vcxproj   merge=binary[m
[32m+[m[32m#*.vcproj    merge=binary[m
[32m+[m[32m#*.dbproj    merge=binary[m
[32m+[m[32m#*.fsproj    merge=binary[m
[32m+[m[32m#*.lsproj    merge=binary[m
[32m+[m[32m#*.wixproj   merge=binary[m
[32m+[m[32m#*.modelproj merge=binary[m
[32m+[m[32m#*.sqlproj   merge=binary[m
[32m+[m[32m#*.wwaproj   merge=binary[m
[32m+[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m# behavior for image files[m
[32m+[m[32m#[m
[32m+[m[32m# image files are treated as binary by default.[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m#*.jpg   binary[m
[32m+[m[32m#*.png   binary[m
[32m+[m[32m#*.gif   binary[m
[32m+[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m# diff behavior for common document formats[m
[32m+[m[32m#[m[41m [m
[32m+[m[32m# Convert binary document formats to text before diffing them. This feature[m
[32m+[m[32m# is only available from the command line. Turn it on by uncommenting the[m[41m [m
[32m+[m[32m# entries below.[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m#*.doc   diff=astextplain[m
[32m+[m[32m#*.DOC   diff=astextplain[m
[32m+[m[32m#*.docx  diff=astextplain[m
[32m+[m[32m#*.DOCX  diff=astextplain[m
[32m+[m[32m#*.dot   diff=astextplain[m
[32m+[m[32m#*.DOT   diff=astextplain[m
[32m+[m[32m#*.pdf   diff=astextplain[m
[32m+[m[32m#*.PDF   diff=astextplain[m
[32m+[m[32m#*.rtf   diff=astextplain[m
[32m+[m[32m#*.RTF   diff=astextplain[m

[33mcommit ff414e62d5e4e9c92057dd65747371e0d65d9059[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Fri Jun 12 10:31:44 2015 -0700

    Typo

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 9eefa06..6b63531 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -264,7 +264,7 @@[m [minternal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context[m
                                 if (supportedDiagnosticsCorrect)[m
                                 {[m
                                     //check the SyntaxNode, Symbol, Compilation, CodeBlock, etc analysis method(s)[m
[31m-                                    bool analysisCorrect = CheckAnlaysis(_branchesDict[registerSymbol.Name.ToString()], kindName, ruleNames, context);[m
[32m+[m[32m                                    bool analysisCorrect = CheckAnalysis(_branchesDict[registerSymbol.Name.ToString()], kindName, ruleNames, context);[m
                                     if (analysisCorrect)[m
                                     {[m
                                         //diagnostic to go to code fix[m

[33mcommit aa0065f2029ddbd1135ed6fb7ff7e04af13cfdd5[m
Merge: 1338071 5dcd7e6
Author: Daniel King <t-daki@microsoft.com>
Date:   Fri Jun 12 10:05:19 2015 -0700

    Merge branch 'daking2014-check-supported-diagnostics' into check-supported-diagnostics

[33mcommit 5dcd7e630c04f742f2bcfd1b27ef49938ea7f1a7[m
Merge: b7af453 1338071
Author: Daniel King <t-daki@microsoft.com>
Date:   Fri Jun 12 10:04:41 2015 -0700

    fixed merge conflicts

[33mcommit 13380719e7d8c803b9ef8a495023690acb159b15[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Thu Jun 11 16:29:45 2015 -0700

    CheckSupportedDiagnostics()

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 45afc7f..9eefa06 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -14,7 +14,6 @@[m [mnamespace MetaCompilation[m
     [DiagnosticAnalyzer(LanguageNames.CSharp)][m
     public class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
     {[m
[31m-[m
         #region id rules[m
         public const string MissingId = "missingId";[m
         internal static DiagnosticDescriptor MissingIdRule = new DiagnosticDescriptor([m
[36m@@ -26,7 +25,7 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             isEnabledByDefault: true);[m
         #endregion[m
 [m
[31m-        #region initialize rules[m
[32m+[m[32m        #region Initialize rules[m
         public const string MissingInit = "missingInit";[m
         internal static DiagnosticDescriptor MissingInitRule = new DiagnosticDescriptor([m
             id: MissingInit,[m
[36m@@ -73,11 +72,88 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
             isEnabledByDefault: true);[m
         #endregion[m
 [m
[32m+[m[32m        #region SupportedDiagnostics rules[m
[32m+[m[32m        public const string MissingSuppDiag = "missingSuppDiag";[m
[32m+[m[32m        internal static DiagnosticDescriptor MissingSuppDiagRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: MissingSuppDiag,[m
[32m+[m[32m            title: "You are missing the required SupportedDiagnostics method",[m
[32m+[m[32m            messageFormat: "You are missing the required SupportedDiagnostics method",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public const string IncorrectSigSuppDiag = "incorrectSignatureSuppDiag";[m
[32m+[m[32m        internal static DiagnosticDescriptor IncorrectSigSuppDiagRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: IncorrectSigSuppDiag,[m
[32m+[m[32m            title: "The signature of the SupportedDiagnostics property is incorrect",[m
[32m+[m[32m            messageFormat: "The signature of the SupportedDiagnostics property is incorrect",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public const string MissingAccessor = "missingAccessor";[m
[32m+[m[32m        internal static DiagnosticDescriptor MissingAccessorRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: MissingAccessor,[m
[32m+[m[32m            title: "You are missing a get accessor in your SupportedDiagnostics property",[m
[32m+[m[32m            messageFormat: "You are missing a get accessor in your SupportedDiagnostics property",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public const string TooManyAccessors = "tooManyAccessors";[m
[32m+[m[32m        internal static DiagnosticDescriptor TooManyAccessorsRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: TooManyAccessors,[m
[32m+[m[32m            title: "You only need a get accessor for this property",[m
[32m+[m[32m            messageFormat: "You only need a get accessor for this property",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public const string IncorrectAccessorReturn = "incorrectReturn";[m
[32m+[m[32m        internal static DiagnosticDescriptor IncorrectAccessorReturnRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: IncorrectAccessorReturn,[m
[32m+[m[32m            title: "The get accessor needs to return an ImmutableArray containing all of your DiagnosticDescriptor rules",[m
[32m+[m[32m            messageFormat: "The get accessor needs to return an ImmutableArray containing all of your DiagnosticDescriptor rules",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public const string SuppDiagReturnValue = "ImmutableArray";[m
[32m+[m[32m        internal static DiagnosticDescriptor SuppDiagReturnValueRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: SuppDiagReturnValue,[m
[32m+[m[32m            title: "You need to create an immutable array",[m
[32m+[m[32m            messageFormat: "You need to create an immutable array",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public const string SupportedRules = "SupportedRules";[m
[32m+[m[32m        internal static DiagnosticDescriptor SupportedRulesRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: SupportedRules,[m
[32m+[m[32m            title: "The immutable array should contain every DiagnosticDescriptor rule that was created",[m
[32m+[m[32m            messageFormat: "The immutable array should contain every DiagnosticDescriptor rule that was created",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m[32m        #endregion[m
[32m+[m
         public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
         {[m
             get[m
             {[m
[31m-                return ImmutableArray.Create(MissingIdRule, MissingInitRule, MissingRegisterRule, TooManyInitStatementsRule, IncorrectInitStatementRule, IncorrectInitSigRule);[m
[32m+[m[32m                return ImmutableArray.Create(MissingIdRule,[m[41m [m
[32m+[m[32m                                             MissingInitRule,[m[41m [m
[32m+[m[32m                                             MissingRegisterRule,[m[41m [m
[32m+[m[32m                                             TooManyInitStatementsRule,[m[41m [m
[32m+[m[32m                                             IncorrectInitStatementRule,[m[41m [m
[32m+[m[32m                                             IncorrectInitSigRule,[m
[32m+[m[32m                                             MissingSuppDiagRule,[m
[32m+[m[32m                                             IncorrectSigSuppDiagRule,[m
[32m+[m[32m                                             MissingAccessorRule,[m
[32m+[m[32m                                             TooManyAccessorsRule,[m
[32m+[m[32m                                             IncorrectAccessorReturnRule,[m
[32m+[m[32m                                             SuppDiagReturnValueRule,[m
[32m+[m[32m                                             SupportedRulesRule);[m
             }[m
         }[m
 [m
[36m@@ -226,14 +302,193 @@[m [minternal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context[m
                 }[m
             }[m
 [m
[31m-            internal bool CheckAnlaysis(string branch, string kind, List<string> ruleNames, CompilationAnalysisContext context)[m
[32m+[m[32m            internal bool CheckAnalysis(string branch, string kind, List<string> ruleNames, CompilationAnalysisContext context)[m
             {[m
                 throw new NotImplementedException();[m
             }[m
 [m
[32m+[m[32m            //returns a boolean based on whether or not the SupportedDiagnostics property is correct[m
             internal bool CheckSupportedDiagnostics(List<string> ruleNames, CompilationAnalysisContext context)[m
             {[m
[31m-                throw new NotImplementedException();[m
[32m+[m[32m                if (_propertySymbol == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, MissingSuppDiagRule, _analyzerClassSymbol.Locations[0], MissingSuppDiagRule.MessageFormat);[m
[32m+[m[32m                    return false;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (_propertySymbol.Name.ToString() != "SupportedDiagnostics" || _propertySymbol.DeclaredAccessibility.ToString() != "Public" ||[m[41m [m
[32m+[m[32m                    !_propertySymbol.IsOverride || _propertySymbol.OverriddenProperty.ToString() != "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics"[m[41m [m
[32m+[m[32m                    || _propertySymbol.Type.ToString() != "System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.DiagnosticDescriptor>")[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectSigSuppDiagRule, _propertySymbol.Locations[0], IncorrectSigSuppDiagRule.MessageFormat);[m
[32m+[m[32m                    return false;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var propertyDeclaration = _propertySymbol.DeclaringSyntaxReferences[0].GetSyntax() as PropertyDeclarationSyntax;[m
[32m+[m[32m                if (propertyDeclaration == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return false;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                AccessorListSyntax accessorList = propertyDeclaration.AccessorList;[m
[32m+[m[32m                if (accessorList == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return false;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                SyntaxList<AccessorDeclarationSyntax> accessors = accessorList.Accessors;[m
[32m+[m[32m                if (accessors == null || accessors.Count == 0)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, MissingAccessorRule, propertyDeclaration.GetLocation(), MissingAccessorRule.MessageFormat);[m
[32m+[m[32m                    return false;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (accessors.Count > 1)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, TooManyAccessorsRule, accessorList.GetLocation(), TooManyAccessorsRule.MessageFormat);[m
[32m+[m[32m                    return false;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var getAccessor = accessors.First() as AccessorDeclarationSyntax;[m
[32m+[m[32m                if (getAccessor == null || getAccessor.Keyword.ToString() != "get")[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, MissingAccessorRule, propertyDeclaration.GetLocation(), MissingAccessorRule.MessageFormat);[m
[32m+[m[32m                    return false;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var accessorBody = getAccessor.Body as BlockSyntax;[m
[32m+[m[32m                if (accessorBody == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessor.Keyword.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    return false;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                SyntaxList<StatementSyntax> statements = accessorBody.Statements;[m
[32m+[m[32m                if (statements.Count == 0)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessor.Keyword.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    return false;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                IEnumerable<ReturnStatementSyntax> returnStatements = statements.OfType<ReturnStatementSyntax>();[m
[32m+[m[32m                if (returnStatements.Count() == 0)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessor.Keyword.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    return false;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                ReturnStatementSyntax returnStatement = returnStatements.First();[m
[32m+[m[32m                if (returnStatement == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessor.Keyword.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    return false;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var returnExpression = returnStatement.Expression;[m
[32m+[m[32m                if (returnExpression == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessor.Keyword.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    return false;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (returnExpression.GetType().ToString() == "Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax")[m
[32m+[m[32m                {[m
[32m+[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (returnExpression.GetType().ToString() == "Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax")[m
[32m+[m[32m                {[m
[32m+[m[32m                    var returnSymbolInfo = context.Compilation.GetSemanticModel(returnStatement.SyntaxTree).GetSymbolInfo(returnExpression as IdentifierNameSyntax);[m
[32m+[m[32m                    ILocalSymbol returnSymbol = null;[m
[32m+[m[32m                    if (returnSymbolInfo.CandidateSymbols.Count() == 0)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        returnSymbol = returnSymbolInfo.Symbol as ILocalSymbol;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else[m
[32m+[m[32m                    {[m
[32m+[m[32m                        returnSymbol = returnSymbolInfo.CandidateSymbols[0] as ILocalSymbol;[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    if (returnSymbol == null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessor.Keyword.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                        return false;[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    if (returnSymbol.Type.ToString() != "System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.DiagnosticDescriptor>")[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ReportDiagnostic(context, IncorrectAccessorReturnRule, returnSymbol.Locations[0], IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                        return false;[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    var returnDeclaration = returnSymbol.DeclaringSyntaxReferences[0].GetSyntax() as VariableDeclaratorSyntax;[m
[32m+[m[32m                    if (returnDeclaration == null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ReportDiagnostic(context, IncorrectAccessorReturnRule, returnSymbol.Locations[0], IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                        return false;[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    var equalsValueClause = returnDeclaration.Initializer as EqualsValueClauseSyntax;[m
[32m+[m[32m                    if (equalsValueClause == null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ReportDiagnostic(context, IncorrectAccessorReturnRule, returnDeclaration.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                        return false;[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    var valueClause = equalsValueClause.Value as InvocationExpressionSyntax;[m
[32m+[m[32m                    if (valueClause == null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ReportDiagnostic(context, IncorrectAccessorReturnRule, returnDeclaration.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                        return false;[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    var valueExpression = valueClause.Expression as MemberAccessExpressionSyntax;[m
[32m+[m[32m                    if (valueExpression == null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ReportDiagnostic(context, IncorrectAccessorReturnRule, returnDeclaration.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                        return false;[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    if (valueExpression.ToString() != "ImmutableArray.Create")[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ReportDiagnostic(context, SuppDiagReturnValueRule, returnDeclaration.GetLocation(), SuppDiagReturnValueRule.MessageFormat);[m
[32m+[m[32m                        return false;[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    var valueArguments = valueClause.ArgumentList as ArgumentListSyntax;[m
[32m+[m[32m                    if (valueArguments == null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return false;[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    SeparatedSyntaxList<ArgumentSyntax> valueArgs = valueArguments.Arguments;[m
[32m+[m[32m                    if (valueArgs == null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return false;[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[41m                    [m
[32m+[m[32m                    foreach (ArgumentSyntax arg in valueArgs)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        if (ruleNames.Count == 0)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            ReportDiagnostic(context, SupportedRulesRule, valueExpression.GetLocation(), SupportedRulesRule.MessageFormat);[m
[32m+[m[32m                            return false;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (ruleNames.Contains(arg.ToString()))[m
[32m+[m[32m                        {[m
[32m+[m[32m                            ruleNames.Remove(arg.ToString());[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    ReportDiagnostic(context, IncorrectAccessorReturnRule, getAccessor.Keyword.GetLocation(), IncorrectAccessorReturnRule.MessageFormat);[m
[32m+[m[32m                    return false;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                return true;[m
[32m+[m
             }[m
             [m
             //returns a list of rule names[m

[33mcommit de0e79ebf76269c7ed2747478b8491f825f5509c[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Thu Jun 11 16:29:31 2015 -0700

    deleted comment

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1mindex 61c1d01..291c41c 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[36m@@ -40,7 +40,7 @@[m [mpublic sealed override FixAllProvider GetFixAllProvider()[m
             foreach (Diagnostic diagnostic in context.Diagnostics)[m
             {[m
                 TextSpan diagnosticSpan = diagnostic.Location.SourceSpan;[m
[31m-                //TODO: if statements for each diagnostic id, to register a code fix[m
[32m+[m
                 if (diagnostic.Id.Equals(MetaCompilationAnalyzer.MissingId))[m
                 {[m
                     ClassDeclarationSyntax declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<ClassDeclarationSyntax>().First();[m

[33mcommit 8f8392b8995e5e4bb62c08a30088a2d0287a7e16[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Thu Jun 11 16:29:19 2015 -0700

    rename object to context

[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[1mindex 69a89e0..224a0b4 100644[m
[1m--- a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[36m@@ -57,7 +57,7 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
             }[m
 [m
             var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[31m-            obj.ReportDiagnostic(diagnostic);[m
[32m+[m[32m            context.ReportDiagnostic(diagnostic);[m
         }[m
     }[m
 }[m

[33mcommit 57d49fadce204c97fba84541b9fdae4f035405cc[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Thu Jun 11 14:44:30 2015 -0700

    Add test for missing Id

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex 7c5c1e9..87956ab 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -94,6 +94,148 @@[m [mprivate void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
             VerifyCSharpDiagnostic(test);[m
         }[m
 [m
[32m+[m[32m        //check missingId code fix and diagnostic[m
[32m+[m[32m        public void TestMethod3()[m
[32m+[m[32m        {[m
[32m+[m[32m            var test = @"using System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32m            using System.Collections.Immutable;[m
[32m+[m[32m            using System.Linq;[m
[32m+[m[32m            using System.Threading;[m
[32m+[m[32m            using Microsoft.CodeAnalysis;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.Text;[m
[32m+[m
[32m+[m[32mnamespace SyntaxNodeAnalyzer[m
[32m+[m[32m    {[m
[32m+[m[32m        [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[32m+[m[32m        public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m        {[m
[32m+[m[32m            internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m                id: spacingRuleId, //make the id specific[m
[32m+[m[32m                title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[32m+[m[32m                messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[32m+[m[32m                category: ""Syntax"", //make the category specific[m
[32m+[m[32m                defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m                isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m            public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[32m+[m[32m            {[m
[32m+[m[32m                get[m
[32m+[m[32m                {[m
[32m+[m[32m                    return ImmutableArray.Create(Rule);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            public override void Initialize(AnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m                var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m                var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m                var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m
[32m+[m[32m                if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m                {[m
[32m+[m[32m                    var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                    if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                        {[m
[32m+[m[32m                            return;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m                obj.ReportDiagnostic(diagnostic);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m";[m
[32m+[m[32m            var expected = new DiagnosticResult[m
[32m+[m[32m            {[m
[32m+[m[32m                Id = MetaCompilationAnalyzer.MissingId,[m
[32m+[m[32m                Message = "You are missing a diagnostic Id",[m
[32m+[m[32m                Severity = DiagnosticSeverity.Error,[m
[32m+[m[32m                Locations = new[] { new DiagnosticResultLocation("Test0.cs", 15, 22) }[m
[32m+[m[32m            };[m
[32m+[m
[32m+[m[32m            VerifyCSharpDiagnostic(test, expected);[m
[32m+[m
[32m+[m[32m            var fixtest = @"using System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32m            using System.Collections.Immutable;[m
[32m+[m[32m            using System.Linq;[m
[32m+[m[32m            using System.Threading;[m
[32m+[m[32m            using Microsoft.CodeAnalysis;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.Text;[m
[32m+[m
[32m+[m[32mnamespace SyntaxNodeAnalyzer[m
[32m+[m[32m    {[m
[32m+[m[32m        [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[32m+[m[32m        public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m        {[m
[32m+[m[32m            public const string spacingRuleId = ""IfSpacing"";[m
[32m+[m
[32m+[m[32m            internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m                id: spacingRuleId, //make the id specific[m
[32m+[m[32m                title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[32m+[m[32m                messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[32m+[m[32m                category: ""Syntax"", //make the category specific[m
[32m+[m[32m                defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m                isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m            public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[32m+[m[32m            {[m
[32m+[m[32m                get[m
[32m+[m[32m                {[m
[32m+[m[32m                    return ImmutableArray.Create(Rule);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            public override void Initialize(AnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m                var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m                var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m                var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m
[32m+[m[32m                if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m                {[m
[32m+[m[32m                    var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                    if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                        {[m
[32m+[m[32m                            return;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m                obj.ReportDiagnostic(diagnostic);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m";[m
[32m+[m[32m            VerifyCSharpFix(test, fixtest);[m
[32m+[m[32m        }[m
[32m+[m
         protected override CodeFixProvider GetCSharpCodeFixProvider()[m
         {[m
             return new MetaCompilationCodeFixProvider();[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1mindex 45ebc2c..cde99e8 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[36m@@ -52,7 +52,6 @@[m [mpublic sealed override FixAllProvider GetFixAllProvider()[m
 [m
         private async Task<Document> MissingIdAsync(Document document, ClassDeclarationSyntax declaration, CancellationToken c)[m
         {[m
[31m-            // Code fix partially completed[m
             var idToken = SyntaxFactory.ParseToken("spacingRuleId");[m
             [m
             var expressionKind = SyntaxFactory.ParseExpression("\"IfSpacing\"") as ExpressionSyntax;[m

[33mcommit b7af4533021e5b4f802a07fd8a8ad545a086b44e[m
Merge: 27cbf90 db05532
Author: Daniel King <daniel.king2014@gmail.com>
Date:   Thu Jun 11 11:24:49 2015 -0700

    Merge pull request #10 from jepetty/codeFixWork
    
    Code fix for missing id

[33mcommit db0553246d3929f0b124ef095c0a6f6404de8d86[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Thu Jun 11 10:06:27 2015 -0700

    Code fix for missing id

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1mindex 61c1d01..45ebc2c 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[36m@@ -44,14 +44,47 @@[m [mpublic sealed override FixAllProvider GetFixAllProvider()[m
                 if (diagnostic.Id.Equals(MetaCompilationAnalyzer.MissingId))[m
                 {[m
                     ClassDeclarationSyntax declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<ClassDeclarationSyntax>().First();[m
[31m-                    context.RegisterCodeFix(CodeAction.Create("Remove invalid statement", c => MissingIdAsync(context.Document, declaration, c)), diagnostic);[m
[32m+[m[32m                    context.RegisterCodeFix(CodeAction.Create("Add diagnostic id",[m
[32m+[m[32m                        c => MissingIdAsync(context.Document, declaration, c)), diagnostic);[m
                 }[m
             }[m
         }[m
 [m
         private async Task<Document> MissingIdAsync(Document document, ClassDeclarationSyntax declaration, CancellationToken c)[m
         {[m
[31m-            throw new NotImplementedException();[m
[32m+[m[32m            // Code fix partially completed[m
[32m+[m[32m            var idToken = SyntaxFactory.ParseToken("spacingRuleId");[m
[32m+[m[41m            [m
[32m+[m[32m            var expressionKind = SyntaxFactory.ParseExpression("\"IfSpacing\"") as ExpressionSyntax;[m
[32m+[m[41m            [m
[32m+[m[32m            var equalsValueClause = SyntaxFactory.EqualsValueClause(expressionKind);[m
[32m+[m[32m            var idDeclarator = SyntaxFactory.VariableDeclarator(idToken, null, equalsValueClause);[m
[32m+[m
[32m+[m[32m            var type = SyntaxFactory.ParseTypeName("string");[m
[32m+[m
[32m+[m[32m            var idDeclaratorList = new SeparatedSyntaxList<VariableDeclaratorSyntax>().Add(idDeclarator);[m
[32m+[m[32m            var idDeclaration = SyntaxFactory.VariableDeclaration(type, idDeclaratorList);[m
[32m+[m
[32m+[m[32m            var whiteSpace = SyntaxFactory.Whitespace("");[m
[32m+[m[32m            var publicModifier = SyntaxFactory.ParseToken("public").WithLeadingTrivia(whiteSpace).WithTrailingTrivia(whiteSpace);[m
[32m+[m[32m            var constModifier = SyntaxFactory.ParseToken("const").WithLeadingTrivia(whiteSpace).WithTrailingTrivia(whiteSpace);[m
[32m+[m[32m            var modifierList = SyntaxFactory.TokenList(publicModifier, constModifier);[m
[32m+[m
[32m+[m[32m            var attributeList = new SyntaxList<AttributeListSyntax>();[m
[32m+[m[32m            var fieldDeclaration = SyntaxFactory.FieldDeclaration(attributeList, modifierList, idDeclaration);[m
[32m+[m[32m            var memberList = new SyntaxList<MemberDeclarationSyntax>().Add(fieldDeclaration);[m
[32m+[m
[32m+[m[32m            var newClassDeclaration = declaration.WithMembers(memberList);[m
[32m+[m[32m            foreach (MemberDeclarationSyntax member in declaration.Members)[m
[32m+[m[32m            {[m
[32m+[m[32m                newClassDeclaration = newClassDeclaration.AddMembers(member);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            var root = await document.GetSyntaxRootAsync();[m
[32m+[m[32m            var newRoot = root.ReplaceNode(declaration, newClassDeclaration);[m
[32m+[m[32m            var newDocument = document.WithSyntaxRoot(newRoot);[m
[32m+[m
[32m+[m[32m            return newDocument;[m
         }[m
     }[m
 }[m
\ No newline at end of file[m

[33mcommit 27cbf90ee57939767979fd3254f7a20c6c56454a[m
Merge: 12a0355 baf56b2
Author: Daniel King <daniel.king2014@gmail.com>
Date:   Thu Jun 11 10:00:17 2015 -0700

    Merge pull request #9 from daking2014/begin-tests
    
    Begin tests

[33mcommit baf56b2e25419a9ec236f671c65402f4334d234c[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Wed Jun 10 17:04:35 2015 -0700

    first two tests

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/MetaCompilation.Test.csproj b/MetaCompilation/MetaCompilation/MetaCompilation.Test/MetaCompilation.Test.csproj[m
[1mindex b0ddcc9..2162840 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/MetaCompilation.Test.csproj[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/MetaCompilation.Test.csproj[m
[36m@@ -121,6 +121,9 @@[m
       <Name>MetaCompilation</Name>[m
     </ProjectReference>[m
   </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Service Include="{82A7F48D-3B50-4B1E-B82E-3ADA8210C358}" />[m
[32m+[m[32m  </ItemGroup>[m
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />[m
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. [m
        Other similar extension points exist, see Microsoft.Common.targets.[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex 3bdd162..7c5c1e9 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -14,5 +14,94 @@[m [mnamespace MetaCompilation.Test[m
     [TestClass][m
     public class UnitTest : CodeFixVerifier[m
     {[m
[32m+[m[32m        //no diagnostics[m
[32m+[m[32m        [TestMethod][m
[32m+[m[32m        public void TestMethod1()[m
[32m+[m[32m        {[m
[32m+[m[32m            var test = @"";[m
[32m+[m
[32m+[m[32m            VerifyCSharpDiagnostic(test);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        //no diagnostics[m
[32m+[m[32m        [TestMethod][m
[32m+[m[32m        public void TestMethod2()[m
[32m+[m[32m        {[m
[32m+[m[32m            var test = @"using System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32m            using System.Collections.Immutable;[m
[32m+[m[32m            using System.Linq;[m
[32m+[m[32m            using System.Threading;[m
[32m+[m[32m            using Microsoft.CodeAnalysis;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.Text;[m
[32m+[m
[32m+[m[32mnamespace SyntaxNodeAnalyzer[m
[32m+[m[32m    {[m
[32m+[m[32m        [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[32m+[m[32m        public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m        {[m
[32m+[m[32m            public const string spacingRuleId = ""IfSpacing"";[m
[32m+[m
[32m+[m[32m            internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m                id: spacingRuleId, //make the id specific[m
[32m+[m[32m                title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[32m+[m[32m                messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[32m+[m[32m                category: ""Syntax"", //make the category specific[m
[32m+[m[32m                defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m                isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m            public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[32m+[m[32m            {[m
[32m+[m[32m                get[m
[32m+[m[32m                {[m
[32m+[m[32m                    return ImmutableArray.Create(Rule);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            public override void Initialize(AnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m                var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m                var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m                var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m
[32m+[m[32m                if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m                {[m
[32m+[m[32m                    var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                    if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                        {[m
[32m+[m[32m                            return;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m                obj.ReportDiagnostic(diagnostic);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m";[m
[32m+[m[32m            VerifyCSharpDiagnostic(test);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        protected override CodeFixProvider GetCSharpCodeFixProvider()[m
[32m+[m[32m        {[m
[32m+[m[32m            return new MetaCompilationCodeFixProvider();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        protected override DiagnosticAnalyzer GetCSharpDiagnosticAnalyzer()[m
[32m+[m[32m        {[m
[32m+[m[32m            return new MetaCompilationAnalyzer();[m
[32m+[m[32m        }[m
     }[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1mindex 9a76579..61c1d01 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[36m@@ -41,12 +41,10 @@[m [mpublic sealed override FixAllProvider GetFixAllProvider()[m
             {[m
                 TextSpan diagnosticSpan = diagnostic.Location.SourceSpan;[m
                 //TODO: if statements for each diagnostic id, to register a code fix[m
[31m-                if (diagnostic.Id.Equals(MetaCompilationAnalyzer.missingId))[m
[32m+[m[32m                if (diagnostic.Id.Equals(MetaCompilationAnalyzer.MissingId))[m
                 {[m
[31m-                    var declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf()[m
[31m-                        .OfType<ClassDeclarationSyntax>().First();[m
[31m-                    context.RegisterCodeFix(CodeAction.Create("Remove invalid statement",[m
[31m-                        c => MissingIdAsync(context.Document, declaration, c)), diagnostic);[m
[32m+[m[32m                    ClassDeclarationSyntax declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<ClassDeclarationSyntax>().First();[m
[32m+[m[32m                    context.RegisterCodeFix(CodeAction.Create("Remove invalid statement", c => MissingIdAsync(context.Document, declaration, c)), diagnostic);[m
                 }[m
             }[m
         }[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex fc57cee..45afc7f 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -319,7 +319,7 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                         var statement = statements[0] as ExpressionStatementSyntax;[m
                         if (statement == null)[m
                         {[m
[31m-                            ReportDiagnostic(context, IncorrectInitStatementRule, initializeMethod.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            ReportDiagnostic(context, IncorrectInitStatementRule, statements[0].GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
                             return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
 [m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[1mindex 5547a42..69a89e0 100644[m
[1m--- a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[36m@@ -37,9 +37,9 @@[m [mpublic override void Initialize(AnalysisContext context)[m
             context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
         }[m
 [m
[31m-        private void AnalyzeIfStatement(SyntaxNodeAnalysisContext obj)[m
[32m+[m[32m        private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
         {[m
[31m-            var ifStatement = (IfStatementSyntax)obj.Node;[m
[32m+[m[32m            var ifStatement = (IfStatementSyntax)context.Node;[m
             var ifKeyword = ifStatement.IfKeyword;[m
             var openParen = ifStatement.OpenParenToken;[m
             var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m

[33mcommit a347754348e7bb22c86347873c8c8813d3e7f5c3[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Wed Jun 10 17:04:35 2015 -0700

    first two tests

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/MetaCompilation.Test.csproj b/MetaCompilation/MetaCompilation/MetaCompilation.Test/MetaCompilation.Test.csproj[m
[1mindex b0ddcc9..2162840 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/MetaCompilation.Test.csproj[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/MetaCompilation.Test.csproj[m
[36m@@ -121,6 +121,9 @@[m
       <Name>MetaCompilation</Name>[m
     </ProjectReference>[m
   </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Service Include="{82A7F48D-3B50-4B1E-B82E-3ADA8210C358}" />[m
[32m+[m[32m  </ItemGroup>[m
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />[m
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. [m
        Other similar extension points exist, see Microsoft.Common.targets.[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex 3bdd162..7c5c1e9 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -14,5 +14,94 @@[m [mnamespace MetaCompilation.Test[m
     [TestClass][m
     public class UnitTest : CodeFixVerifier[m
     {[m
[32m+[m[32m        //no diagnostics[m
[32m+[m[32m        [TestMethod][m
[32m+[m[32m        public void TestMethod1()[m
[32m+[m[32m        {[m
[32m+[m[32m            var test = @"";[m
[32m+[m
[32m+[m[32m            VerifyCSharpDiagnostic(test);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        //no diagnostics[m
[32m+[m[32m        [TestMethod][m
[32m+[m[32m        public void TestMethod2()[m
[32m+[m[32m        {[m
[32m+[m[32m            var test = @"using System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32m            using System.Collections.Immutable;[m
[32m+[m[32m            using System.Linq;[m
[32m+[m[32m            using System.Threading;[m
[32m+[m[32m            using Microsoft.CodeAnalysis;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32m            using Microsoft.CodeAnalysis.Text;[m
[32m+[m
[32m+[m[32mnamespace SyntaxNodeAnalyzer[m
[32m+[m[32m    {[m
[32m+[m[32m        [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[32m+[m[32m        public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m        {[m
[32m+[m[32m            public const string spacingRuleId = ""IfSpacing"";[m
[32m+[m
[32m+[m[32m            internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m                id: spacingRuleId, //make the id specific[m
[32m+[m[32m                title: ""If statement must have a space between 'if' and the boolean expression"", //allow any title[m
[32m+[m[32m                messageFormat: ""If statements must contain a space between the 'if' keyword and the boolean expression"", //allow any message[m
[32m+[m[32m                category: ""Syntax"", //make the category specific[m
[32m+[m[32m                defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m                isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m            public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[32m+[m[32m            {[m
[32m+[m[32m                get[m
[32m+[m[32m                {[m
[32m+[m[32m                    return ImmutableArray.Create(Rule);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            public override void Initialize(AnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                var ifStatement = (IfStatementSyntax)context.Node;[m
[32m+[m[32m                var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m                var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m                var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m
[32m+[m[32m                if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m                {[m
[32m+[m[32m                    var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                    if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        if (trailingTrivia.ToString() == "" "")[m
[32m+[m[32m                        {[m
[32m+[m[32m                            return;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m                obj.ReportDiagnostic(diagnostic);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m";[m
[32m+[m[32m            VerifyCSharpDiagnostic(test);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        protected override CodeFixProvider GetCSharpCodeFixProvider()[m
[32m+[m[32m        {[m
[32m+[m[32m            return new MetaCompilationCodeFixProvider();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        protected override DiagnosticAnalyzer GetCSharpDiagnosticAnalyzer()[m
[32m+[m[32m        {[m
[32m+[m[32m            return new MetaCompilationAnalyzer();[m
[32m+[m[32m        }[m
     }[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1mindex 9a76579..61c1d01 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[36m@@ -41,12 +41,10 @@[m [mpublic sealed override FixAllProvider GetFixAllProvider()[m
             {[m
                 TextSpan diagnosticSpan = diagnostic.Location.SourceSpan;[m
                 //TODO: if statements for each diagnostic id, to register a code fix[m
[31m-                if (diagnostic.Id.Equals(MetaCompilationAnalyzer.missingId))[m
[32m+[m[32m                if (diagnostic.Id.Equals(MetaCompilationAnalyzer.MissingId))[m
                 {[m
[31m-                    var declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf()[m
[31m-                        .OfType<ClassDeclarationSyntax>().First();[m
[31m-                    context.RegisterCodeFix(CodeAction.Create("Remove invalid statement",[m
[31m-                        c => MissingIdAsync(context.Document, declaration, c)), diagnostic);[m
[32m+[m[32m                    ClassDeclarationSyntax declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<ClassDeclarationSyntax>().First();[m
[32m+[m[32m                    context.RegisterCodeFix(CodeAction.Create("Remove invalid statement", c => MissingIdAsync(context.Document, declaration, c)), diagnostic);[m
                 }[m
             }[m
         }[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex fc57cee..45afc7f 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -319,7 +319,7 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                         var statement = statements[0] as ExpressionStatementSyntax;[m
                         if (statement == null)[m
                         {[m
[31m-                            ReportDiagnostic(context, IncorrectInitStatementRule, initializeMethod.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            ReportDiagnostic(context, IncorrectInitStatementRule, statements[0].GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
                             return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
 [m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[1mindex 5547a42..69a89e0 100644[m
[1m--- a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[36m@@ -37,9 +37,9 @@[m [mpublic override void Initialize(AnalysisContext context)[m
             context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
         }[m
 [m
[31m-        private void AnalyzeIfStatement(SyntaxNodeAnalysisContext obj)[m
[32m+[m[32m        private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context)[m
         {[m
[31m-            var ifStatement = (IfStatementSyntax)obj.Node;[m
[32m+[m[32m            var ifStatement = (IfStatementSyntax)context.Node;[m
             var ifKeyword = ifStatement.IfKeyword;[m
             var openParen = ifStatement.OpenParenToken;[m
             var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m

[33mcommit a4d8f153345fb519298f5123c431e35f9af80791[m
Merge: 4e28951 6ba9a5d
Author: Daniel King <t-daki@microsoft.com>
Date:   Wed Jun 10 16:39:46 2015 -0700

    Merge branch 'dotnet/codeFixWork'

[33mcommit 12a0355c2af1a78c65317dce373ebd6a23f89ae0[m
Merge: 057f84e 4e28951
Author: Daniel King <daniel.king2014@gmail.com>
Date:   Wed Jun 10 16:34:36 2015 -0700

    Merge pull request #7 from daking2014/coding-guidelines
    
    Coding guidelines

[33mcommit 4e28951f70d83590a56c66c7c7c53e0ced5f7551[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Wed Jun 10 16:33:29 2015 -0700

    coding guidelines

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 2725cb1..b10ca54 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -89,6 +89,7 @@[m [mpublic override void Initialize(AnalysisContext context)[m
 [m
         private void SetupAnalysis(CompilationStartAnalysisContext context)[m
         {[m
[32m+[m[32m            //information collector[m
             CompilationAnalyzer compilationAnalyzer = new CompilationAnalyzer();[m
 [m
             context.RegisterSymbolAction(compilationAnalyzer.AddClass, SymbolKind.NamedType);[m

[33mcommit 1f9f0a2d11139e7c551f27b33781026cf7ce738d[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Wed Jun 10 16:31:42 2015 -0700

    Follow coding guidelines

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mindex bdd4ce8..3bdd162 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -1,9 +1,12 @@[m
[31m-﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32m﻿using System;[m
[32m+[m
[32m+[m[32musing Microsoft.CodeAnalysis;[m
 using Microsoft.CodeAnalysis.CodeFixes;[m
 using Microsoft.CodeAnalysis.Diagnostics;[m
 using Microsoft.VisualStudio.TestTools.UnitTesting;[m
[31m-using System;[m
[32m+[m
 using TestHelper;[m
[32m+[m
 using MetaCompilation;[m
 [m
 namespace MetaCompilation.Test[m
[36m@@ -11,6 +14,5 @@[m [mnamespace MetaCompilation.Test[m
     [TestClass][m
     public class UnitTest : CodeFixVerifier[m
     {[m
[31m-[m
[31m-    }        [m
[32m+[m[32m    }[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1mindex 8f2a6c8..1cb2699 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[36m@@ -5,6 +5,7 @@[m
 using System.Linq;[m
 using System.Threading;[m
 using System.Threading.Tasks;[m
[32m+[m
 using Microsoft.CodeAnalysis;[m
 using Microsoft.CodeAnalysis.CodeFixes;[m
 using Microsoft.CodeAnalysis.CodeActions;[m
[36m@@ -23,7 +24,7 @@[m [mpublic override ImmutableArray<string> FixableDiagnosticIds[m
             get[m
             {[m
                 //TODO: add any new rules[m
[31m-                return ImmutableArray.Create(MetaCompilationAnalyzer.missingId);[m
[32m+[m[32m                return ImmutableArray.Create(MetaCompilationAnalyzer.MissingId);[m
             }[m
         }[m
 [m
[36m@@ -34,12 +35,11 @@[m [mpublic sealed override FixAllProvider GetFixAllProvider()[m
 [m
         public sealed override async Task RegisterCodeFixesAsync(CodeFixContext context)[m
         {[m
[31m-            var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);[m
[32m+[m[32m            SyntaxNode root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);[m
 [m
[31m-            foreach (var diagnostic in context.Diagnostics)[m
[32m+[m[32m            foreach (Diagnostic diagnostic in context.Diagnostics)[m
             {[m
[31m-                var diagnosticSpan = diagnostic.Location.SourceSpan;[m
[31m-[m
[32m+[m[32m                TextSpan diagnosticSpan = diagnostic.Location.SourceSpan;[m
                 //TODO: if statements for each diagnostic id, to register a code fix[m
             }[m
         }[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 876c58f..2725cb1 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -3,6 +3,7 @@[m
 using System.Collections.Immutable;[m
 using System.Linq;[m
 using System.Threading;[m
[32m+[m
 using Microsoft.CodeAnalysis;[m
 using Microsoft.CodeAnalysis.CSharp;[m
 using Microsoft.CodeAnalysis.CSharp.Syntax;[m
[36m@@ -16,9 +17,9 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
     {[m
 [m
         #region id rules[m
[31m-        public const string missingId = "missingId";[m
[31m-        internal static DiagnosticDescriptor missingIdRule = new DiagnosticDescriptor([m
[31m-            id: missingId,[m
[32m+[m[32m        public const string MissingId = "missingId";[m
[32m+[m[32m        internal static DiagnosticDescriptor MissingIdRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: MissingId,[m
             title: "You are missing a diagnostic id",[m
             messageFormat: "You are missing a diagnostic id",[m
             category: "Syntax",[m
[36m@@ -27,45 +28,45 @@[m [mpublic class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
         #endregion[m
 [m
         #region initialize rules[m
[31m-        public const string missingInit = "missingInit";[m
[31m-        internal static DiagnosticDescriptor missingInitRule = new DiagnosticDescriptor([m
[31m-            id: missingInit,[m
[32m+[m[32m        public const string MissingInit = "missingInit";[m
[32m+[m[32m        internal static DiagnosticDescriptor MissingInitRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: MissingInit,[m
             title: "You are missing the required Initialize method",[m
             messageFormat: "You are missing the required Initialize method",[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
 [m
[31m-        public const string missingRegisterStatement = "missingRegister";[m
[31m-        internal static DiagnosticDescriptor missingRegisterRule = new DiagnosticDescriptor([m
[31m-            id: missingRegisterStatement,[m
[32m+[m[32m        public const string MissingRegisterStatement = "missingRegister";[m
[32m+[m[32m        internal static DiagnosticDescriptor MissingRegisterRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: MissingRegisterStatement,[m
             title: "You need to register an action within the Initialize method",[m
             messageFormat: "You need to register an action within the Initialize method",[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
 [m
[31m-        public const string tooManyInitStatements = "incorrectInit001";[m
[31m-        internal static DiagnosticDescriptor tooManyInitStatementsRule = new DiagnosticDescriptor([m
[31m-            id: tooManyInitStatements,[m
[32m+[m[32m        public const string TooManyInitStatements = "incorrectInit001";[m
[32m+[m[32m        internal static DiagnosticDescriptor TooManyInitStatementsRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: TooManyInitStatements,[m
             title: "Please only have one statement within Initiailize. You will only be registering one action.",[m
             messageFormat: "Please only have one statement within Initiailize. You will only be registering one action.",[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
 [m
[31m-        public const string incorrectInitStatement = "incorrectInit002";[m
[31m-        internal static DiagnosticDescriptor incorrectInitStatementRule = new DiagnosticDescriptor([m
[31m-            id: incorrectInitStatement,[m
[32m+[m[32m        public const string IncorrectInitStatement = "incorrectInit002";[m
[32m+[m[32m        internal static DiagnosticDescriptor IncorrectInitStatementRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: IncorrectInitStatement,[m
             title: "This statement needs to register for a supported action",[m
             messageFormat: "This statement needs to register for a supported action",[m
             category: "Syntax",[m
             defaultSeverity: DiagnosticSeverity.Error,[m
             isEnabledByDefault: true);[m
 [m
[31m-        public const string incorrectInitSig = "initSignature";[m
[31m-        internal static DiagnosticDescriptor incorrectInitSigRule = new DiagnosticDescriptor([m
[31m-            id: incorrectInitSig,[m
[32m+[m[32m        public const string IncorrectInitSig = "initSignature";[m
[32m+[m[32m        internal static DiagnosticDescriptor IncorrectInitSigRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: IncorrectInitSig,[m
             title: "The signature for the Initialize method is incorrect",[m
             messageFormat: "The signature for the Initialize method is incorrect",[m
             category: "Syntax",[m
[36m@@ -77,7 +78,7 @@[m [mpublic override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
         {[m
             get[m
             {[m
[31m-                return ImmutableArray.Create(missingIdRule, missingInitRule, missingRegisterRule, tooManyInitStatementsRule, incorrectInitStatementRule, incorrectInitSigRule);[m
[32m+[m[32m                return ImmutableArray.Create(MissingIdRule, MissingInitRule, MissingRegisterRule, TooManyInitStatementsRule, IncorrectInitStatementRule, IncorrectInitSigRule);[m
             }[m
         }[m
 [m
[36m@@ -100,38 +101,49 @@[m [mprivate void SetupAnalysis(CompilationStartAnalysisContext context)[m
 [m
         class CompilationAnalyzer[m
         {[m
[31m-            List<IMethodSymbol> analyzerMethodSymbols = new List<IMethodSymbol>();[m
[31m-            List<IPropertySymbol> analyzerPropertySymbols = new List<IPropertySymbol>();[m
[31m-            List<IFieldSymbol> analyzerFieldSymbols = new List<IFieldSymbol>();[m
[31m-            List<INamedTypeSymbol> otherClassSymbols = new List<INamedTypeSymbol>();[m
[31m-            IMethodSymbol initializeSymbol = null;[m
[31m-            IPropertySymbol propertySymbol = null; [m
[31m-            INamedTypeSymbol analyzerClassSymbol = null;[m
[31m-            Dictionary<string, string> branchesDict = new Dictionary<string, string>();[m
[32m+[m[32m            private List<IMethodSymbol> _analyzerMethodSymbols = new List<IMethodSymbol>();[m
[32m+[m[32m            private List<IPropertySymbol> _analyzerPropertySymbols = new List<IPropertySymbol>();[m
[32m+[m[32m            private List<IFieldSymbol> _analyzerFieldSymbols = new List<IFieldSymbol>();[m
[32m+[m[32m            private List<INamedTypeSymbol> _otherClassSymbols = new List<INamedTypeSymbol>();[m
[32m+[m[32m            private IMethodSymbol _initializeSymbol = null;[m
[32m+[m[32m            private IPropertySymbol _propertySymbol = null;[m[41m [m
[32m+[m[32m            private INamedTypeSymbol _analyzerClassSymbol = null;[m
[32m+[m[32m            private Dictionary<string, string> _branchesDict = new Dictionary<string, string>();[m
 [m
             internal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context)[m
             {[m
                 //supported main branches for tutorial[m
[31m-                branchesDict.Add("RegisterSyntaxNodeAction", "SyntaxNode");[m
[32m+[m[32m                _branchesDict.Add("RegisterSyntaxNodeAction", "SyntaxNode");[m
 [m
                 //supported sub-branches for tutorial[m
                 List<string> allowedKinds = new List<string>();[m
                 allowedKinds.Add("IfStatement");[m
 [m
[31m-                if (analyzerClassSymbol == null)[m
[32m+[m[32m                if (_analyzerClassSymbol == null)[m
                 {[m
                     return;[m
                 }[m
 [m
                 //gather initialize info[m
                 List<object> registerInfo = CheckInitialize(context);[m
[31m-                if (registerInfo == null) return;[m
[31m-               [m
[32m+[m[32m                if (registerInfo == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
                 var registerSymbol = (IMethodSymbol)registerInfo[0];[m
[31m-                if (registerSymbol == null) return;[m
[32m+[m[32m                if (registerSymbol == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
                 var registerArgs = (List<ISymbol>)registerInfo[1];[m
[31m-                if (registerArgs == null) return;[m
[31m-                if (registerArgs.Count == 0) return;[m
[32m+[m[32m                if (registerArgs == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (registerArgs.Count == 0)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
                 if (registerArgs.Count > 0)[m
                 {[m
                     if (registerArgs[0] != null)[m
[36m@@ -146,9 +158,12 @@[m [minternal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context[m
                 }[m
 [m
                 var invocationExpression = (InvocationExpressionSyntax)registerInfo[2];[m
[31m-                if (invocationExpression == null) return;[m
[32m+[m[32m                if (invocationExpression == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
                 //interpret initialize info[m
[31m-                if (branchesDict.ContainsKey(registerSymbol.Name.ToString()))[m
[32m+[m[32m                if (_branchesDict.ContainsKey(registerSymbol.Name.ToString()))[m
                 {[m
                     string kindName = null;[m
                     if (kind != null)[m
[36m@@ -159,21 +174,21 @@[m [minternal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context[m
                     if (kindName == null || allowedKinds.Contains(kindName))[m
                     {[m
                         //look for and interpret id fields[m
[31m-                        var idNames = CheckIds(branchesDict[registerSymbol.Name.ToString()], kindName, context);[m
[32m+[m[32m                        List<string> idNames = CheckIds(_branchesDict[registerSymbol.Name.ToString()], kindName, context);[m
                         if (idNames.Count > 0)[m
                         {[m
                             //look for and interpret rule fields[m
[31m-                            var ruleNames = CheckRules(idNames, branchesDict[registerSymbol.Name.ToString()], kindName, context);[m
[32m+[m[32m                            List<string> ruleNames = CheckRules(idNames, _branchesDict[registerSymbol.Name.ToString()], kindName, context);[m
 [m
                             if (ruleNames.Count > 0)[m
                             {[m
                                 //look for and interpret SupportedDiagnostics property[m
[31m-                                var supportedDiagnosticsCorrect = CheckSupportedDiagnostics(ruleNames, context);[m
[32m+[m[32m                               bool supportedDiagnosticsCorrect = CheckSupportedDiagnostics(ruleNames, context);[m
 [m
                                 if (supportedDiagnosticsCorrect)[m
                                 {[m
                                     //check the SyntaxNode, Symbol, Compilation, CodeBlock, etc analysis method(s)[m
[31m-                                    var analysisCorrect = CheckAnlaysis(branchesDict[registerSymbol.Name.ToString()], kindName, ruleNames, context);[m
[32m+[m[32m                                    bool analysisCorrect = CheckAnlaysis(_branchesDict[registerSymbol.Name.ToString()], kindName, ruleNames, context);[m
                                     if (analysisCorrect)[m
                                     {[m
                                         //diagnostic to go to code fix[m
[36m@@ -196,22 +211,19 @@[m [minternal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context[m
                         else[m
                         {[m
                             // diagnostic for missing id names[m
[31m-                            var analyzerClassSyntax = analyzerClassSymbol.DeclaringSyntaxReferences[0].GetSyntax() as ClassDeclarationSyntax;[m
[31m-                            ReportDiagnostic(context, missingIdRule, analyzerClassSyntax.Identifier.GetLocation(), analyzerClassSyntax.Identifier.ToString());[m
[32m+[m[32m                           var analyzerClassSyntax = _analyzerClassSymbol.DeclaringSyntaxReferences[0].GetSyntax() as ClassDeclarationSyntax;[m
[32m+[m[32m                           ReportDiagnostic(context, MissingIdRule, analyzerClassSyntax.Identifier.GetLocation(), analyzerClassSyntax.Identifier.ToString());[m
                         }[m
                     }[m
                     else[m
                     {[m
[31m-                        ReportDiagnostic(context, incorrectInitStatementRule, invocationExpression.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                        ReportDiagnostic(context, IncorrectInitStatementRule, invocationExpression.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
                     }[m
                 }[m
                 else[m
                 {[m
                     //diagnostic[m
                 }[m
[31m-[m
[31m-[m
[31m-                [m
             }[m
 [m
             internal bool CheckAnlaysis(string branch, string kind, List<string> ruleNames, CompilationAnalysisContext context)[m
[36m@@ -235,11 +247,14 @@[m [minternal List<string> CheckRules(List<string> idNames, string branch, string kin[m
             internal List<string> CheckIds(string branch, string kind, CompilationAnalysisContext context)[m
             {[m
                 List<string> idNames = new List<string>();[m
[31m-                foreach (IFieldSymbol field in analyzerFieldSymbols)[m
[32m+[m[32m                foreach (IFieldSymbol field in _analyzerFieldSymbols)[m
                 {[m
                     if (field.IsConst && field.IsStatic && field.DeclaredAccessibility.ToString() == "public" && field.Type.ToString() == "string")[m
                     {[m
[31m-                        if (field.Name == null) continue;[m
[32m+[m[32m                        if (field.Name == null)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            continue;[m
[32m+[m[32m                        }[m
                         idNames.Add(field.Name.ToString());[m
                     }[m
                 }[m
[36m@@ -256,55 +271,62 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                 InvocationExpressionSyntax invocExpr = null;[m
 [m
                 [m
[31m-                if (initializeSymbol == null)[m
[32m+[m[32m                if (_initializeSymbol == null)[m
                 {[m
                     //the initialize method was not found[m
[31m-                    ReportDiagnostic(context, missingInitRule, analyzerClassSymbol.Locations[0], missingInitRule.MessageFormat);[m
[32m+[m[32m                    ReportDiagnostic(context, MissingInitRule, _analyzerClassSymbol.Locations[0], MissingInitRule.MessageFormat);[m
                     return new List<object>(new object[] { registerCall, registerArgs });[m
                 }[m
                 else[m
                 {[m
                     //checking method signature[m
[31m-                    var parameters = initializeSymbol.Parameters;[m
[31m-                    if (parameters.Count() != 1 || parameters[0].Type.ToString() != "Microsoft.CodeAnalysis.Diagnostics.AnalysisContext" || parameters[0].Name.ToString() != "context" || initializeSymbol.DeclaredAccessibility.ToString() != "Public" || !initializeSymbol.IsOverride || !initializeSymbol.ReturnsVoid)[m
[32m+[m[32m                    ImmutableArray<IParameterSymbol> parameters = _initializeSymbol.Parameters;[m
[32m+[m[32m                    if (parameters.Count() != 1 || parameters[0].Type.ToString() != "Microsoft.CodeAnalysis.Diagnostics.AnalysisContext" || parameters[0].Name.ToString() != "context" || _initializeSymbol.DeclaredAccessibility.ToString() != "Public" || !_initializeSymbol.IsOverride || !_initializeSymbol.ReturnsVoid)[m
                     {[m
[31m-                        ReportDiagnostic(context, incorrectInitSigRule, initializeSymbol.Locations[0], missingInitRule.MessageFormat);[m
[32m+[m[32m                        ReportDiagnostic(context, IncorrectInitSigRule, _initializeSymbol.Locations[0], MissingInitRule.MessageFormat);[m
                         return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                     }[m
                     [m
                     //looking at the contents of the initialize method[m
[31m-                    var initializeMethod = initializeSymbol.DeclaringSyntaxReferences[0].GetSyntax() as MethodDeclarationSyntax;[m
[31m-                    if (initializeMethod == null) return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
[32m+[m[32m                    var initializeMethod = _initializeSymbol.DeclaringSyntaxReferences[0].GetSyntax() as MethodDeclarationSyntax;[m
[32m+[m[32m                    if (initializeMethod == null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
[32m+[m[32m                    }[m
 [m
                     var codeBlock = initializeMethod.Body as BlockSyntax;[m
[31m-                    if (codeBlock == null) return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
[32m+[m[32m                    if (codeBlock == null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
[32m+[m[32m                    }[m
 [m
[31m-                    var statements = codeBlock.Statements;[m
[32m+[m[32m                    SyntaxList<StatementSyntax> statements = codeBlock.Statements;[m
                     if (statements.Count == 0)[m
                     {[m
                         //no statements inside initiailize[m
[31m-                        ReportDiagnostic(context, missingRegisterRule, initializeSymbol.Locations[0], missingRegisterRule.MessageFormat);[m
[32m+[m[32m                        ReportDiagnostic(context, MissingRegisterRule, _initializeSymbol.Locations[0], MissingRegisterRule.MessageFormat);[m
                         return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                     }[m
                     else if (statements.Count > 1)[m
                     {[m
                         //too many statements inside initialize[m
[31m-                        ReportDiagnostic(context, tooManyInitStatementsRule, statements[0].GetLocation(), tooManyInitStatementsRule.MessageFormat);[m
[32m+[m[32m                        ReportDiagnostic(context, TooManyInitStatementsRule, statements[0].GetLocation(), TooManyInitStatementsRule.MessageFormat);[m
                         return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                     }[m
                     else[m
                     {[m
                         //only one statement inside initialize[m
                         var statement = statements[0] as ExpressionStatementSyntax;[m
[31m-                        if (statement == null) {[m
[31m-                            ReportDiagnostic(context, incorrectInitStatementRule, initializeMethod.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                        if (statement == null)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            ReportDiagnostic(context, IncorrectInitStatementRule, initializeMethod.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
                             return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
 [m
                         var invocationExpr = statement.Expression as InvocationExpressionSyntax;[m
                         if (invocationExpr == null)[m
                         {[m
[31m-                            ReportDiagnostic(context, incorrectInitStatementRule, statement.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            ReportDiagnostic(context, IncorrectInitStatementRule, statement.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
                             return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
                         invocExpr = invocationExpr;[m
[36m@@ -312,31 +334,31 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                         var memberExpr = invocationExpr.Expression as MemberAccessExpressionSyntax;[m
                         if (memberExpr == null)[m
                         {[m
[31m-                            ReportDiagnostic(context, incorrectInitStatementRule, invocationExpr.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            ReportDiagnostic(context, IncorrectInitStatementRule, invocationExpr.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
                             return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
 [m
                         var memberExprContext = memberExpr.Expression as IdentifierNameSyntax;[m
                         if (memberExprContext == null)[m
                         {[m
[31m-                            ReportDiagnostic(context, incorrectInitStatementRule, memberExpr.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            ReportDiagnostic(context, IncorrectInitStatementRule, memberExpr.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
                             return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
                         if (memberExprContext.Identifier.ToString() != "context")[m
                         {[m
[31m-                            ReportDiagnostic(context, incorrectInitStatementRule, memberExprContext.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            ReportDiagnostic(context, IncorrectInitStatementRule, memberExprContext.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
                             return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
 [m
                         var memberExprRegister = memberExpr.Name as IdentifierNameSyntax;[m
                         if (memberExprRegister == null)[m
                         {[m
[31m-                            ReportDiagnostic(context, incorrectInitStatementRule, memberExpr.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            ReportDiagnostic(context, IncorrectInitStatementRule, memberExpr.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
                             return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
[31m-                        if (!branchesDict.ContainsKey(memberExprRegister.ToString()))[m
[32m+[m[32m                        if (!_branchesDict.ContainsKey(memberExprRegister.ToString()))[m
                         {[m
[31m-                            ReportDiagnostic(context, incorrectInitStatementRule, memberExprRegister.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            ReportDiagnostic(context, IncorrectInitStatementRule, memberExprRegister.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
                             return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
 [m
[36m@@ -348,22 +370,26 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                         {[m
                             registerCall = context.Compilation.GetSemanticModel(memberExpr.SyntaxTree).GetSymbolInfo(memberExpr).CandidateSymbols[0] as IMethodSymbol;[m
                         }[m
[31m-                        if (registerCall == null) return new List<object>(new object[] { registerCall, registerArgs });[m
 [m
[31m-                        var arguments = invocationExpr.ArgumentList.Arguments;[m
[32m+[m[32m                        if (registerCall == null)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        SeparatedSyntaxList<ArgumentSyntax> arguments = invocationExpr.ArgumentList.Arguments;[m
                         if (arguments == null)[m
                         {[m
[31m-                            ReportDiagnostic(context, incorrectInitStatementRule, memberExpr.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            ReportDiagnostic(context, IncorrectInitStatementRule, memberExpr.GetLocation(), IncorrectInitStatementRule.MessageFormat);[m
                             return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
                         if (arguments.Count() > 0)[m
                         {[m
[31m-                            var actionSymbol = context.Compilation.GetSemanticModel(invocationExpr.SyntaxTree).GetSymbolInfo(arguments[0].Expression).Symbol as IMethodSymbol;[m
[32m+[m[32m                            IMethodSymbol actionSymbol = context.Compilation.GetSemanticModel(invocationExpr.SyntaxTree).GetSymbolInfo(arguments[0].Expression).Symbol as IMethodSymbol;[m
                             registerArgs.Add(actionSymbol);[m
 [m
                             if (arguments.Count() > 1)[m
                             {[m
[31m-                                var kindSymbol = context.Compilation.GetSemanticModel(invocationExpr.SyntaxTree).GetSymbolInfo(arguments[1].Expression).Symbol as IFieldSymbol;[m
[32m+[m[32m                                IFieldSymbol kindSymbol = context.Compilation.GetSemanticModel(invocationExpr.SyntaxTree).GetSymbolInfo(arguments[1].Expression).Symbol as IFieldSymbol;[m
                                 if (kindSymbol == null)[m
                                 {[m
                                     return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
[36m@@ -374,11 +400,9 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                                 }[m
                             }[m
                         }[m
[31m-[m
                     }[m
                 }[m
 [m
[31m-[m
                 return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
             }[m
 [m
[36m@@ -403,18 +427,18 @@[m [minternal void AddMethod(SymbolAnalysisContext context)[m
                 {[m
                     return;[m
                 }[m
[31m-                if (analyzerMethodSymbols.Contains(sym))[m
[32m+[m[32m                if (_analyzerMethodSymbols.Contains(sym))[m
                 {[m
                     return;[m
                 }[m
 [m
                 if (sym.Name.ToString() == "Initialize")[m
                 {[m
[31m-                    initializeSymbol = sym;[m
[32m+[m[32m                    _initializeSymbol = sym;[m
                     return;[m
                 }[m
 [m
[31m-                analyzerMethodSymbols.Add(sym);[m
[32m+[m[32m                _analyzerMethodSymbols.Add(sym);[m
             }[m
 [m
             internal void AddProperty(SymbolAnalysisContext context)[m
[36m@@ -437,18 +461,18 @@[m [minternal void AddProperty(SymbolAnalysisContext context)[m
                 {[m
                     return;[m
                 }[m
[31m-                if (analyzerPropertySymbols.Contains(sym))[m
[32m+[m[32m                if (_analyzerPropertySymbols.Contains(sym))[m
                 {[m
                     return;[m
                 }[m
 [m
                 if (sym.Name.ToString() == "SupportedDiagnostics")[m
                 {[m
[31m-                    propertySymbol = sym;[m
[32m+[m[32m                    _propertySymbol = sym;[m
                     return;[m
                 }[m
 [m
[31m-                analyzerPropertySymbols.Add(sym);[m
[32m+[m[32m                _analyzerPropertySymbols.Add(sym);[m
             }[m
 [m
             internal void AddField(SymbolAnalysisContext context)[m
[36m@@ -471,12 +495,12 @@[m [minternal void AddField(SymbolAnalysisContext context)[m
                 {[m
                     return;[m
                 }[m
[31m-                if (analyzerFieldSymbols.Contains(sym))[m
[32m+[m[32m                if (_analyzerFieldSymbols.Contains(sym))[m
                 {[m
                     return;[m
                 }[m
 [m
[31m-                analyzerFieldSymbols.Add(sym);[m
[32m+[m[32m                _analyzerFieldSymbols.Add(sym);[m
             }[m
 [m
             internal void AddClass(SymbolAnalysisContext context)[m
[36m@@ -493,17 +517,23 @@[m [minternal void AddClass(SymbolAnalysisContext context)[m
                 }[m
                 if (sym.BaseType.ToString() != "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer")[m
                 {[m
[31m-                    if (sym.ContainingType == null) return;[m
[31m-                    if (sym.ContainingType.BaseType == null) return;[m
[32m+[m[32m                    if (sym.ContainingType == null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (sym.ContainingType.BaseType == null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return;[m
[32m+[m[32m                    }[m
                     if (sym.ContainingType.BaseType.ToString() == "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer")[m
                     {[m
[31m-                        if (otherClassSymbols.Contains(sym))[m
[32m+[m[32m                        if (_otherClassSymbols.Contains(sym))[m
                         {[m
                             return;[m
                         }[m
                         else[m
                         {[m
[31m-                            otherClassSymbols.Add(sym);[m
[32m+[m[32m                            _otherClassSymbols.Add(sym);[m
                             return;[m
                         }[m
                     }[m
[36m@@ -513,21 +543,21 @@[m [minternal void AddClass(SymbolAnalysisContext context)[m
                     }[m
                 }[m
 [m
[31m-                analyzerClassSymbol = sym;[m
[32m+[m[32m                _analyzerClassSymbol = sym;[m
             }[m
             #endregion[m
 [m
             internal void ClearState()[m
             {[m
[31m-                analyzerClassSymbol = null;[m
[31m-                analyzerFieldSymbols = new List<IFieldSymbol>();[m
[31m-                analyzerMethodSymbols = new List<IMethodSymbol>();[m
[31m-                analyzerPropertySymbols = new List<IPropertySymbol>();[m
[32m+[m[32m                _analyzerClassSymbol = null;[m
[32m+[m[32m                _analyzerFieldSymbols = new List<IFieldSymbol>();[m
[32m+[m[32m                _analyzerMethodSymbols = new List<IMethodSymbol>();[m
[32m+[m[32m                _analyzerPropertySymbols = new List<IPropertySymbol>();[m
             }[m
 [m
             public static void ReportDiagnostic(CompilationAnalysisContext context, DiagnosticDescriptor rule, Location location, params object[] messageArgs)[m
             {[m
[31m-                var diagnostic = Diagnostic.Create(rule, location, messageArgs);[m
[32m+[m[32m                Diagnostic diagnostic = Diagnostic.Create(rule, location, messageArgs);[m
                 context.ReportDiagnostic(diagnostic);[m
             }[m
         }[m

[33mcommit 057f84ed4d98da2a2b25cbdf0795c6f89bd53e9d[m
Merge: 6c2330f 6ba9a5d
Author: Jessica Petty <jessica.petty@colorado.edu>
Date:   Wed Jun 10 16:27:18 2015 -0700

    Merge pull request #6 from dotnet/codeFixWork
    
    Fixed false diagnostic send

[33mcommit 6ba9a5d86ecbc1641da4657e2622f3ae6d185584[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Wed Jun 10 16:22:06 2015 -0700

    Fixed false diagnostic send

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1mindex 8f2a6c8..7cc22a1 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[36m@@ -41,7 +41,19 @@[m [mpublic sealed override FixAllProvider GetFixAllProvider()[m
                 var diagnosticSpan = diagnostic.Location.SourceSpan;[m
 [m
                 //TODO: if statements for each diagnostic id, to register a code fix[m
[32m+[m[32m                if (diagnostic.Id.Equals(MetaCompilationAnalyzer.missingId))[m
[32m+[m[32m                {[m
[32m+[m[32m                    var declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf()[m
[32m+[m[32m                        .OfType<ClassDeclarationSyntax>().First();[m
[32m+[m[32m                    context.RegisterCodeFix(CodeAction.Create("Remove invalid statement",[m
[32m+[m[32m                        c => MissingIdAsync(context.Document, declaration, c)), diagnostic);[m
[32m+[m[32m                }[m
             }[m
         }[m
[32m+[m
[32m+[m[32m        private async Task<Document> MissingIdAsync(Document document, ClassDeclarationSyntax declaration, CancellationToken c)[m
[32m+[m[32m        {[m
[32m+[m[32m            throw new NotImplementedException();[m
[32m+[m[32m        }[m
     }[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex 5d28ac6..32bb80d 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -8,7 +8,6 @@[m
 using Microsoft.CodeAnalysis.CSharp.Syntax;[m
 using Microsoft.CodeAnalysis.Diagnostics;[m
 using Microsoft.CodeAnalysis.Text;[m
[31m-//jessica[m
 namespace MetaCompilation[m
 {[m
     [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[36m@@ -235,7 +234,7 @@[m [minternal List<string> CheckIds(string branch, string kind, CompilationAnalysisCo[m
                 List<string> idNames = new List<string>();[m
                 foreach (IFieldSymbol field in analyzerFieldSymbols)[m
                 {[m
[31m-                    if (field.IsConst && field.IsStatic && field.DeclaredAccessibility.ToString() == "public" && field.Type.ToString() == "string")[m
[32m+[m[32m                    if (field.IsConst && field.IsStatic && field.DeclaredAccessibility.ToString() == "Public" && field.Type.ToString() == "string")[m
                     {[m
                         if (field.Name == null) continue;[m
                         idNames.Add(field.Name.ToString());[m

[33mcommit 6c2330f624094498cab50583ee9de75972900670[m
Merge: 030836a fc8e712
Author: Daniel King <daniel.king2014@gmail.com>
Date:   Wed Jun 10 14:56:58 2015 -0700

    Merge pull request #5 from daking2014/initialize-fix
    
    fix initialize

[33mcommit fc8e71299176dfeb5b5bf46587315610619f01d2[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Wed Jun 10 14:55:05 2015 -0700

    fix initialize
    
    underline incorrect syntax kinds

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex b454fee..876c58f 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -145,6 +145,8 @@[m [minternal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context[m
                     kind = (IFieldSymbol)registerArgs[1];[m
                 }[m
 [m
[32m+[m[32m                var invocationExpression = (InvocationExpressionSyntax)registerInfo[2];[m
[32m+[m[32m                if (invocationExpression == null) return;[m
                 //interpret initialize info[m
                 if (branchesDict.ContainsKey(registerSymbol.Name.ToString()))[m
                 {[m
[36m@@ -200,7 +202,7 @@[m [minternal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context[m
                     }[m
                     else[m
                     {[m
[31m-                        ReportDiagnostic(context, incorrectInitStatementRule, registerSymbol.Locations[0], incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                        ReportDiagnostic(context, incorrectInitStatementRule, invocationExpression.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
                     }[m
                 }[m
                 else[m
[36m@@ -251,6 +253,7 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                 //default values for returning[m
                 IMethodSymbol registerCall = null;[m
                 List<ISymbol> registerArgs = new List<ISymbol>();[m
[32m+[m[32m                InvocationExpressionSyntax invocExpr = null;[m
 [m
                 [m
                 if (initializeSymbol == null)[m
[36m@@ -266,28 +269,28 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                     if (parameters.Count() != 1 || parameters[0].Type.ToString() != "Microsoft.CodeAnalysis.Diagnostics.AnalysisContext" || parameters[0].Name.ToString() != "context" || initializeSymbol.DeclaredAccessibility.ToString() != "Public" || !initializeSymbol.IsOverride || !initializeSymbol.ReturnsVoid)[m
                     {[m
                         ReportDiagnostic(context, incorrectInitSigRule, initializeSymbol.Locations[0], missingInitRule.MessageFormat);[m
[31m-                        return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                        return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                     }[m
                     [m
                     //looking at the contents of the initialize method[m
                     var initializeMethod = initializeSymbol.DeclaringSyntaxReferences[0].GetSyntax() as MethodDeclarationSyntax;[m
[31m-                    if (initializeMethod == null) return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                    if (initializeMethod == null) return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
 [m
                     var codeBlock = initializeMethod.Body as BlockSyntax;[m
[31m-                    if (codeBlock == null) return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                    if (codeBlock == null) return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
 [m
                     var statements = codeBlock.Statements;[m
                     if (statements.Count == 0)[m
                     {[m
                         //no statements inside initiailize[m
                         ReportDiagnostic(context, missingRegisterRule, initializeSymbol.Locations[0], missingRegisterRule.MessageFormat);[m
[31m-                        return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                        return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                     }[m
                     else if (statements.Count > 1)[m
                     {[m
                         //too many statements inside initialize[m
                         ReportDiagnostic(context, tooManyInitStatementsRule, statements[0].GetLocation(), tooManyInitStatementsRule.MessageFormat);[m
[31m-                        return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                        return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                     }[m
                     else[m
                     {[m
[36m@@ -295,45 +298,46 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                         var statement = statements[0] as ExpressionStatementSyntax;[m
                         if (statement == null) {[m
                             ReportDiagnostic(context, incorrectInitStatementRule, initializeMethod.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[31m-                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
 [m
                         var invocationExpr = statement.Expression as InvocationExpressionSyntax;[m
                         if (invocationExpr == null)[m
                         {[m
                             ReportDiagnostic(context, incorrectInitStatementRule, statement.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[31m-                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
[32m+[m[32m                        invocExpr = invocationExpr;[m
 [m
                         var memberExpr = invocationExpr.Expression as MemberAccessExpressionSyntax;[m
                         if (memberExpr == null)[m
                         {[m
                             ReportDiagnostic(context, incorrectInitStatementRule, invocationExpr.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[31m-                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
 [m
                         var memberExprContext = memberExpr.Expression as IdentifierNameSyntax;[m
                         if (memberExprContext == null)[m
                         {[m
                             ReportDiagnostic(context, incorrectInitStatementRule, memberExpr.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[31m-                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
                         if (memberExprContext.Identifier.ToString() != "context")[m
                         {[m
                             ReportDiagnostic(context, incorrectInitStatementRule, memberExprContext.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[31m-                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
 [m
                         var memberExprRegister = memberExpr.Name as IdentifierNameSyntax;[m
                         if (memberExprRegister == null)[m
                         {[m
                             ReportDiagnostic(context, incorrectInitStatementRule, memberExpr.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[31m-                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
                         if (!branchesDict.ContainsKey(memberExprRegister.ToString()))[m
                         {[m
                             ReportDiagnostic(context, incorrectInitStatementRule, memberExprRegister.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[31m-                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
 [m
                         if (context.Compilation.GetSemanticModel(invocationExpr.SyntaxTree).GetSymbolInfo(memberExpr).CandidateSymbols.Count() == 0)[m
[36m@@ -350,7 +354,7 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                         if (arguments == null)[m
                         {[m
                             ReportDiagnostic(context, incorrectInitStatementRule, memberExpr.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[31m-                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                         }[m
                         if (arguments.Count() > 0)[m
                         {[m
[36m@@ -362,7 +366,7 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                                 var kindSymbol = context.Compilation.GetSemanticModel(invocationExpr.SyntaxTree).GetSymbolInfo(arguments[1].Expression).Symbol as IFieldSymbol;[m
                                 if (kindSymbol == null)[m
                                 {[m
[31m-                                    return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                                    return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
                                 }[m
                                 else[m
                                 {[m
[36m@@ -375,7 +379,7 @@[m [minternal List<object> CheckInitialize(CompilationAnalysisContext context)[m
                 }[m
 [m
 [m
[31m-                return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                return new List<object>(new object[] { registerCall, registerArgs, invocExpr });[m
             }[m
 [m
             #region symbol collectors[m

[33mcommit a8124d9b5d7dc05483fe6ef8424aed57064df1e5[m
Author: Jessica Petty <t-jepett@microsoft.com>
Date:   Wed Jun 10 13:53:49 2015 -0700

    test

[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mindex b454fee..5d28ac6 100644[m
[1m--- a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -8,7 +8,7 @@[m
 using Microsoft.CodeAnalysis.CSharp.Syntax;[m
 using Microsoft.CodeAnalysis.Diagnostics;[m
 using Microsoft.CodeAnalysis.Text;[m
[31m-[m
[32m+[m[32m//jessica[m
 namespace MetaCompilation[m
 {[m
     [DiagnosticAnalyzer(LanguageNames.CSharp)][m

[33mcommit 030836ac8127f4753bc8a738ffc9767fd625135c[m
Merge: 13f3692 4d2c1ba
Author: Daniel King <daniel.king2014@gmail.com>
Date:   Wed Jun 10 13:31:02 2015 -0700

    Merge pull request #1 from daking2014/Initial-check-in
    
    Initial commit

[33mcommit 4d2c1ba61aa863fa84c7e975bc69428cc1e9cebc[m
Author: Daniel King <t-daki@microsoft.com>
Date:   Wed Jun 10 13:26:59 2015 -0700

    Initial commit
    
    MetaCompilation, SyntaxNodeAnalyzer, NewAnalyzerTemplate

[1mdiff --git a/MetaCompilation/MetaCompilation.sln b/MetaCompilation/MetaCompilation.sln[m
[1mnew file mode 100644[m
[1mindex 0000000..eb1d620[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation.sln[m
[36m@@ -0,0 +1,34 @@[m
[32m+[m[32m﻿[m
[32m+[m[32mMicrosoft Visual Studio Solution File, Format Version 12.00[m
[32m+[m[32m# Visual Studio 14[m
[32m+[m[32mVisualStudioVersion = 14.0.22823.1[m
[32m+[m[32mMinimumVisualStudioVersion = 10.0.40219.1[m
[32m+[m[32mProject("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MetaCompilation", "MetaCompilation\MetaCompilation\MetaCompilation.csproj", "{6CD505A6-60D7-4C35-AE53-694AFDEB3A64}"[m
[32m+[m[32mEndProject[m
[32m+[m[32mProject("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MetaCompilation.Test", "MetaCompilation\MetaCompilation.Test\MetaCompilation.Test.csproj", "{45D60761-2694-4084-9B23-B8D1660B6712}"[m
[32m+[m[32mEndProject[m
[32m+[m[32mProject("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MetaCompilation.Vsix", "MetaCompilation\MetaCompilation.Vsix\MetaCompilation.Vsix.csproj", "{AEDFBCB1-8D38-4148-B9D5-E31FB6087E14}"[m
[32m+[m[32mEndProject[m
[32m+[m[32mGlobal[m
[32m+[m	[32mGlobalSection(SolutionConfigurationPlatforms) = preSolution[m
[32m+[m		[32mDebug|Any CPU = Debug|Any CPU[m
[32m+[m		[32mRelease|Any CPU = Release|Any CPU[m
[32m+[m	[32mEndGlobalSection[m
[32m+[m	[32mGlobalSection(ProjectConfigurationPlatforms) = postSolution[m
[32m+[m		[32m{6CD505A6-60D7-4C35-AE53-694AFDEB3A64}.Debug|Any CPU.ActiveCfg = Debug|Any CPU[m
[32m+[m		[32m{6CD505A6-60D7-4C35-AE53-694AFDEB3A64}.Debug|Any CPU.Build.0 = Debug|Any CPU[m
[32m+[m		[32m{6CD505A6-60D7-4C35-AE53-694AFDEB3A64}.Release|Any CPU.ActiveCfg = Release|Any CPU[m
[32m+[m		[32m{6CD505A6-60D7-4C35-AE53-694AFDEB3A64}.Release|Any CPU.Build.0 = Release|Any CPU[m
[32m+[m		[32m{45D60761-2694-4084-9B23-B8D1660B6712}.Debug|Any CPU.ActiveCfg = Debug|Any CPU[m
[32m+[m		[32m{45D60761-2694-4084-9B23-B8D1660B6712}.Debug|Any CPU.Build.0 = Debug|Any CPU[m
[32m+[m		[32m{45D60761-2694-4084-9B23-B8D1660B6712}.Release|Any CPU.ActiveCfg = Release|Any CPU[m
[32m+[m		[32m{45D60761-2694-4084-9B23-B8D1660B6712}.Release|Any CPU.Build.0 = Release|Any CPU[m
[32m+[m		[32m{AEDFBCB1-8D38-4148-B9D5-E31FB6087E14}.Debug|Any CPU.ActiveCfg = Debug|Any CPU[m
[32m+[m		[32m{AEDFBCB1-8D38-4148-B9D5-E31FB6087E14}.Debug|Any CPU.Build.0 = Debug|Any CPU[m
[32m+[m		[32m{AEDFBCB1-8D38-4148-B9D5-E31FB6087E14}.Release|Any CPU.ActiveCfg = Release|Any CPU[m
[32m+[m		[32m{AEDFBCB1-8D38-4148-B9D5-E31FB6087E14}.Release|Any CPU.Build.0 = Release|Any CPU[m
[32m+[m	[32mEndGlobalSection[m
[32m+[m	[32mGlobalSection(SolutionProperties) = preSolution[m
[32m+[m		[32mHideSolutionNode = FALSE[m
[32m+[m	[32mEndGlobalSection[m
[32m+[m[32mEndGlobal[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/CodeFixVerifier.Helper.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/CodeFixVerifier.Helper.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..0f73d06[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/CodeFixVerifier.Helper.cs[m
[36m@@ -0,0 +1,85 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeActions;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Formatting;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Simplification;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m
[32m+[m[32mnamespace TestHelper[m
[32m+[m[32m{[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Diagnostic Producer class with extra methods dealing with applying codefixes[m
[32m+[m[32m    /// All methods are static[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public abstract partial class CodeFixVerifier : DiagnosticVerifier[m
[32m+[m[32m    {[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Apply the inputted CodeAction to the inputted document.[m
[32m+[m[32m        /// Meant to be used to apply codefixes.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="document">The Document to apply the fix on</param>[m
[32m+[m[32m        /// <param name="codeAction">A CodeAction that will be applied to the Document.</param>[m
[32m+[m[32m        /// <returns>A Document with the changes from the CodeAction</returns>[m
[32m+[m[32m        private static Document ApplyFix(Document document, CodeAction codeAction)[m
[32m+[m[32m        {[m
[32m+[m[32m            var operations = codeAction.GetOperationsAsync(CancellationToken.None).Result;[m
[32m+[m[32m            var solution = operations.OfType<ApplyChangesOperation>().Single().ChangedSolution;[m
[32m+[m[32m            return solution.GetDocument(document.Id);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Compare two collections of Diagnostics,and return a list of any new diagnostics that appear only in the second collection.[m
[32m+[m[32m        /// Note: Considers Diagnostics to be the same if they have the same Ids.  In the case of multiple diagnostics with the same Id in a row,[m
[32m+[m[32m        /// this method may not necessarily return the new one.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="diagnostics">The Diagnostics that existed in the code before the CodeFix was applied</param>[m
[32m+[m[32m        /// <param name="newDiagnostics">The Diagnostics that exist in the code after the CodeFix was applied</param>[m
[32m+[m[32m        /// <returns>A list of Diagnostics that only surfaced in the code after the CodeFix was applied</returns>[m
[32m+[m[32m        private static IEnumerable<Diagnostic> GetNewDiagnostics(IEnumerable<Diagnostic> diagnostics, IEnumerable<Diagnostic> newDiagnostics)[m
[32m+[m[32m        {[m
[32m+[m[32m            var oldArray = diagnostics.OrderBy(d => d.Location.SourceSpan.Start).ToArray();[m
[32m+[m[32m            var newArray = newDiagnostics.OrderBy(d => d.Location.SourceSpan.Start).ToArray();[m
[32m+[m
[32m+[m[32m            int oldIndex = 0;[m
[32m+[m[32m            int newIndex = 0;[m
[32m+[m
[32m+[m[32m            while (newIndex < newArray.Length)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (oldIndex < oldArray.Length && oldArray[oldIndex].Id == newArray[newIndex].Id)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ++oldIndex;[m
[32m+[m[32m                    ++newIndex;[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    yield return newArray[newIndex++];[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Get the existing compiler diagnostics on the inputted document.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="document">The Document to run the compiler diagnostic analyzers on</param>[m
[32m+[m[32m        /// <returns>The compiler diagnostics that were found in the code</returns>[m
[32m+[m[32m        private static IEnumerable<Diagnostic> GetCompilerDiagnostics(Document document)[m
[32m+[m[32m        {[m
[32m+[m[32m            return document.GetSemanticModelAsync().Result.GetDiagnostics();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Given a document, turn it into a string based on the syntax root[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="document">The Document to be converted to a string</param>[m
[32m+[m[32m        /// <returns>A string containing the syntax of the Document after formatting</returns>[m
[32m+[m[32m        private static string GetStringFromDocument(Document document)[m
[32m+[m[32m        {[m
[32m+[m[32m            var simplifiedDoc = Simplifier.ReduceAsync(document, Simplifier.Annotation).Result;[m
[32m+[m[32m            var root = simplifiedDoc.GetSyntaxRootAsync().Result;[m
[32m+[m[32m            root = Formatter.Format(root, Formatter.Annotation, simplifiedDoc.Project.Solution.Workspace);[m
[32m+[m[32m            return root.GetText().ToString();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/DiagnosticResult.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/DiagnosticResult.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..5958a4d[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/DiagnosticResult.cs[m
[36m@@ -0,0 +1,86 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing System;[m
[32m+[m
[32m+[m[32mnamespace TestHelper[m
[32m+[m[32m{[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Location where the diagnostic appears, as determined by path, line number, and column number.[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public struct DiagnosticResultLocation[m
[32m+[m[32m    {[m
[32m+[m[32m        public DiagnosticResultLocation(string path, int line, int column)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (line < 0 && column < 0)[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new ArgumentOutOfRangeException("At least one of line and column must be > 0");[m
[32m+[m[32m            }[m
[32m+[m[32m            if (line < -1 || column < -1)[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new ArgumentOutOfRangeException("Both line and column must be >= -1");[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            this.Path = path;[m
[32m+[m[32m            this.Line = line;[m
[32m+[m[32m            this.Column = column;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public string Path;[m
[32m+[m[32m        public int Line;[m
[32m+[m[32m        public int Column;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Struct that stores information about a Diagnostic appearing in a source[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public struct DiagnosticResult[m
[32m+[m[32m    {[m
[32m+[m[32m        private DiagnosticResultLocation[] locations;[m
[32m+[m
[32m+[m[32m        public DiagnosticResultLocation[] Locations[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                if (this.locations == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    this.locations = new DiagnosticResultLocation[] { };[m
[32m+[m[32m                }[m
[32m+[m[32m                return this.locations;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            set[m
[32m+[m[32m            {[m
[32m+[m[32m                this.locations = value;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public DiagnosticSeverity Severity { get; set; }[m
[32m+[m
[32m+[m[32m        public string Id { get; set; }[m
[32m+[m
[32m+[m[32m        public string Message { get; set; }[m
[32m+[m
[32m+[m[32m        public string Path[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return this.Locations.Length > 0 ? this.Locations[0].Path : "";[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public int Line[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return this.Locations.Length > 0 ? this.Locations[0].Line : -1;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public int Column[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return this.Locations.Length > 0 ? this.Locations[0].Column : -1;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/DiagnosticVerifier.Helper.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/DiagnosticVerifier.Helper.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..12b93c2[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/Helpers/DiagnosticVerifier.Helper.cs[m
[36m@@ -0,0 +1,179 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Text;[m
[32m+[m[32musing System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Collections.Immutable;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m
[32m+[m[32mnamespace TestHelper[m
[32m+[m[32m{[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Class for turning strings into documents and getting the diagnostics on them[m
[32m+[m[32m    /// All methods are static[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public abstract partial class DiagnosticVerifier[m
[32m+[m[32m    {[m
[32m+[m[32m        private static readonly MetadataReference CorlibReference = MetadataReference.CreateFromAssembly(typeof(object).Assembly);[m
[32m+[m[32m        private static readonly MetadataReference SystemCoreReference = MetadataReference.CreateFromAssembly(typeof(Enumerable).Assembly);[m
[32m+[m[32m        private static readonly MetadataReference CSharpSymbolsReference = MetadataReference.CreateFromAssembly(typeof(CSharpCompilation).Assembly);[m
[32m+[m[32m        private static readonly MetadataReference CodeAnalysisReference = MetadataReference.CreateFromAssembly(typeof(Compilation).Assembly);[m
[32m+[m
[32m+[m[32m        internal static string DefaultFilePathPrefix = "Test";[m
[32m+[m[32m        internal static string CSharpDefaultFileExt = "cs";[m
[32m+[m[32m        internal static string VisualBasicDefaultExt = "vb";[m
[32m+[m[32m        internal static string CSharpDefaultFilePath = DefaultFilePathPrefix + 0 + "." + CSharpDefaultFileExt;[m
[32m+[m[32m        internal static string VisualBasicDefaultFilePath = DefaultFilePathPrefix + 0 + "." + VisualBasicDefaultExt;[m
[32m+[m[32m        internal static string TestProjectName = "TestProject";[m
[32m+[m
[32m+[m[32m        #region  Get Diagnostics[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Given classes in the form of strings, their language, and an IDiagnosticAnlayzer to apply to it, return the diagnostics found in the string after converting it to a document.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">Classes in the form of strings</param>[m
[32m+[m[32m        /// <param name="language">The language the source classes are in</param>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer to be run on the sources</param>[m
[32m+[m[32m        /// <returns>An IEnumerable of Diagnostics that surfaced in the source code, sorted by Location</returns>[m
[32m+[m[32m        private static Diagnostic[] GetSortedDiagnostics(string[] sources, string language, DiagnosticAnalyzer analyzer)[m
[32m+[m[32m        {[m
[32m+[m[32m            return GetSortedDiagnosticsFromDocuments(analyzer, GetDocuments(sources, language));[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Given an analyzer and a document to apply it to, run the analyzer and gather an array of diagnostics found in it.[m
[32m+[m[32m        /// The returned diagnostics are then ordered by location in the source document.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer to run on the documents</param>[m
[32m+[m[32m        /// <param name="documents">The Documents that the analyzer will be run on</param>[m
[32m+[m[32m        /// <param name="spans">Optional TextSpan indicating where a Diagnostic will be found</param>[m
[32m+[m[32m        /// <returns>An IEnumerable of Diagnostics that surfaced in the source code, sorted by Location</returns>[m
[32m+[m[32m        protected static Diagnostic[] GetSortedDiagnosticsFromDocuments(DiagnosticAnalyzer analyzer, Document[] documents)[m
[32m+[m[32m        {[m
[32m+[m[32m            var projects = new HashSet<Project>();[m
[32m+[m[32m            foreach (var document in documents)[m
[32m+[m[32m            {[m
[32m+[m[32m                projects.Add(document.Project);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            var diagnostics = new List<Diagnostic>();[m
[32m+[m[32m            foreach (var project in projects)[m
[32m+[m[32m            {[m
[32m+[m[32m                var compilationWithAnalyzers = project.GetCompilationAsync().Result.WithAnalyzers(ImmutableArray.Create(analyzer));[m
[32m+[m[32m                var diags = compilationWithAnalyzers.GetAnalyzerDiagnosticsAsync().Result;[m
[32m+[m[32m                foreach (var diag in diags)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (diag.Location == Location.None || diag.Location.IsInMetadata)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        diagnostics.Add(diag);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else[m
[32m+[m[32m                    {[m
[32m+[m[32m                        for (int i = 0; i < documents.Length; i++)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            var document = documents[i];[m
[32m+[m[32m                            var tree = document.GetSyntaxTreeAsync().Result;[m
[32m+[m[32m                            if (tree == diag.Location.SourceTree)[m
[32m+[m[32m                            {[m
[32m+[m[32m                                diagnostics.Add(diag);[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            var results = SortDiagnostics(diagnostics);[m
[32m+[m[32m            diagnostics.Clear();[m
[32m+[m[32m            return results;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Sort diagnostics by location in source document[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="diagnostics">The list of Diagnostics to be sorted</param>[m
[32m+[m[32m        /// <returns>An IEnumerable containing the Diagnostics in order of Location</returns>[m
[32m+[m[32m        private static Diagnostic[] SortDiagnostics(IEnumerable<Diagnostic> diagnostics)[m
[32m+[m[32m        {[m
[32m+[m[32m            return diagnostics.OrderBy(d => d.Location.SourceSpan.Start).ToArray();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        #endregion[m
[32m+[m
[32m+[m[32m        #region Set up compilation and documents[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Given an array of strings as sources and a language, turn them into a project and return the documents and spans of it.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">Classes in the form of strings</param>[m
[32m+[m[32m        /// <param name="language">The language the source code is in</param>[m
[32m+[m[32m        /// <returns>A Tuple containing the Documents produced from the sources and their TextSpans if relevant</returns>[m
[32m+[m[32m        private static Document[] GetDocuments(string[] sources, string language)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (language != LanguageNames.CSharp && language != LanguageNames.VisualBasic)[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new ArgumentException("Unsupported Language");[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            for (int i = 0; i < sources.Length; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                string fileName = language == LanguageNames.CSharp ? "Test" + i + ".cs" : "Test" + i + ".vb";[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            var project = CreateProject(sources, language);[m
[32m+[m[32m            var documents = project.Documents.ToArray();[m
[32m+[m
[32m+[m[32m            if (sources.Length != documents.Length)[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new SystemException("Amount of sources did not match amount of Documents created");[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            return documents;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Create a Document from a string through creating a project that contains it.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="source">Classes in the form of a string</param>[m
[32m+[m[32m        /// <param name="language">The language the source code is in</param>[m
[32m+[m[32m        /// <returns>A Document created from the source string</returns>[m
[32m+[m[32m        protected static Document CreateDocument(string source, string language = LanguageNames.CSharp)[m
[32m+[m[32m        {[m
[32m+[m[32m            return CreateProject(new[] { source }, language).Documents.First();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Create a project using the inputted strings as sources.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">Classes in the form of strings</param>[m
[32m+[m[32m        /// <param name="language">The language the source code is in</param>[m
[32m+[m[32m        /// <returns>A Project created out of the Documents created from the source strings</returns>[m
[32m+[m[32m        private static Project CreateProject(string[] sources, string language = LanguageNames.CSharp)[m
[32m+[m[32m        {[m
[32m+[m[32m            string fileNamePrefix = DefaultFilePathPrefix;[m
[32m+[m[32m            string fileExt = language == LanguageNames.CSharp ? CSharpDefaultFileExt : VisualBasicDefaultExt;[m
[32m+[m
[32m+[m[32m            var projectId = ProjectId.CreateNewId(debugName: TestProjectName);[m
[32m+[m
[32m+[m[32m            var solution = new AdhocWorkspace()[m
[32m+[m[32m                .CurrentSolution[m
[32m+[m[32m                .AddProject(projectId, TestProjectName, TestProjectName, language)[m
[32m+[m[32m                .AddMetadataReference(projectId, CorlibReference)[m
[32m+[m[32m                .AddMetadataReference(projectId, SystemCoreReference)[m
[32m+[m[32m                .AddMetadataReference(projectId, CSharpSymbolsReference)[m
[32m+[m[32m                .AddMetadataReference(projectId, CodeAnalysisReference);[m
[32m+[m
[32m+[m[32m            int count = 0;[m
[32m+[m[32m            foreach (var source in sources)[m
[32m+[m[32m            {[m
[32m+[m[32m                var newFileName = fileNamePrefix + count + "." + fileExt;[m
[32m+[m[32m                var documentId = DocumentId.CreateNewId(projectId, debugName: newFileName);[m
[32m+[m[32m                solution = solution.AddDocument(documentId, newFileName, SourceText.From(source));[m
[32m+[m[32m                count++;[m
[32m+[m[32m            }[m
[32m+[m[32m            return solution.GetProject(projectId);[m
[32m+[m[32m        }[m
[32m+[m[32m        #endregion[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/MetaCompilation.Test.csproj b/MetaCompilation/MetaCompilation/MetaCompilation.Test/MetaCompilation.Test.csproj[m
[1mnew file mode 100644[m
[1mindex 0000000..b0ddcc9[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/MetaCompilation.Test.csproj[m
[36m@@ -0,0 +1,132 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>[m
[32m+[m[32m    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>[m
[32m+[m[32m    <ProductVersion>8.0.30703</ProductVersion>[m
[32m+[m[32m    <SchemaVersion>2.0</SchemaVersion>[m
[32m+[m[32m    <ProjectGuid>{45D60761-2694-4084-9B23-B8D1660B6712}</ProjectGuid>[m
[32m+[m[32m    <OutputType>Library</OutputType>[m
[32m+[m[32m    <AppDesignerFolder>Properties</AppDesignerFolder>[m
[32m+[m[32m    <RootNamespace>MetaCompilation.Test</RootNamespace>[m
[32m+[m[32m    <AssemblyName>MetaCompilation.Test</AssemblyName>[m
[32m+[m[32m    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>[m
[32m+[m[32m    <FileAlignment>512</FileAlignment>[m
[32m+[m[32m    <TargetFrameworkProfile />[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">[m
[32m+[m[32m    <DebugSymbols>true</DebugSymbols>[m
[32m+[m[32m    <DebugType>full</DebugType>[m
[32m+[m[32m    <Optimize>false</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Debug\</OutputPath>[m
[32m+[m[32m    <DefineConstants>DEBUG;TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m    <Prefer32Bit>false</Prefer32Bit>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">[m
[32m+[m[32m    <DebugType>pdbonly</DebugType>[m
[32m+[m[32m    <Optimize>true</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Release\</OutputPath>[m
[32m+[m[32m    <DefineConstants>TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m    <Prefer32Bit>false</Prefer32Bit>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.Desktop.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.Workspaces.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.Workspaces.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp.Workspaces.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.Workspaces.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.Workspaces.Desktop.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.Desktop.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Workspaces.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.Workspaces.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.Workspaces.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Workspaces.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.Workspaces.Desktop.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System" />[m
[32m+[m[32m    <Reference Include="System.Collections.Immutable, Version=1.1.33.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\System.Collections.Immutable.1.1.33-beta\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.AttributedModel, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.AttributedModel.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Convention, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Convention.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Hosting, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Hosting.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Runtime, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Runtime.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.TypedParts, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.TypedParts.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Core" />[m
[32m+[m[32m    <Reference Include="System.Reflection.Metadata, Version=1.0.18.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\System.Reflection.Metadata.1.0.18-beta\lib\portable-net45+win8\System.Reflection.Metadata.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Xml.Linq" />[m
[32m+[m[32m    <Reference Include="System.Data.DataSetExtensions" />[m
[32m+[m[32m    <Reference Include="Microsoft.CSharp" />[m
[32m+[m[32m    <Reference Include="System.Data" />[m
[32m+[m[32m    <Reference Include="System.Xml" />[m
[32m+[m[32m    <Reference Include="Microsoft.VisualStudio.QualityTools.UnitTestFramework" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Compile Include="Verifiers\CodeFixVerifier.cs" />[m
[32m+[m[32m    <Compile Include="Verifiers\DiagnosticVerifier.cs" />[m
[32m+[m[32m    <Compile Include="Helpers\CodeFixVerifier.Helper.cs" />[m
[32m+[m[32m    <Compile Include="Helpers\DiagnosticResult.cs" />[m
[32m+[m[32m    <Compile Include="Helpers\DiagnosticVerifier.Helper.cs" />[m
[32m+[m[32m    <Compile Include="UnitTests.cs" />[m
[32m+[m[32m    <Compile Include="Properties\AssemblyInfo.cs" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <None Include="packages.config" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <ProjectReference Include="..\MetaCompilation\MetaCompilation.csproj">[m
[32m+[m[32m      <Project>{6CD505A6-60D7-4C35-AE53-694AFDEB3A64}</Project>[m
[32m+[m[32m      <Name>MetaCompilation</Name>[m
[32m+[m[32m    </ProjectReference>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />[m
[32m+[m[32m  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.[m[41m [m
[32m+[m[32m       Other similar extension points exist, see Microsoft.Common.targets.[m
[32m+[m[32m  <Target Name="BeforeBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  <Target Name="AfterBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  -->[m
[32m+[m[32m</Project>[m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/Properties/AssemblyInfo.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/Properties/AssemblyInfo.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..289513d[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/Properties/AssemblyInfo.cs[m
[36m@@ -0,0 +1,32 @@[m
[32m+[m[32m﻿using System.Reflection;[m
[32m+[m[32musing System.Runtime.InteropServices;[m
[32m+[m
[32m+[m[32m// General Information about an assembly is controlled through the following[m[41m [m
[32m+[m[32m// set of attributes. Change these attribute values to modify the information[m
[32m+[m[32m// associated with an assembly.[m
[32m+[m[32m[assembly: AssemblyTitle("MetaCompilation.Test")][m
[32m+[m[32m[assembly: AssemblyDescription("")][m
[32m+[m[32m[assembly: AssemblyConfiguration("")][m
[32m+[m[32m[assembly: AssemblyCompany("")][m
[32m+[m[32m[assembly: AssemblyProduct("MetaCompilation.Test")][m
[32m+[m[32m[assembly: AssemblyCopyright("Copyright ©  2015")][m
[32m+[m[32m[assembly: AssemblyTrademark("")][m
[32m+[m[32m[assembly: AssemblyCulture("")][m
[32m+[m
[32m+[m[32m// Setting ComVisible to false makes the types in this assembly not visible[m[41m [m
[32m+[m[32m// to COM components.  If you need to access a type in this assembly from[m[41m [m
[32m+[m[32m// COM, set the ComVisible attribute to true on that type.[m
[32m+[m[32m[assembly: ComVisible(false)][m
[32m+[m
[32m+[m[32m// Version information for an assembly consists of the following four values:[m
[32m+[m[32m//[m
[32m+[m[32m//      Major Version[m
[32m+[m[32m//      Minor Version[m[41m [m
[32m+[m[32m//      Build Number[m
[32m+[m[32m//      Revision[m
[32m+[m[32m//[m
[32m+[m[32m// You can specify all the values or you can default the Build and Revision Numbers[m[41m [m
[32m+[m[32m// by using the '*' as shown below:[m
[32m+[m[32m// [assembly: AssemblyVersion("1.0.*")][m
[32m+[m[32m[assembly: AssemblyVersion("1.0.0.0")][m
[32m+[m[32m[assembly: AssemblyFileVersion("1.0.0.0")][m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..bdd4ce8[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/UnitTests.cs[m
[36m@@ -0,0 +1,16 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeFixes;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.VisualStudio.TestTools.UnitTesting;[m
[32m+[m[32musing System;[m
[32m+[m[32musing TestHelper;[m
[32m+[m[32musing MetaCompilation;[m
[32m+[m
[32m+[m[32mnamespace MetaCompilation.Test[m
[32m+[m[32m{[m
[32m+[m[32m    [TestClass][m
[32m+[m[32m    public class UnitTest : CodeFixVerifier[m
[32m+[m[32m    {[m
[32m+[m
[32m+[m[32m    }[m[41m        [m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/Verifiers/CodeFixVerifier.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/Verifiers/CodeFixVerifier.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..61549fc[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/Verifiers/CodeFixVerifier.cs[m
[36m@@ -0,0 +1,128 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeActions;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeFixes;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Formatting;[m
[32m+[m[32musing Microsoft.VisualStudio.TestTools.UnitTesting;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m
[32m+[m[32mnamespace TestHelper[m
[32m+[m[32m{[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Superclass of all Unit tests made for diagnostics with codefixes.[m
[32m+[m[32m    /// Contains methods used to verify correctness of codefixes[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public abstract partial class CodeFixVerifier : DiagnosticVerifier[m
[32m+[m[32m    {[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Returns the codefix being tested (C#) - to be implemented in non-abstract class[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <returns>The CodeFixProvider to be used for CSharp code</returns>[m
[32m+[m[32m        protected virtual CodeFixProvider GetCSharpCodeFixProvider()[m
[32m+[m[32m        {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Returns the codefix being tested (VB) - to be implemented in non-abstract class[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <returns>The CodeFixProvider to be used for VisualBasic code</returns>[m
[32m+[m[32m        protected virtual CodeFixProvider GetBasicCodeFixProvider()[m
[32m+[m[32m        {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a C# codefix when applied on the inputted string as a source[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="oldSource">A class in the form of a string before the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="newSource">A class in the form of a string after the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="codeFixIndex">Index determining which codefix to apply if there are multiple</param>[m
[32m+[m[32m        /// <param name="allowNewCompilerDiagnostics">A bool controlling whether or not the test will fail if the CodeFix introduces other warnings after being applied</param>[m
[32m+[m[32m        protected void VerifyCSharpFix(string oldSource, string newSource, int? codeFixIndex = null, bool allowNewCompilerDiagnostics = false)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyFix(LanguageNames.CSharp, GetCSharpDiagnosticAnalyzer(), GetCSharpCodeFixProvider(), oldSource, newSource, codeFixIndex, allowNewCompilerDiagnostics);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a VB codefix when applied on the inputted string as a source[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="oldSource">A class in the form of a string before the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="newSource">A class in the form of a string after the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="codeFixIndex">Index determining which codefix to apply if there are multiple</param>[m
[32m+[m[32m        /// <param name="allowNewCompilerDiagnostics">A bool controlling whether or not the test will fail if the CodeFix introduces other warnings after being applied</param>[m
[32m+[m[32m        protected void VerifyBasicFix(string oldSource, string newSource, int? codeFixIndex = null, bool allowNewCompilerDiagnostics = false)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyFix(LanguageNames.VisualBasic, GetBasicDiagnosticAnalyzer(), GetBasicCodeFixProvider(), oldSource, newSource, codeFixIndex, allowNewCompilerDiagnostics);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// General verifier for codefixes.[m
[32m+[m[32m        /// Creates a Document from the source string, then gets diagnostics on it and applies the relevant codefixes.[m
[32m+[m[32m        /// Then gets the string after the codefix is applied and compares it with the expected result.[m
[32m+[m[32m        /// Note: If any codefix causes new diagnostics to show up, the test fails unless allowNewCompilerDiagnostics is set to true.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="language">The language the source code is in</param>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer to be applied to the source code</param>[m
[32m+[m[32m        /// <param name="codeFixProvider">The codefix to be applied to the code wherever the relevant Diagnostic is found</param>[m
[32m+[m[32m        /// <param name="oldSource">A class in the form of a string before the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="newSource">A class in the form of a string after the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="codeFixIndex">Index determining which codefix to apply if there are multiple</param>[m
[32m+[m[32m        /// <param name="allowNewCompilerDiagnostics">A bool controlling whether or not the test will fail if the CodeFix introduces other warnings after being applied</param>[m
[32m+[m[32m        private void VerifyFix(string language, DiagnosticAnalyzer analyzer, CodeFixProvider codeFixProvider, string oldSource, string newSource, int? codeFixIndex, bool allowNewCompilerDiagnostics)[m
[32m+[m[32m        {[m
[32m+[m[32m            var document = CreateDocument(oldSource, language);[m
[32m+[m[32m            var analyzerDiagnostics = GetSortedDiagnosticsFromDocuments(analyzer, new[] { document });[m
[32m+[m[32m            var compilerDiagnostics = GetCompilerDiagnostics(document);[m
[32m+[m[32m            var attempts = analyzerDiagnostics.Length;[m
[32m+[m
[32m+[m[32m            for (int i = 0; i < attempts; ++i)[m
[32m+[m[32m            {[m
[32m+[m[32m                var actions = new List<CodeAction>();[m
[32m+[m[32m                var context = new CodeFixContext(document, analyzerDiagnostics[0], (a, d) => actions.Add(a), CancellationToken.None);[m
[32m+[m[32m                codeFixProvider.RegisterCodeFixesAsync(context).Wait();[m
[32m+[m
[32m+[m[32m                if (!actions.Any())[m
[32m+[m[32m                {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (codeFixIndex != null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    document = ApplyFix(document, actions.ElementAt((int)codeFixIndex));[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                document = ApplyFix(document, actions.ElementAt(0));[m
[32m+[m[32m                analyzerDiagnostics = GetSortedDiagnosticsFromDocuments(analyzer, new[] { document });[m
[32m+[m
[32m+[m[32m                var newCompilerDiagnostics = GetNewDiagnostics(compilerDiagnostics, GetCompilerDiagnostics(document));[m
[32m+[m
[32m+[m[32m                //check if applying the code fix introduced any new compiler diagnostics[m
[32m+[m[32m                if (!allowNewCompilerDiagnostics && newCompilerDiagnostics.Any())[m
[32m+[m[32m                {[m
[32m+[m[32m                    // Format and get the compiler diagnostics again so that the locations make sense in the output[m
[32m+[m[32m                    document = document.WithSyntaxRoot(Formatter.Format(document.GetSyntaxRootAsync().Result, Formatter.Annotation, document.Project.Solution.Workspace));[m
[32m+[m[32m                    newCompilerDiagnostics = GetNewDiagnostics(compilerDiagnostics, GetCompilerDiagnostics(document));[m
[32m+[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Fix introduced new compiler diagnostics:\r\n{0}\r\n\r\nNew document:\r\n{1}\r\n",[m
[32m+[m[32m                            string.Join("\r\n", newCompilerDiagnostics.Select(d => d.ToString())),[m
[32m+[m[32m                            document.GetSyntaxRootAsync().Result.ToFullString()));[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                //check if there are analyzer diagnostics left after the code fix[m
[32m+[m[32m                if (!analyzerDiagnostics.Any())[m
[32m+[m[32m                {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            //after applying all of the code fixes, compare the resulting string to the inputted one[m
[32m+[m[32m            var actual = GetStringFromDocument(document);[m
[32m+[m[32m            Assert.AreEqual(newSource, actual);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/Verifiers/DiagnosticVerifier.cs b/MetaCompilation/MetaCompilation/MetaCompilation.Test/Verifiers/DiagnosticVerifier.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..a0124e5[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/Verifiers/DiagnosticVerifier.cs[m
[36m@@ -0,0 +1,270 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.VisualStudio.TestTools.UnitTesting;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Text;[m
[32m+[m
[32m+[m[32mnamespace TestHelper[m
[32m+[m[32m{[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Superclass of all Unit Tests for DiagnosticAnalyzers[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public abstract partial class DiagnosticVerifier[m
[32m+[m[32m    {[m
[32m+[m[32m        #region To be implemented by Test classes[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Get the CSharp analyzer being tested - to be implemented in non-abstract class[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        protected virtual DiagnosticAnalyzer GetCSharpDiagnosticAnalyzer()[m
[32m+[m[32m        {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Get the Visual Basic analyzer being tested (C#) - to be implemented in non-abstract class[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        protected virtual DiagnosticAnalyzer GetBasicDiagnosticAnalyzer()[m
[32m+[m[32m        {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        #endregion[m
[32m+[m
[32m+[m[32m        #region Verifier wrappers[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a C# DiagnosticAnalyzer when applied on the single inputted string as a source[m
[32m+[m[32m        /// Note: input a DiagnosticResult for each Diagnostic expected[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="source">A class in the form of a string to run the analyzer on</param>[m
[32m+[m[32m        /// <param name="expected"> DiagnosticResults that should appear after the analyzer is run on the source</param>[m
[32m+[m[32m        protected void VerifyCSharpDiagnostic(string source, params DiagnosticResult[] expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyDiagnostics(new[] { source }, LanguageNames.CSharp, GetCSharpDiagnosticAnalyzer(), expected);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a VB DiagnosticAnalyzer when applied on the single inputted string as a source[m
[32m+[m[32m        /// Note: input a DiagnosticResult for each Diagnostic expected[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="source">A class in the form of a string to run the analyzer on</param>[m
[32m+[m[32m        /// <param name="expected">DiagnosticResults that should appear after the analyzer is run on the source</param>[m
[32m+[m[32m        protected void VerifyBasicDiagnostic(string source, params DiagnosticResult[] expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyDiagnostics(new[] { source }, LanguageNames.VisualBasic, GetBasicDiagnosticAnalyzer(), expected);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a C# DiagnosticAnalyzer when applied on the inputted strings as a source[m
[32m+[m[32m        /// Note: input a DiagnosticResult for each Diagnostic expected[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">An array of strings to create source documents from to run the analyzers on</param>[m
[32m+[m[32m        /// <param name="expected">DiagnosticResults that should appear after the analyzer is run on the sources</param>[m
[32m+[m[32m        protected void VerifyCSharpDiagnostic(string[] sources, params DiagnosticResult[] expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyDiagnostics(sources, LanguageNames.CSharp, GetCSharpDiagnosticAnalyzer(), expected);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a VB DiagnosticAnalyzer when applied on the inputted strings as a source[m
[32m+[m[32m        /// Note: input a DiagnosticResult for each Diagnostic expected[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">An array of strings to create source documents from to run the analyzers on</param>[m
[32m+[m[32m        /// <param name="expected">DiagnosticResults that should appear after the analyzer is run on the sources</param>[m
[32m+[m[32m        protected void VerifyBasicDiagnostic(string[] sources, params DiagnosticResult[] expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyDiagnostics(sources, LanguageNames.VisualBasic, GetBasicDiagnosticAnalyzer(), expected);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// General method that gets a collection of actual diagnostics found in the source after the analyzer is run,[m[41m [m
[32m+[m[32m        /// then verifies each of them.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">An array of strings to create source documents from to run the analyzers on</param>[m
[32m+[m[32m        /// <param name="language">The language of the classes represented by the source strings</param>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer to be run on the source code</param>[m
[32m+[m[32m        /// <param name="expected">DiagnosticResults that should appear after the analyzer is run on the sources</param>[m
[32m+[m[32m        private void VerifyDiagnostics(string[] sources, string language, DiagnosticAnalyzer analyzer, params DiagnosticResult[] expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            var diagnostics = GetSortedDiagnostics(sources, language, analyzer);[m
[32m+[m[32m            VerifyDiagnosticResults(diagnostics, analyzer, expected);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        #endregion[m
[32m+[m
[32m+[m[32m        #region Actual comparisons and verifications[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Checks each of the actual Diagnostics found and compares them with the corresponding DiagnosticResult in the array of expected results.[m
[32m+[m[32m        /// Diagnostics are considered equal only if the DiagnosticResultLocation, Id, Severity, and Message of the DiagnosticResult match the actual diagnostic.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="actualResults">The Diagnostics found by the compiler after running the analyzer on the source code</param>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer that was being run on the sources</param>[m
[32m+[m[32m        /// <param name="expectedResults">Diagnostic Results that should have appeared in the code</param>[m
[32m+[m[32m        private static void VerifyDiagnosticResults(IEnumerable<Diagnostic> actualResults, DiagnosticAnalyzer analyzer, params DiagnosticResult[] expectedResults)[m
[32m+[m[32m        {[m
[32m+[m[32m            int expectedCount = expectedResults.Count();[m
[32m+[m[32m            int actualCount = actualResults.Count();[m
[32m+[m
[32m+[m[32m            if (expectedCount != actualCount)[m
[32m+[m[32m            {[m
[32m+[m[32m                string diagnosticsOutput = actualResults.Any() ? FormatDiagnostics(analyzer, actualResults.ToArray()) : "    NONE.";[m
[32m+[m
[32m+[m[32m                Assert.IsTrue(false,[m
[32m+[m[32m                    string.Format("Mismatch between number of diagnostics returned, expected \"{0}\" actual \"{1}\"\r\n\r\nDiagnostics:\r\n{2}\r\n", expectedCount, actualCount, diagnosticsOutput));[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            for (int i = 0; i < expectedResults.Length; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                var actual = actualResults.ElementAt(i);[m
[32m+[m[32m                var expected = expectedResults[i];[m
[32m+[m
[32m+[m[32m                if (expected.Line == -1 && expected.Column == -1)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (actual.Location != Location.None)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        Assert.IsTrue(false,[m
[32m+[m[32m                            string.Format("Expected:\nA project diagnostic with No location\nActual:\n{0}",[m
[32m+[m[32m                            FormatDiagnostics(analyzer, actual)));[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    VerifyDiagnosticLocation(analyzer, actual, actual.Location, expected.Locations.First());[m
[32m+[m[32m                    var additionalLocations = actual.AdditionalLocations.ToArray();[m
[32m+[m
[32m+[m[32m                    if (additionalLocations.Length != expected.Locations.Length - 1)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        Assert.IsTrue(false,[m
[32m+[m[32m                            string.Format("Expected {0} additional locations but got {1} for Diagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                                expected.Locations.Length - 1, additionalLocations.Length,[m
[32m+[m[32m                                FormatDiagnostics(analyzer, actual)));[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    for (int j = 0; j < additionalLocations.Length; ++j)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        VerifyDiagnosticLocation(analyzer, actual, additionalLocations[j], expected.Locations[j + 1]);[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (actual.Id != expected.Id)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Expected diagnostic id to be \"{0}\" was \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                            expected.Id, actual.Id, FormatDiagnostics(analyzer, actual)));[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (actual.Severity != expected.Severity)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Expected diagnostic severity to be \"{0}\" was \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                            expected.Severity, actual.Severity, FormatDiagnostics(analyzer, actual)));[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (actual.GetMessage() != expected.Message)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Expected diagnostic message to be \"{0}\" was \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                            expected.Message, actual.GetMessage(), FormatDiagnostics(analyzer, actual)));[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Helper method to VerifyDiagnosticResult that checks the location of a diagnostic and compares it with the location in the expected DiagnosticResult.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer that was being run on the sources</param>[m
[32m+[m[32m        /// <param name="diagnostic">The diagnostic that was found in the code</param>[m
[32m+[m[32m        /// <param name="actual">The Location of the Diagnostic found in the code</param>[m
[32m+[m[32m        /// <param name="expected">The DiagnosticResultLocation that should have been found</param>[m
[32m+[m[32m        private static void VerifyDiagnosticLocation(DiagnosticAnalyzer analyzer, Diagnostic diagnostic, Location actual, DiagnosticResultLocation expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            var actualSpan = actual.GetLineSpan();[m
[32m+[m
[32m+[m[32m            Assert.IsTrue(actualSpan.Path == expected.Path || (actualSpan.Path != null && actualSpan.Path.Contains("Test0.") && expected.Path.Contains("Test.")),[m
[32m+[m[32m                string.Format("Expected diagnostic to be in file \"{0}\" was actually in file \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                    expected.Path, actualSpan.Path, FormatDiagnostics(analyzer, diagnostic)));[m
[32m+[m
[32m+[m[32m            var actualLinePosition = actualSpan.StartLinePosition;[m
[32m+[m
[32m+[m[32m            // Only check line position if there is an actual line in the real diagnostic[m
[32m+[m[32m            if (actualLinePosition.Line > 0)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (actualLinePosition.Line + 1 != expected.Line)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Expected diagnostic to be on line \"{0}\" was actually on line \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                            expected.Line, actualLinePosition.Line + 1, FormatDiagnostics(analyzer, diagnostic)));[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Only check column position if there is an actual column position in the real diagnostic[m
[32m+[m[32m            if (actualLinePosition.Character > 0)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (actualLinePosition.Character + 1 != expected.Column)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Expected diagnostic to start at column \"{0}\" was actually at column \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                            expected.Column, actualLinePosition.Character + 1, FormatDiagnostics(analyzer, diagnostic)));[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        #endregion[m
[32m+[m
[32m+[m[32m        #region Formatting Diagnostics[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Helper method to format a Diagnostic into an easily readable string[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer that this verifier tests</param>[m
[32m+[m[32m        /// <param name="diagnostics">The Diagnostics to be formatted</param>[m
[32m+[m[32m        /// <returns>The Diagnostics formatted as a string</returns>[m
[32m+[m[32m        private static string FormatDiagnostics(DiagnosticAnalyzer analyzer, params Diagnostic[] diagnostics)[m
[32m+[m[32m        {[m
[32m+[m[32m            var builder = new StringBuilder();[m
[32m+[m[32m            for (int i = 0; i < diagnostics.Length; ++i)[m
[32m+[m[32m            {[m
[32m+[m[32m                builder.AppendLine("// " + diagnostics[i].ToString());[m
[32m+[m
[32m+[m[32m                var analyzerType = analyzer.GetType();[m
[32m+[m[32m                var rules = analyzer.SupportedDiagnostics;[m
[32m+[m
[32m+[m[32m                foreach (var rule in rules)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (rule != null && rule.Id == diagnostics[i].Id)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        var location = diagnostics[i].Location;[m
[32m+[m[32m                        if (location == Location.None)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            builder.AppendFormat("GetGlobalResult({0}.{1})", analyzerType.Name, rule.Id);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else[m
[32m+[m[32m                        {[m
[32m+[m[32m                            Assert.IsTrue(location.IsInSource,[m
[32m+[m[32m                                string.Format("Test base does not currently handle diagnostics in metadata locations. Diagnostic in metadata:\r\n", diagnostics[i]));[m
[32m+[m
[32m+[m[32m                            string resultMethodName = diagnostics[i].Location.SourceTree.FilePath.EndsWith(".cs") ? "GetCSharpResultAt" : "GetBasicResultAt";[m
[32m+[m[32m                            var linePosition = diagnostics[i].Location.GetLineSpan().StartLinePosition;[m
[32m+[m
[32m+[m[32m                            builder.AppendFormat("{0}({1}, {2}, {3}.{4})",[m
[32m+[m[32m                                resultMethodName,[m
[32m+[m[32m                                linePosition.Line + 1,[m
[32m+[m[32m                                linePosition.Character + 1,[m
[32m+[m[32m                                analyzerType.Name,[m
[32m+[m[32m                                rule.Id);[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        if (i != diagnostics.Length - 1)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            builder.Append(',');[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        builder.AppendLine();[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            return builder.ToString();[m
[32m+[m[32m        }[m
[32m+[m[32m        #endregion[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Test/packages.config b/MetaCompilation/MetaCompilation/MetaCompilation.Test/packages.config[m
[1mnew file mode 100644[m
[1mindex 0000000..fd6eb05[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Test/packages.config[m
[36m@@ -0,0 +1,10 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<packages>[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.Common" version="1.0.0-rc2" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.CSharp" version="1.0.0-rc2" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.CSharp.Workspaces" version="1.0.0-rc2" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.Workspaces.Common" version="1.0.0-rc2" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.Composition" version="1.0.27" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="System.Collections.Immutable" version="1.1.33-beta" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="System.Reflection.Metadata" version="1.0.18-beta" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m</packages>[m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Vsix/MetaCompilation.Vsix.csproj b/MetaCompilation/MetaCompilation/MetaCompilation.Vsix/MetaCompilation.Vsix.csproj[m
[1mnew file mode 100644[m
[1mindex 0000000..435bea2[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Vsix/MetaCompilation.Vsix.csproj[m
[36m@@ -0,0 +1,69 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>[m
[32m+[m[32m    <VSToolsPath Condition="'$(VSToolsPath)' == ''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>[m
[32m+[m[32m    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>[m
[32m+[m[32m    <SchemaVersion>2.0</SchemaVersion>[m
[32m+[m[32m    <ProjectTypeGuids>{82b43b9b-a64c-4715-b499-d71e9ca2bd60};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>[m
[32m+[m[32m    <ProjectGuid>{AEDFBCB1-8D38-4148-B9D5-E31FB6087E14}</ProjectGuid>[m
[32m+[m[32m    <OutputType>Library</OutputType>[m
[32m+[m[32m    <AppDesignerFolder>Properties</AppDesignerFolder>[m
[32m+[m[32m    <RootNamespace>MetaCompilation</RootNamespace>[m
[32m+[m[32m    <AssemblyName>MetaCompilation</AssemblyName>[m
[32m+[m[32m    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>[m
[32m+[m[32m    <GeneratePkgDefFile>false</GeneratePkgDefFile>[m
[32m+[m[32m    <IncludeAssemblyInVSIXContainer>false</IncludeAssemblyInVSIXContainer>[m
[32m+[m[32m    <IncludeDebugSymbolsInVSIXContainer>false</IncludeDebugSymbolsInVSIXContainer>[m
[32m+[m[32m    <IncludeDebugSymbolsInLocalVSIXDeployment>false</IncludeDebugSymbolsInLocalVSIXDeployment>[m
[32m+[m[32m    <CopyBuildOutputToOutputDirectory>false</CopyBuildOutputToOutputDirectory>[m
[32m+[m[32m    <CopyOutputSymbolsToOutputDirectory>false</CopyOutputSymbolsToOutputDirectory>[m
[32m+[m[32m    <VSSDKTargetPlatformRegRootSuffix>Roslyn</VSSDKTargetPlatformRegRootSuffix>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">[m
[32m+[m[32m    <DebugSymbols>true</DebugSymbols>[m
[32m+[m[32m    <DebugType>full</DebugType>[m
[32m+[m[32m    <Optimize>false</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Debug\</OutputPath>[m
[32m+[m[32m    <DefineConstants>DEBUG;TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">[m
[32m+[m[32m    <DebugType>pdbonly</DebugType>[m
[32m+[m[32m    <Optimize>true</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Release\</OutputPath>[m
[32m+[m[32m    <DefineConstants>TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <StartAction>Program</StartAction>[m
[32m+[m[32m    <StartProgram>$(DevEnvDir)devenv.exe</StartProgram>[m
[32m+[m[32m    <StartArguments>/rootsuffix Roslyn</StartArguments>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <None Include="source.extension.vsixmanifest">[m
[32m+[m[32m      <SubType>Designer</SubType>[m
[32m+[m[32m    </None>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <ProjectReference Include="..\MetaCompilation\MetaCompilation.csproj">[m
[32m+[m[32m      <Project>{6CD505A6-60D7-4C35-AE53-694AFDEB3A64}</Project>[m
[32m+[m[32m      <Name>MetaCompilation</Name>[m
[32m+[m[32m    </ProjectReference>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />[m
[32m+[m[32m  <Import Project="$(VSToolsPath)\VSSDK\Microsoft.VsSDK.targets" Condition="'$(VSToolsPath)' != ''" />[m
[32m+[m[32m  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.[m[41m [m
[32m+[m[32m       Other similar extension points exist, see Microsoft.Common.targets.[m
[32m+[m[32m  <Target Name="BeforeBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  <Target Name="AfterBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  -->[m
[32m+[m[32m</Project>[m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation.Vsix/source.extension.vsixmanifest b/MetaCompilation/MetaCompilation/MetaCompilation.Vsix/source.extension.vsixmanifest[m
[1mnew file mode 100644[m
[1mindex 0000000..7afadd0[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation.Vsix/source.extension.vsixmanifest[m
[36m@@ -0,0 +1,21 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<PackageManifest Version="2.0.0" xmlns="http://schemas.microsoft.com/developer/vsx-schema/2011" xmlns:d="http://schemas.microsoft.com/developer/vsx-schema-design/2011">[m
[32m+[m[32m  <Metadata>[m
[32m+[m[32m    <Identity Id="MetaCompilation.Vsix..5c6391a0-1c50-455e-af26-4625f610bc62" Version="1.0" Language="en-US" Publisher="Administrator"/>[m
[32m+[m[32m    <DisplayName>MetaCompilation.Vsix</DisplayName>[m
[32m+[m[32m    <Description xml:space="preserve">This is a sample diagnostic extension for the .NET Compiler Platform ("Roslyn").</Description>[m
[32m+[m[32m  </Metadata>[m
[32m+[m[32m  <Installation>[m
[32m+[m[32m    <InstallationTarget Version="[14.0,]" Id="Microsoft.VisualStudio.Pro" />[m
[32m+[m[32m    <InstallationTarget Version="[14.0,]" Id="Microsoft.VisualStudio.VSWinDesktopExpress" />[m
[32m+[m[32m    <InstallationTarget Version="[14.0,]" Id="Microsoft.VisualStudio.VWDExpress" />[m
[32m+[m[32m    <InstallationTarget Version="[14.0,]" Id="Microsoft.VisualStudio.VSWinExpress" />[m
[32m+[m[32m  </Installation>[m
[32m+[m[32m  <Dependencies>[m
[32m+[m[32m    <Dependency Id="Microsoft.Framework.NDP" DisplayName="Microsoft .NET Framework" d:Source="Manual" Version="[4.5,)" />[m
[32m+[m[32m  </Dependencies>[m
[32m+[m[32m  <Assets>[m
[32m+[m[32m    <Asset Type="Microsoft.VisualStudio.MefComponent" d:Source="Project" d:ProjectName="MetaCompilation" Path="|MetaCompilation|"/>[m
[32m+[m[32m    <Asset Type="Microsoft.VisualStudio.Analyzer" d:Source="Project" d:ProjectName="MetaCompilation" Path="|MetaCompilation|"/>[m
[32m+[m[32m  </Assets>[m
[32m+[m[32m</PackageManifest>[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..8f2a6c8[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/CodeFixProvider.cs[m
[36m@@ -0,0 +1,47 @@[m
[32m+[m[32m﻿using System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Collections.Immutable;[m
[32m+[m[32musing System.Composition;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m[32musing System.Threading.Tasks;[m
[32m+[m[32musing Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeFixes;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeActions;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Rename;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Text;[m
[32m+[m
[32m+[m[32mnamespace MetaCompilation[m
[32m+[m[32m{[m
[32m+[m[32m    [ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(MetaCompilationCodeFixProvider)), Shared][m
[32m+[m[32m    public class MetaCompilationCodeFixProvider : CodeFixProvider[m
[32m+[m[32m    {[m
[32m+[m[32m        public override ImmutableArray<string> FixableDiagnosticIds[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                //TODO: add any new rules[m
[32m+[m[32m                return ImmutableArray.Create(MetaCompilationAnalyzer.missingId);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public sealed override FixAllProvider GetFixAllProvider()[m
[32m+[m[32m        {[m
[32m+[m[32m            return WellKnownFixAllProviders.BatchFixer;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public sealed override async Task RegisterCodeFixesAsync(CodeFixContext context)[m
[32m+[m[32m        {[m
[32m+[m[32m            var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);[m
[32m+[m
[32m+[m[32m            foreach (var diagnostic in context.Diagnostics)[m
[32m+[m[32m            {[m
[32m+[m[32m                var diagnosticSpan = diagnostic.Location.SourceSpan;[m
[32m+[m
[32m+[m[32m                //TODO: if statements for each diagnostic id, to register a code fix[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/Diagnostic.nuspec b/MetaCompilation/MetaCompilation/MetaCompilation/Diagnostic.nuspec[m
[1mnew file mode 100644[m
[1mindex 0000000..e7be924[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/Diagnostic.nuspec[m
[36m@@ -0,0 +1,25 @@[m
[32m+[m[32m﻿<?xml version="1.0"?>[m
[32m+[m[32m<package xmlns="http://schemas.microsoft.com/packaging/2011/08/nuspec.xsd">[m
[32m+[m[32m  <metadata>[m
[32m+[m[32m    <id>MetaCompilation</id>[m
[32m+[m[32m    <version>1.0.0.0</version>[m
[32m+[m[32m    <title>MetaCompilation</title>[m
[32m+[m[32m    <authors>MetaCompilation</authors>[m
[32m+[m[32m    <owners>MetaCompilation</owners>[m
[32m+[m[32m    <licenseUrl>http://LICENSE_URL_HERE_OR_DELETE_THIS_LINE</licenseUrl>[m
[32m+[m[32m    <projectUrl>http://PROJECT_URL_HERE_OR_DELETE_THIS_LINE</projectUrl>[m
[32m+[m[32m    <iconUrl>http://ICON_URL_HERE_OR_DELETE_THIS_LINE</iconUrl>[m
[32m+[m[32m    <requireLicenseAcceptance>false</requireLicenseAcceptance>[m
[32m+[m[32m    <description>MetaCompilation</description>[m
[32m+[m[32m    <releaseNotes>Summary of changes made in this release of the package.</releaseNotes>[m
[32m+[m[32m    <copyright>Copyright</copyright>[m
[32m+[m[32m    <tags>MetaCompilation, analyzers</tags>[m
[32m+[m[32m    <frameworkAssemblies>[m
[32m+[m[32m      <frameworkAssembly assemblyName="System" targetFramework="" />[m
[32m+[m[32m    </frameworkAssemblies>[m
[32m+[m[32m  </metadata>[m
[32m+[m[32m  <files>[m
[32m+[m[32m    <file src="*.dll" target="tools\analyzers\" exclude="**\Microsoft.CodeAnalysis.*;**\System.Collections.Immutable.*;**\System.Reflection.Metadata.*" />[m
[32m+[m[32m    <file src="tools\*.ps1" target="tools\" />[m
[32m+[m[32m  </files>[m
[32m+[m[32m</package>[m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..b454fee[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/DiagnosticAnalyzer.cs[m
[36m@@ -0,0 +1,531 @@[m
[32m+[m[32musing System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Collections.Immutable;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m[32musing Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Text;[m
[32m+[m
[32m+[m[32mnamespace MetaCompilation[m
[32m+[m[32m{[m
[32m+[m[32m    [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[32m+[m[32m    public class MetaCompilationAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m    {[m
[32m+[m
[32m+[m[32m        #region id rules[m
[32m+[m[32m        public const string missingId = "missingId";[m
[32m+[m[32m        internal static DiagnosticDescriptor missingIdRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: missingId,[m
[32m+[m[32m            title: "You are missing a diagnostic id",[m
[32m+[m[32m            messageFormat: "You are missing a diagnostic id",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m[32m        #endregion[m
[32m+[m
[32m+[m[32m        #region initialize rules[m
[32m+[m[32m        public const string missingInit = "missingInit";[m
[32m+[m[32m        internal static DiagnosticDescriptor missingInitRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: missingInit,[m
[32m+[m[32m            title: "You are missing the required Initialize method",[m
[32m+[m[32m            messageFormat: "You are missing the required Initialize method",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public const string missingRegisterStatement = "missingRegister";[m
[32m+[m[32m        internal static DiagnosticDescriptor missingRegisterRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: missingRegisterStatement,[m
[32m+[m[32m            title: "You need to register an action within the Initialize method",[m
[32m+[m[32m            messageFormat: "You need to register an action within the Initialize method",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public const string tooManyInitStatements = "incorrectInit001";[m
[32m+[m[32m        internal static DiagnosticDescriptor tooManyInitStatementsRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: tooManyInitStatements,[m
[32m+[m[32m            title: "Please only have one statement within Initiailize. You will only be registering one action.",[m
[32m+[m[32m            messageFormat: "Please only have one statement within Initiailize. You will only be registering one action.",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public const string incorrectInitStatement = "incorrectInit002";[m
[32m+[m[32m        internal static DiagnosticDescriptor incorrectInitStatementRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: incorrectInitStatement,[m
[32m+[m[32m            title: "This statement needs to register for a supported action",[m
[32m+[m[32m            messageFormat: "This statement needs to register for a supported action",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public const string incorrectInitSig = "initSignature";[m
[32m+[m[32m        internal static DiagnosticDescriptor incorrectInitSigRule = new DiagnosticDescriptor([m
[32m+[m[32m            id: incorrectInitSig,[m
[32m+[m[32m            title: "The signature for the Initialize method is incorrect",[m
[32m+[m[32m            messageFormat: "The signature for the Initialize method is incorrect",[m
[32m+[m[32m            category: "Syntax",[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Error,[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m[32m        #endregion[m
[32m+[m
[32m+[m[32m        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return ImmutableArray.Create(missingIdRule, missingInitRule, missingRegisterRule, tooManyInitStatementsRule, incorrectInitStatementRule, incorrectInitSigRule);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public override void Initialize(AnalysisContext context)[m
[32m+[m[32m        {[m
[32m+[m[32m            context.RegisterCompilationStartAction(SetupAnalysis);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        private void SetupAnalysis(CompilationStartAnalysisContext context)[m
[32m+[m[32m        {[m
[32m+[m[32m            CompilationAnalyzer compilationAnalyzer = new CompilationAnalyzer();[m
[32m+[m
[32m+[m[32m            context.RegisterSymbolAction(compilationAnalyzer.AddClass, SymbolKind.NamedType);[m
[32m+[m[32m            context.RegisterSymbolAction(compilationAnalyzer.AddMethod, SymbolKind.Method);[m
[32m+[m[32m            context.RegisterSymbolAction(compilationAnalyzer.AddField, SymbolKind.Field);[m
[32m+[m[32m            context.RegisterSymbolAction(compilationAnalyzer.AddProperty, SymbolKind.Property);[m
[32m+[m
[32m+[m[32m            context.RegisterCompilationEndAction(compilationAnalyzer.ReportCompilationEndDiagnostics);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        class CompilationAnalyzer[m
[32m+[m[32m        {[m
[32m+[m[32m            List<IMethodSymbol> analyzerMethodSymbols = new List<IMethodSymbol>();[m
[32m+[m[32m            List<IPropertySymbol> analyzerPropertySymbols = new List<IPropertySymbol>();[m
[32m+[m[32m            List<IFieldSymbol> analyzerFieldSymbols = new List<IFieldSymbol>();[m
[32m+[m[32m            List<INamedTypeSymbol> otherClassSymbols = new List<INamedTypeSymbol>();[m
[32m+[m[32m            IMethodSymbol initializeSymbol = null;[m
[32m+[m[32m            IPropertySymbol propertySymbol = null;[m[41m [m
[32m+[m[32m            INamedTypeSymbol analyzerClassSymbol = null;[m
[32m+[m[32m            Dictionary<string, string> branchesDict = new Dictionary<string, string>();[m
[32m+[m
[32m+[m[32m            internal void ReportCompilationEndDiagnostics(CompilationAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                //supported main branches for tutorial[m
[32m+[m[32m                branchesDict.Add("RegisterSyntaxNodeAction", "SyntaxNode");[m
[32m+[m
[32m+[m[32m                //supported sub-branches for tutorial[m
[32m+[m[32m                List<string> allowedKinds = new List<string>();[m
[32m+[m[32m                allowedKinds.Add("IfStatement");[m
[32m+[m
[32m+[m[32m                if (analyzerClassSymbol == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                //gather initialize info[m
[32m+[m[32m                List<object> registerInfo = CheckInitialize(context);[m
[32m+[m[32m                if (registerInfo == null) return;[m
[32m+[m[41m               [m
[32m+[m[32m                var registerSymbol = (IMethodSymbol)registerInfo[0];[m
[32m+[m[32m                if (registerSymbol == null) return;[m
[32m+[m[32m                var registerArgs = (List<ISymbol>)registerInfo[1];[m
[32m+[m[32m                if (registerArgs == null) return;[m
[32m+[m[32m                if (registerArgs.Count == 0) return;[m
[32m+[m[32m                if (registerArgs.Count > 0)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (registerArgs[0] != null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        var analysisMethodSymbol = (IMethodSymbol)registerArgs[0];[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                IFieldSymbol kind = null;[m
[32m+[m[32m                if (registerArgs.Count > 1)[m
[32m+[m[32m                {[m
[32m+[m[32m                    kind = (IFieldSymbol)registerArgs[1];[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                //interpret initialize info[m
[32m+[m[32m                if (branchesDict.ContainsKey(registerSymbol.Name.ToString()))[m
[32m+[m[32m                {[m
[32m+[m[32m                    string kindName = null;[m
[32m+[m[32m                    if (kind != null)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        kindName = kind.Name.ToString();[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    if (kindName == null || allowedKinds.Contains(kindName))[m
[32m+[m[32m                    {[m
[32m+[m[32m                        //look for and interpret id fields[m
[32m+[m[32m                        var idNames = CheckIds(branchesDict[registerSymbol.Name.ToString()], kindName, context);[m
[32m+[m[32m                        if (idNames.Count > 0)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            //look for and interpret rule fields[m
[32m+[m[32m                            var ruleNames = CheckRules(idNames, branchesDict[registerSymbol.Name.ToString()], kindName, context);[m
[32m+[m
[32m+[m[32m                            if (ruleNames.Count > 0)[m
[32m+[m[32m                            {[m
[32m+[m[32m                                //look for and interpret SupportedDiagnostics property[m
[32m+[m[32m                                var supportedDiagnosticsCorrect = CheckSupportedDiagnostics(ruleNames, context);[m
[32m+[m
[32m+[m[32m                                if (supportedDiagnosticsCorrect)[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    //check the SyntaxNode, Symbol, Compilation, CodeBlock, etc analysis method(s)[m
[32m+[m[32m                                    var analysisCorrect = CheckAnlaysis(branchesDict[registerSymbol.Name.ToString()], kindName, ruleNames, context);[m
[32m+[m[32m                                    if (analysisCorrect)[m
[32m+[m[32m                                    {[m
[32m+[m[32m                                        //diagnostic to go to code fix[m
[32m+[m[32m                                    }[m
[32m+[m[32m                                    else[m
[32m+[m[32m                                    {[m
[32m+[m[32m                                        //diagnostic[m
[32m+[m[32m                                    }[m
[32m+[m[32m                                }[m
[32m+[m[32m                                else[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    //diagnostic[m
[32m+[m[32m                                }[m
[32m+[m[32m                            }[m
[32m+[m[32m                            else[m
[32m+[m[32m                            {[m
[32m+[m[32m                                //diagnostic[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else[m
[32m+[m[32m                        {[m
[32m+[m[32m                            // diagnostic for missing id names[m
[32m+[m[32m                            var analyzerClassSyntax = analyzerClassSymbol.DeclaringSyntaxReferences[0].GetSyntax() as ClassDeclarationSyntax;[m
[32m+[m[32m                            ReportDiagnostic(context, missingIdRule, analyzerClassSyntax.Identifier.GetLocation(), analyzerClassSyntax.Identifier.ToString());[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ReportDiagnostic(context, incorrectInitStatementRule, registerSymbol.Locations[0], incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    //diagnostic[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m
[32m+[m[41m                [m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            internal bool CheckAnlaysis(string branch, string kind, List<string> ruleNames, CompilationAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new NotImplementedException();[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            internal bool CheckSupportedDiagnostics(List<string> ruleNames, CompilationAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new NotImplementedException();[m
[32m+[m[32m            }[m
[32m+[m[41m            [m
[32m+[m[32m            //returns a list of rule names[m
[32m+[m[32m            internal List<string> CheckRules(List<string> idNames, string branch, string kind, CompilationAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new NotImplementedException();[m
[32m+[m
[32m+[m[32m            }[m
[32m+[m[41m            [m
[32m+[m[32m            //returns a list of id names, empty if none found[m
[32m+[m[32m            internal List<string> CheckIds(string branch, string kind, CompilationAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                List<string> idNames = new List<string>();[m
[32m+[m[32m                foreach (IFieldSymbol field in analyzerFieldSymbols)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (field.IsConst && field.IsStatic && field.DeclaredAccessibility.ToString() == "public" && field.Type.ToString() == "string")[m
[32m+[m[32m                    {[m
[32m+[m[32m                        if (field.Name == null) continue;[m
[32m+[m[32m                        idNames.Add(field.Name.ToString());[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                return idNames;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            //returns a symbol for the register call, and a list of the arguments[m
[32m+[m[32m            //assumes that there is only one thing registered[m
[32m+[m[32m            internal List<object> CheckInitialize(CompilationAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                //default values for returning[m
[32m+[m[32m                IMethodSymbol registerCall = null;[m
[32m+[m[32m                List<ISymbol> registerArgs = new List<ISymbol>();[m
[32m+[m
[32m+[m[41m                [m
[32m+[m[32m                if (initializeSymbol == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    //the initialize method was not found[m
[32m+[m[32m                    ReportDiagnostic(context, missingInitRule, analyzerClassSymbol.Locations[0], missingInitRule.MessageFormat);[m
[32m+[m[32m                    return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    //checking method signature[m
[32m+[m[32m                    var parameters = initializeSymbol.Parameters;[m
[32m+[m[32m                    if (parameters.Count() != 1 || parameters[0].Type.ToString() != "Microsoft.CodeAnalysis.Diagnostics.AnalysisContext" || parameters[0].Name.ToString() != "context" || initializeSymbol.DeclaredAccessibility.ToString() != "Public" || !initializeSymbol.IsOverride || !initializeSymbol.ReturnsVoid)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ReportDiagnostic(context, incorrectInitSigRule, initializeSymbol.Locations[0], missingInitRule.MessageFormat);[m
[32m+[m[32m                        return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                    }[m
[32m+[m[41m                    [m
[32m+[m[32m                    //looking at the contents of the initialize method[m
[32m+[m[32m                    var initializeMethod = initializeSymbol.DeclaringSyntaxReferences[0].GetSyntax() as MethodDeclarationSyntax;[m
[32m+[m[32m                    if (initializeMethod == null) return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m
[32m+[m[32m                    var codeBlock = initializeMethod.Body as BlockSyntax;[m
[32m+[m[32m                    if (codeBlock == null) return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m
[32m+[m[32m                    var statements = codeBlock.Statements;[m
[32m+[m[32m                    if (statements.Count == 0)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        //no statements inside initiailize[m
[32m+[m[32m                        ReportDiagnostic(context, missingRegisterRule, initializeSymbol.Locations[0], missingRegisterRule.MessageFormat);[m
[32m+[m[32m                        return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else if (statements.Count > 1)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        //too many statements inside initialize[m
[32m+[m[32m                        ReportDiagnostic(context, tooManyInitStatementsRule, statements[0].GetLocation(), tooManyInitStatementsRule.MessageFormat);[m
[32m+[m[32m                        return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else[m
[32m+[m[32m                    {[m
[32m+[m[32m                        //only one statement inside initialize[m
[32m+[m[32m                        var statement = statements[0] as ExpressionStatementSyntax;[m
[32m+[m[32m                        if (statement == null) {[m
[32m+[m[32m                            ReportDiagnostic(context, incorrectInitStatementRule, initializeMethod.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        var invocationExpr = statement.Expression as InvocationExpressionSyntax;[m
[32m+[m[32m                        if (invocationExpr == null)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            ReportDiagnostic(context, incorrectInitStatementRule, statement.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        var memberExpr = invocationExpr.Expression as MemberAccessExpressionSyntax;[m
[32m+[m[32m                        if (memberExpr == null)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            ReportDiagnostic(context, incorrectInitStatementRule, invocationExpr.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        var memberExprContext = memberExpr.Expression as IdentifierNameSyntax;[m
[32m+[m[32m                        if (memberExprContext == null)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            ReportDiagnostic(context, incorrectInitStatementRule, memberExpr.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (memberExprContext.Identifier.ToString() != "context")[m
[32m+[m[32m                        {[m
[32m+[m[32m                            ReportDiagnostic(context, incorrectInitStatementRule, memberExprContext.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        var memberExprRegister = memberExpr.Name as IdentifierNameSyntax;[m
[32m+[m[32m                        if (memberExprRegister == null)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            ReportDiagnostic(context, incorrectInitStatementRule, memberExpr.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (!branchesDict.ContainsKey(memberExprRegister.ToString()))[m
[32m+[m[32m                        {[m
[32m+[m[32m                            ReportDiagnostic(context, incorrectInitStatementRule, memberExprRegister.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        if (context.Compilation.GetSemanticModel(invocationExpr.SyntaxTree).GetSymbolInfo(memberExpr).CandidateSymbols.Count() == 0)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            registerCall = context.Compilation.GetSemanticModel(memberExpr.SyntaxTree).GetSymbolInfo(memberExpr).Symbol as IMethodSymbol;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else[m
[32m+[m[32m                        {[m
[32m+[m[32m                            registerCall = context.Compilation.GetSemanticModel(memberExpr.SyntaxTree).GetSymbolInfo(memberExpr).CandidateSymbols[0] as IMethodSymbol;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (registerCall == null) return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m
[32m+[m[32m                        var arguments = invocationExpr.ArgumentList.Arguments;[m
[32m+[m[32m                        if (arguments == null)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            ReportDiagnostic(context, incorrectInitStatementRule, memberExpr.GetLocation(), incorrectInitStatementRule.MessageFormat);[m
[32m+[m[32m                            return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (arguments.Count() > 0)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            var actionSymbol = context.Compilation.GetSemanticModel(invocationExpr.SyntaxTree).GetSymbolInfo(arguments[0].Expression).Symbol as IMethodSymbol;[m
[32m+[m[32m                            registerArgs.Add(actionSymbol);[m
[32m+[m
[32m+[m[32m                            if (arguments.Count() > 1)[m
[32m+[m[32m                            {[m
[32m+[m[32m                                var kindSymbol = context.Compilation.GetSemanticModel(invocationExpr.SyntaxTree).GetSymbolInfo(arguments[1].Expression).Symbol as IFieldSymbol;[m
[32m+[m[32m                                if (kindSymbol == null)[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m                                }[m
[32m+[m[32m                                else[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    registerArgs.Add(kindSymbol);[m
[32m+[m[32m                                }[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m
[32m+[m[32m                return new List<object>(new object[] { registerCall, registerArgs });[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            #region symbol collectors[m
[32m+[m[32m            internal void AddMethod(SymbolAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                var sym = (IMethodSymbol)context.Symbol;[m
[32m+[m
[32m+[m[32m                if (sym == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (sym.ContainingType == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (sym.ContainingType.BaseType == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (sym.ContainingType.BaseType.ToString() != "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer")[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (analyzerMethodSymbols.Contains(sym))[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (sym.Name.ToString() == "Initialize")[m
[32m+[m[32m                {[m
[32m+[m[32m                    initializeSymbol = sym;[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                analyzerMethodSymbols.Add(sym);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            internal void AddProperty(SymbolAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                var sym = (IPropertySymbol)context.Symbol;[m
[32m+[m
[32m+[m[32m                if (sym == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (sym.ContainingType == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (sym.ContainingType.BaseType == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (sym.ContainingType.BaseType.ToString() != "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer")[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (analyzerPropertySymbols.Contains(sym))[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (sym.Name.ToString() == "SupportedDiagnostics")[m
[32m+[m[32m                {[m
[32m+[m[32m                    propertySymbol = sym;[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                analyzerPropertySymbols.Add(sym);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            internal void AddField(SymbolAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                var sym = (IFieldSymbol)context.Symbol;[m
[32m+[m
[32m+[m[32m                if (sym == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (sym.ContainingType == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (sym.ContainingType.BaseType == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (sym.ContainingType.BaseType.ToString() != "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer")[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (analyzerFieldSymbols.Contains(sym))[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                analyzerFieldSymbols.Add(sym);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            internal void AddClass(SymbolAnalysisContext context)[m
[32m+[m[32m            {[m
[32m+[m[32m                var sym = (INamedTypeSymbol)context.Symbol;[m
[32m+[m
[32m+[m[32m                if (sym == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (sym.BaseType == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (sym.BaseType.ToString() != "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer")[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (sym.ContainingType == null) return;[m
[32m+[m[32m                    if (sym.ContainingType.BaseType == null) return;[m
[32m+[m[32m                    if (sym.ContainingType.BaseType.ToString() == "Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer")[m
[32m+[m[32m                    {[m
[32m+[m[32m                        if (otherClassSymbols.Contains(sym))[m
[32m+[m[32m                        {[m
[32m+[m[32m                            return;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else[m
[32m+[m[32m                        {[m
[32m+[m[32m                            otherClassSymbols.Add(sym);[m
[32m+[m[32m                            return;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                analyzerClassSymbol = sym;[m
[32m+[m[32m            }[m
[32m+[m[32m            #endregion[m
[32m+[m
[32m+[m[32m            internal void ClearState()[m
[32m+[m[32m            {[m
[32m+[m[32m                analyzerClassSymbol = null;[m
[32m+[m[32m                analyzerFieldSymbols = new List<IFieldSymbol>();[m
[32m+[m[32m                analyzerMethodSymbols = new List<IMethodSymbol>();[m
[32m+[m[32m                analyzerPropertySymbols = new List<IPropertySymbol>();[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            public static void ReportDiagnostic(CompilationAnalysisContext context, DiagnosticDescriptor rule, Location location, params object[] messageArgs)[m
[32m+[m[32m            {[m
[32m+[m[32m                var diagnostic = Diagnostic.Create(rule, location, messageArgs);[m
[32m+[m[32m                context.ReportDiagnostic(diagnostic);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/MetaCompilation.csproj b/MetaCompilation/MetaCompilation/MetaCompilation/MetaCompilation.csproj[m
[1mnew file mode 100644[m
[1mindex 0000000..b3aab06[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/MetaCompilation.csproj[m
[36m@@ -0,0 +1,126 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">[m
[32m+[m[32m  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <MinimumVisualStudioVersion>11.0</MinimumVisualStudioVersion>[m
[32m+[m[32m    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>[m
[32m+[m[32m    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>[m
[32m+[m[32m    <ProjectGuid>{6CD505A6-60D7-4C35-AE53-694AFDEB3A64}</ProjectGuid>[m
[32m+[m[32m    <OutputType>Library</OutputType>[m
[32m+[m[32m    <AppDesignerFolder>Properties</AppDesignerFolder>[m
[32m+[m[32m    <RootNamespace>MetaCompilation</RootNamespace>[m
[32m+[m[32m    <AssemblyName>MetaCompilation</AssemblyName>[m
[32m+[m[32m    <ProjectTypeGuids>{786C830F-07A1-408B-BD7F-6EE04809D6DB};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>[m
[32m+[m[32m    <TargetFrameworkProfile>Profile7</TargetFrameworkProfile>[m
[32m+[m[32m    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">[m
[32m+[m[32m    <DebugSymbols>true</DebugSymbols>[m
[32m+[m[32m    <DebugType>full</DebugType>[m
[32m+[m[32m    <Optimize>false</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Debug\</OutputPath>[m
[32m+[m[32m    <DefineConstants>DEBUG;TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">[m
[32m+[m[32m    <DebugType>pdbonly</DebugType>[m
[32m+[m[32m    <Optimize>true</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Release\</OutputPath>[m
[32m+[m[32m    <DefineConstants>TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Compile Include="CodeFixProvider.cs" />[m
[32m+[m[32m    <Compile Include="DiagnosticAnalyzer.cs" />[m
[32m+[m[32m    <Compile Include="Properties\AssemblyInfo.cs" />[m
[32m+[m[32m    <Compile Include="Resources.Designer.cs">[m
[32m+[m[32m      <AutoGen>True</AutoGen>[m
[32m+[m[32m      <DesignTime>True</DesignTime>[m
[32m+[m[32m      <DependentUpon>Resources.resx</DependentUpon>[m
[32m+[m[32m    </Compile>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <EmbeddedResource Include="Resources.resx">[m
[32m+[m[32m      <Generator>ResXFileCodeGenerator</Generator>[m
[32m+[m[32m      <LastGenOutput>Resources.Designer.cs</LastGenOutput>[m
[32m+[m[32m    </EmbeddedResource>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <None Include="Diagnostic.nuspec">[m
[32m+[m[32m      <SubType>Designer</SubType>[m
[32m+[m[32m      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>[m
[32m+[m[32m    </None>[m
[32m+[m[32m    <None Include="packages.config" />[m
[32m+[m[32m    <None Include="tools\install.ps1">[m
[32m+[m[32m      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>[m
[32m+[m[32m    </None>[m
[32m+[m[32m    <None Include="tools\uninstall.ps1">[m
[32m+[m[32m      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>[m
[32m+[m[32m    </None>[m
[32m+[m[32m    <None Include="ReadMe.txt" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Analyzer Include="..\..\packages\Microsoft.CodeAnalysis.Analyzers.1.0.0-rc2\tools\analyzers\C#\Microsoft.CodeAnalysis.Analyzers.dll" />[m
[32m+[m[32m    <Analyzer Include="..\..\packages\Microsoft.CodeAnalysis.Analyzers.1.0.0-rc2\tools\analyzers\C#\Microsoft.CodeAnalysis.CSharp.Analyzers.dll" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Common.1.0.0-rc2\lib\portable-net45+win8\Microsoft.CodeAnalysis.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.1.0.0-rc2\lib\portable-net45+win8\Microsoft.CodeAnalysis.CSharp.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.Workspaces.1.0.0-rc2\lib\portable-net45+win8\Microsoft.CodeAnalysis.CSharp.Workspaces.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Workspaces.Common.1.0.0-rc2\lib\portable-net45+win8\Microsoft.CodeAnalysis.Workspaces.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Collections.Immutable, Version=1.1.33.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\System.Collections.Immutable.1.1.33-beta\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.AttributedModel, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.AttributedModel.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Convention, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Convention.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Hosting, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Hosting.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Runtime, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Runtime.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.TypedParts, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.TypedParts.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Reflection.Metadata, Version=1.0.18.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\System.Reflection.Metadata.1.0.18-beta\lib\portable-net45+win8\System.Reflection.Metadata.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <Import Project="$(MSBuildExtensionsPath32)\Microsoft\Portable\v4.6\Microsoft.Portable.CSharp.targets" />[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <PostBuildEvent>"$(SolutionDir)\packages\NuGet.CommandLine.2.8.2\tools\NuGet.exe" pack Diagnostic.nuspec -NoPackageAnalysis -OutputDirectory .</PostBuildEvent>[m
[32m+[m[32m    <RunPostBuildEvent>OnOutputUpdated</RunPostBuildEvent>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.[m[41m [m
[32m+[m[32m       Other similar extension points exist, see Microsoft.Common.targets.[m
[32m+[m[32m  <Target Name="BeforeBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  <Target Name="AfterBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  -->[m
[32m+[m[32m</Project>[m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/Properties/AssemblyInfo.cs b/MetaCompilation/MetaCompilation/MetaCompilation/Properties/AssemblyInfo.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..573c3c5[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/Properties/AssemblyInfo.cs[m
[36m@@ -0,0 +1,31 @@[m
[32m+[m[32m﻿using System.Reflection;[m
[32m+[m[32musing System.Runtime.InteropServices;[m
[32m+[m
[32m+[m[32m// General Information about an assembly is controlled through the following[m[41m [m
[32m+[m[32m// set of attributes. Change these attribute values to modify the information[m
[32m+[m[32m// associated with an assembly.[m
[32m+[m[32m[assembly: AssemblyTitle("MetaCompilation")][m
[32m+[m[32m[assembly: AssemblyDescription("")][m
[32m+[m[32m[assembly: AssemblyConfiguration("")][m
[32m+[m[32m[assembly: AssemblyCompany("")][m
[32m+[m[32m[assembly: AssemblyProduct("MetaCompilation")][m
[32m+[m[32m[assembly: AssemblyCopyright("Copyright ©  2015")][m
[32m+[m[32m[assembly: AssemblyTrademark("")][m
[32m+[m[32m[assembly: AssemblyCulture("")][m
[32m+[m
[32m+[m[32m// Setting ComVisible to false makes the types in this assembly not visible[m[41m [m
[32m+[m[32m// to COM components.  If you need to access a type in this assembly from[m[41m [m
[32m+[m[32m// COM, set the ComVisible attribute to true on that type.[m
[32m+[m[32m[assembly: ComVisible(false)][m
[32m+[m
[32m+[m[32m// Version information for an assembly consists of the following four values:[m
[32m+[m[32m//[m
[32m+[m[32m//      Major Version[m
[32m+[m[32m//      Minor Version[m[41m [m
[32m+[m[32m//      Build Number[m
[32m+[m[32m//      Revision[m
[32m+[m[32m//[m
[32m+[m[32m// You can specify all the values or you can default the Build and Revision Numbers[m[41m [m
[32m+[m[32m// by using the '*' as shown below:[m
[32m+[m[32m[assembly: AssemblyVersion("1.0.*")][m
[32m+[m[32m[assembly: AssemblyFileVersion("1.0.0.0")][m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/ReadMe.txt b/MetaCompilation/MetaCompilation/MetaCompilation/ReadMe.txt[m
[1mnew file mode 100644[m
[1mindex 0000000..1b92bfa[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/ReadMe.txt[m
[36m@@ -0,0 +1,33 @@[m
[32m+[m[32m﻿[m
[32m+[m[32mBuilding this project will produce an analyzer .dll, as well as the[m
[32m+[m[32mfollowing two ways you may wish to package that analyzer:[m
[32m+[m[32m * A NuGet package (.nupkg file) that will add your assembly as a[m
[32m+[m[32m   project-local analyzer that participates in builds.[m
[32m+[m[32m * A VSIX extension (.vsix file) that will apply your analyzer to all projects[m
[32m+[m[32m   and works just in the IDE.[m
[32m+[m
[32m+[m[32mTo debug your analyzer, make sure the default project is the VSIX project and[m
[32m+[m[32mstart debugging.  This will deploy the analyzer as a VSIX into another instance[m
[32m+[m[32mof Visual Studio, which is useful for debugging, even if you intend to produce[m
[32m+[m[32ma NuGet package.[m
[32m+[m
[32m+[m
[32m+[m[32mTRYING OUT YOUR NUGET PACKAGE[m
[32m+[m
[32m+[m[32mTo try out the NuGet package:[m
[32m+[m[32m 1. Create a local NuGet feed by following the instructions here:[m
[32m+[m[32m    > http://docs.nuget.org/docs/creating-packages/hosting-your-own-nuget-feeds[m
[32m+[m[32m 2. Copy the .nupkg file into that folder.[m
[32m+[m[32m 3. Open the target project in Visual Studio 2015.[m
[32m+[m[32m 4. Right-click on the project node in Solution Explorer and choose Manage[m
[32m+[m[32m    NuGet Packages.[m
[32m+[m[32m 5. Select the NuGet feed you created on the left.[m
[32m+[m[32m 6. Choose your analyzer from the list and click Install.[m
[32m+[m
[32m+[m[32mIf you want to automatically deploy the .nupkg file to the local feed folder[m
[32m+[m[32mwhen you build this project, follow these steps:[m
[32m+[m[32m 1. Right-click on this project in Solution Explorer and choose Properties.[m
[32m+[m[32m 2. Go to the Compile tab.[m
[32m+[m[32m 3. Click the Build Events button.[m
[32m+[m[32m 4. In the "Post-build event command line" box, change the -OutputDirectory[m
[32m+[m[32m    path to point to your local NuGet feed folder.[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/Resources.Designer.cs b/MetaCompilation/MetaCompilation/MetaCompilation/Resources.Designer.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..7d58a23[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/Resources.Designer.cs[m
[36m@@ -0,0 +1,106 @@[m
[32m+[m[32m﻿//------------------------------------------------------------------------------[m
[32m+[m[32m// <auto-generated>[m
[32m+[m[32m//     This code was generated by a tool.[m
[32m+[m[32m//     Runtime Version:4.0.30319.0[m
[32m+[m[32m//[m
[32m+[m[32m//     Changes to this file may cause incorrect behavior and will be lost if[m
[32m+[m[32m//     the code is regenerated.[m
[32m+[m[32m// </auto-generated>[m
[32m+[m[32m//------------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mnamespace MetaCompilation[m
[32m+[m[32m{[m
[32m+[m[32m    using System;[m
[32m+[m[32m    using System.Reflection;[m
[32m+[m
[32m+[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    ///   A strongly-typed resource class, for looking up localized strings, etc.[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    // This class was auto-generated by the StronglyTypedResourceBuilder[m
[32m+[m[32m    // class via a tool like ResGen or Visual Studio.[m
[32m+[m[32m    // To add or remove a member, edit your .ResX file then rerun ResGen[m
[32m+[m[32m    // with the /str option, or rebuild your VS project.[m
[32m+[m[32m    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")][m
[32m+[m[32m    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()][m
[32m+[m[32m    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()][m
[32m+[m[32m    internal class Resources[m
[32m+[m[32m    {[m
[32m+[m
[32m+[m[32m        private static global::System.Resources.ResourceManager resourceMan;[m
[32m+[m
[32m+[m[32m        private static global::System.Globalization.CultureInfo resourceCulture;[m
[32m+[m
[32m+[m[32m        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")][m
[32m+[m[32m        internal Resources()[m
[32m+[m[32m        {[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        ///   Returns the cached ResourceManager instance used by this class.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)][m
[32m+[m[32m        internal static global::System.Resources.ResourceManager ResourceManager[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                if (object.ReferenceEquals(resourceMan, null))[m
[32m+[m[32m                {[m
[32m+[m[32m                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("MetaCompilation.Resources", typeof(Resources).GetTypeInfo().Assembly);[m
[32m+[m[32m                    resourceMan = temp;[m
[32m+[m[32m                }[m
[32m+[m[32m                return resourceMan;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        ///   Overrides the current thread's CurrentUICulture property for all[m
[32m+[m[32m        ///   resource lookups using this strongly typed resource class.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)][m
[32m+[m[32m        internal static global::System.Globalization.CultureInfo Culture[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return resourceCulture;[m
[32m+[m[32m            }[m
[32m+[m[32m            set[m
[32m+[m[32m            {[m
[32m+[m[32m                resourceCulture = value;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        ///   Looks up a localized string similar to Type names should be all uppercase..[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        internal static string AnalyzerDescription[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return ResourceManager.GetString("AnalyzerDescription", resourceCulture);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        ///   Looks up a localized string similar to Type name &apos;{0}&apos; contains lowercase letters.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        internal static string AnalyzerMessageFormat[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return ResourceManager.GetString("AnalyzerMessageFormat", resourceCulture);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        ///   Looks up a localized string similar to Type name contains lowercase letters.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        internal static string AnalyzerTitle[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return ResourceManager.GetString("AnalyzerTitle", resourceCulture);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/Resources.resx b/MetaCompilation/MetaCompilation/MetaCompilation/Resources.resx[m
[1mnew file mode 100644[m
[1mindex 0000000..c97ee9b[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/Resources.resx[m
[36m@@ -0,0 +1,132 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<root>[m
[32m+[m[32m  <!--[m[41m [m
[32m+[m[32m    Microsoft ResX Schema[m[41m [m
[32m+[m[41m    [m
[32m+[m[32m    Version 2.0[m
[32m+[m[41m    [m
[32m+[m[32m    The primary goals of this format is to allow a simple XML format[m[41m [m
[32m+[m[32m    that is mostly human readable. The generation and parsing of the[m[41m [m
[32m+[m[32m    various data types are done through the TypeConverter classes[m[41m [m
[32m+[m[32m    associated with the data types.[m
[32m+[m[41m    [m
[32m+[m[32m    Example:[m
[32m+[m[41m    [m
[32m+[m[32m    ... ado.net/XML headers & schema ...[m
[32m+[m[32m    <resheader name="resmimetype">text/microsoft-resx</resheader>[m
[32m+[m[32m    <resheader name="version">2.0</resheader>[m
[32m+[m[32m    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>[m
[32m+[m[32m    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>[m
[32m+[m[32m    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>[m
[32m+[m[32m    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>[m
[32m+[m[32m    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">[m
[32m+[m[32m        <value>[base64 mime encoded serialized .NET Framework object]</value>[m
[32m+[m[32m    </data>[m
[32m+[m[32m    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">[m
[32m+[m[32m        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>[m
[32m+[m[32m        <comment>This is a comment</comment>[m
[32m+[m[32m    </data>[m
[32m+[m[41m                [m
[32m+[m[32m    There are any number of "resheader" rows that contain simple[m[41m [m
[32m+[m[32m    name/value pairs.[m
[32m+[m[41m    [m
[32m+[m[32m    Each data row contains a name, and value. The row also contains a[m[41m [m
[32m+[m[32m    type or mimetype. Type corresponds to a .NET class that support[m[41m [m
[32m+[m[32m    text/value conversion through the TypeConverter architecture.[m[41m [m
[32m+[m[32m    Classes that don't support this are serialized and stored with the[m[41m [m
[32m+[m[32m    mimetype set.[m
[32m+[m[41m    [m
[32m+[m[32m    The mimetype is used for serialized objects, and tells the[m[41m [m
[32m+[m[32m    ResXResourceReader how to depersist the object. This is currently not[m[41m [m
[32m+[m[32m    extensible. For a given mimetype the value must be set accordingly:[m
[32m+[m[41m    [m
[32m+[m[32m    Note - application/x-microsoft.net.object.binary.base64 is the format[m[41m [m
[32m+[m[32m    that the ResXResourceWriter will generate, however the reader can[m[41m [m
[32m+[m[32m    read any of the formats listed below.[m
[32m+[m[41m    [m
[32m+[m[32m    mimetype: application/x-microsoft.net.object.binary.base64[m
[32m+[m[32m    value   : The object must be serialized with[m[41m [m
[32m+[m[32m            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter[m
[32m+[m[32m            : and then encoded with base64 encoding.[m
[32m+[m[41m    [m
[32m+[m[32m    mimetype: application/x-microsoft.net.object.soap.base64[m
[32m+[m[32m    value   : The object must be serialized with[m[41m [m
[32m+[m[32m            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter[m
[32m+[m[32m            : and then encoded with base64 encoding.[m
[32m+[m
[32m+[m[32m    mimetype: application/x-microsoft.net.object.bytearray.base64[m
[32m+[m[32m    value   : The object must be serialized into a byte array[m[41m [m
[32m+[m[32m            : using a System.ComponentModel.TypeConverter[m
[32m+[m[32m            : and then encoded with base64 encoding.[m
[32m+[m[32m    -->[m
[32m+[m[32m  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">[m
[32m+[m[32m    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />[m
[32m+[m[32m    <xsd:element name="root" msdata:IsDataSet="true">[m
[32m+[m[32m      <xsd:complexType>[m
[32m+[m[32m        <xsd:choice maxOccurs="unbounded">[m
[32m+[m[32m          <xsd:element name="metadata">[m
[32m+[m[32m            <xsd:complexType>[m
[32m+[m[32m              <xsd:sequence>[m
[32m+[m[32m                <xsd:element name="value" type="xsd:string" minOccurs="0" />[m
[32m+[m[32m              </xsd:sequence>[m
[32m+[m[32m              <xsd:attribute name="name" use="required" type="xsd:string" />[m
[32m+[m[32m              <xsd:attribute name="type" type="xsd:string" />[m
[32m+[m[32m              <xsd:attribute name="mimetype" type="xsd:string" />[m
[32m+[m[32m              <xsd:attribute ref="xml:space" />[m
[32m+[m[32m            </xsd:complexType>[m
[32m+[m[32m          </xsd:element>[m
[32m+[m[32m          <xsd:element name="assembly">[m
[32m+[m[32m            <xsd:complexType>[m
[32m+[m[32m              <xsd:attribute name="alias" type="xsd:string" />[m
[32m+[m[32m              <xsd:attribute name="name" type="xsd:string" />[m
[32m+[m[32m            </xsd:complexType>[m
[32m+[m[32m          </xsd:element>[m
[32m+[m[32m          <xsd:element name="data">[m
[32m+[m[32m            <xsd:complexType>[m
[32m+[m[32m              <xsd:sequence>[m
[32m+[m[32m                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />[m
[32m+[m[32m                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />[m
[32m+[m[32m              </xsd:sequence>[m
[32m+[m[32m              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />[m
[32m+[m[32m              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />[m
[32m+[m[32m              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />[m
[32m+[m[32m              <xsd:attribute ref="xml:space" />[m
[32m+[m[32m            </xsd:complexType>[m
[32m+[m[32m          </xsd:element>[m
[32m+[m[32m          <xsd:element name="resheader">[m
[32m+[m[32m            <xsd:complexType>[m
[32m+[m[32m              <xsd:sequence>[m
[32m+[m[32m                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />[m
[32m+[m[32m              </xsd:sequence>[m
[32m+[m[32m              <xsd:attribute name="name" type="xsd:string" use="required" />[m
[32m+[m[32m            </xsd:complexType>[m
[32m+[m[32m          </xsd:element>[m
[32m+[m[32m        </xsd:choice>[m
[32m+[m[32m      </xsd:complexType>[m
[32m+[m[32m    </xsd:element>[m
[32m+[m[32m  </xsd:schema>[m
[32m+[m[32m  <resheader name="resmimetype">[m
[32m+[m[32m    <value>text/microsoft-resx</value>[m
[32m+[m[32m  </resheader>[m
[32m+[m[32m  <resheader name="version">[m
[32m+[m[32m    <value>2.0</value>[m
[32m+[m[32m  </resheader>[m
[32m+[m[32m  <resheader name="reader">[m
[32m+[m[32m    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>[m
[32m+[m[32m  </resheader>[m
[32m+[m[32m  <resheader name="writer">[m
[32m+[m[32m    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>[m
[32m+[m[32m  </resheader>[m
[32m+[m[32m  <data name="AnalyzerDescription" xml:space="preserve">[m
[32m+[m[32m    <value>Type names should be all uppercase.</value>[m
[32m+[m[32m    <comment>An optional longer localizable description of the diagnostic.</comment>[m
[32m+[m[32m  </data>[m
[32m+[m[32m  <data name="AnalyzerMessageFormat" xml:space="preserve">[m
[32m+[m[32m    <value>Type name '{0}' contains lowercase letters</value>[m
[32m+[m[32m    <comment>The format-able message the diagnostic displays.</comment>[m
[32m+[m[32m  </data>[m
[32m+[m[32m  <data name="AnalyzerTitle" xml:space="preserve">[m
[32m+[m[32m    <value>Type name contains lowercase letters</value>[m
[32m+[m[32m    <comment>The title of the diagnostic.</comment>[m
[32m+[m[32m  </data>[m
[32m+[m[32m</root>[m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/packages.config b/MetaCompilation/MetaCompilation/MetaCompilation/packages.config[m
[1mnew file mode 100644[m
[1mindex 0000000..ec9b94c[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/packages.config[m
[36m@@ -0,0 +1,12 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<packages>[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.Analyzers" version="1.0.0-rc2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.Common" version="1.0.0-rc2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.CSharp" version="1.0.0-rc2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.CSharp.Workspaces" version="1.0.0-rc2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.Workspaces.Common" version="1.0.0-rc2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.Composition" version="1.0.27" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="NuGet.CommandLine" version="2.8.2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="System.Collections.Immutable" version="1.1.33-beta" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="System.Reflection.Metadata" version="1.0.18-beta" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m</packages>[m
\ No newline at end of file[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/tools/install.ps1 b/MetaCompilation/MetaCompilation/MetaCompilation/tools/install.ps1[m
[1mnew file mode 100644[m
[1mindex 0000000..6a2b94d[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/tools/install.ps1[m
[36m@@ -0,0 +1,24 @@[m
[32m+[m[32m﻿param($installPath, $toolsPath, $package, $project)[m
[32m+[m
[32m+[m[32m$analyzersPath = join-path $toolsPath "analyzers"[m
[32m+[m
[32m+[m[32m# Install the language agnostic analyzers.[m
[32m+[m[32mforeach ($analyzerFilePath in Get-ChildItem $analyzersPath -Filter *.dll)[m
[32m+[m[32m{[m
[32m+[m[32m    if($project.Object.AnalyzerReferences)[m
[32m+[m[32m    {[m
[32m+[m[32m        $project.Object.AnalyzerReferences.Add($analyzerFilePath.FullName)[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m# Install language specific analyzers.[m
[32m+[m[32m# $project.Type gives the language name like (C# or VB.NET)[m
[32m+[m[32m$languageAnalyzersPath = join-path $analyzersPath $project.Type[m
[32m+[m
[32m+[m[32mforeach ($analyzerFilePath in Get-ChildItem $languageAnalyzersPath -Filter *.dll)[m
[32m+[m[32m{[m
[32m+[m[32m    if($project.Object.AnalyzerReferences)[m
[32m+[m[32m    {[m
[32m+[m[32m        $project.Object.AnalyzerReferences.Add($analyzerFilePath.FullName)[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/MetaCompilation/MetaCompilation/MetaCompilation/tools/uninstall.ps1 b/MetaCompilation/MetaCompilation/MetaCompilation/tools/uninstall.ps1[m
[1mnew file mode 100644[m
[1mindex 0000000..de0016c[m
[1m--- /dev/null[m
[1m+++ b/MetaCompilation/MetaCompilation/MetaCompilation/tools/uninstall.ps1[m
[36m@@ -0,0 +1,24 @@[m
[32m+[m[32m﻿param($installPath, $toolsPath, $package, $project)[m
[32m+[m
[32m+[m[32m# Uninstall the language agnostic analyzers.[m
[32m+[m[32m$analyzersPath = join-path $toolsPath "analyzers"[m
[32m+[m
[32m+[m[32mforeach ($analyzerFilePath in Get-ChildItem $analyzersPath -Filter *.dll)[m
[32m+[m[32m{[m
[32m+[m[32m    if($project.Object.AnalyzerReferences)[m
[32m+[m[32m    {[m
[32m+[m[32m        $project.Object.AnalyzerReferences.Remove($analyzerFilePath.FullName)[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m# Uninstall language specific analyzers.[m
[32m+[m[32m# $project.Type gives the language name like (C# or VB.NET)[m
[32m+[m[32m$languageAnalyzersPath = join-path $analyzersPath $project.Type[m
[32m+[m
[32m+[m[32mforeach ($analyzerFilePath in Get-ChildItem $languageAnalyzersPath -Filter *.dll)[m
[32m+[m[32m{[m
[32m+[m[32m    if($project.Object.AnalyzerReferences)[m
[32m+[m[32m    {[m
[32m+[m[32m        $project.Object.AnalyzerReferences.Remove($analyzerFilePath.FullName)[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate.sln b/NewAnalyzerTemplate/NewAnalyzerTemplate.sln[m
[1mnew file mode 100644[m
[1mindex 0000000..266dfc9[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate.sln[m
[36m@@ -0,0 +1,34 @@[m
[32m+[m[32m﻿[m
[32m+[m[32mMicrosoft Visual Studio Solution File, Format Version 12.00[m
[32m+[m[32m# Visual Studio 14[m
[32m+[m[32mVisualStudioVersion = 14.0.22823.1[m
[32m+[m[32mMinimumVisualStudioVersion = 10.0.40219.1[m
[32m+[m[32mProject("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "NewAnalyzerTemplate", "NewAnalyzerTemplate\NewAnalyzerTemplate\NewAnalyzerTemplate.csproj", "{702DD21D-86CF-4222-94E3-FC008A2B3423}"[m
[32m+[m[32mEndProject[m
[32m+[m[32mProject("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "NewAnalyzerTemplate.Test", "NewAnalyzerTemplate\NewAnalyzerTemplate.Test\NewAnalyzerTemplate.Test.csproj", "{19ADF009-EC92-4CA7-A663-77D12A8503B2}"[m
[32m+[m[32mEndProject[m
[32m+[m[32mProject("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "NewAnalyzerTemplate.Vsix", "NewAnalyzerTemplate\NewAnalyzerTemplate.Vsix\NewAnalyzerTemplate.Vsix.csproj", "{0C7CED5F-F00E-4EF2-9DFE-8AFD9DFC8483}"[m
[32m+[m[32mEndProject[m
[32m+[m[32mGlobal[m
[32m+[m	[32mGlobalSection(SolutionConfigurationPlatforms) = preSolution[m
[32m+[m		[32mDebug|Any CPU = Debug|Any CPU[m
[32m+[m		[32mRelease|Any CPU = Release|Any CPU[m
[32m+[m	[32mEndGlobalSection[m
[32m+[m	[32mGlobalSection(ProjectConfigurationPlatforms) = postSolution[m
[32m+[m		[32m{702DD21D-86CF-4222-94E3-FC008A2B3423}.Debug|Any CPU.ActiveCfg = Debug|Any CPU[m
[32m+[m		[32m{702DD21D-86CF-4222-94E3-FC008A2B3423}.Debug|Any CPU.Build.0 = Debug|Any CPU[m
[32m+[m		[32m{702DD21D-86CF-4222-94E3-FC008A2B3423}.Release|Any CPU.ActiveCfg = Release|Any CPU[m
[32m+[m		[32m{702DD21D-86CF-4222-94E3-FC008A2B3423}.Release|Any CPU.Build.0 = Release|Any CPU[m
[32m+[m		[32m{19ADF009-EC92-4CA7-A663-77D12A8503B2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU[m
[32m+[m		[32m{19ADF009-EC92-4CA7-A663-77D12A8503B2}.Debug|Any CPU.Build.0 = Debug|Any CPU[m
[32m+[m		[32m{19ADF009-EC92-4CA7-A663-77D12A8503B2}.Release|Any CPU.ActiveCfg = Release|Any CPU[m
[32m+[m		[32m{19ADF009-EC92-4CA7-A663-77D12A8503B2}.Release|Any CPU.Build.0 = Release|Any CPU[m
[32m+[m		[32m{0C7CED5F-F00E-4EF2-9DFE-8AFD9DFC8483}.Debug|Any CPU.ActiveCfg = Debug|Any CPU[m
[32m+[m		[32m{0C7CED5F-F00E-4EF2-9DFE-8AFD9DFC8483}.Debug|Any CPU.Build.0 = Debug|Any CPU[m
[32m+[m		[32m{0C7CED5F-F00E-4EF2-9DFE-8AFD9DFC8483}.Release|Any CPU.ActiveCfg = Release|Any CPU[m
[32m+[m		[32m{0C7CED5F-F00E-4EF2-9DFE-8AFD9DFC8483}.Release|Any CPU.Build.0 = Release|Any CPU[m
[32m+[m	[32mEndGlobalSection[m
[32m+[m	[32mGlobalSection(SolutionProperties) = preSolution[m
[32m+[m		[32mHideSolutionNode = FALSE[m
[32m+[m	[32mEndGlobalSection[m
[32m+[m[32mEndGlobal[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Helpers/CodeFixVerifier.Helper.cs b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Helpers/CodeFixVerifier.Helper.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..0f73d06[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Helpers/CodeFixVerifier.Helper.cs[m
[36m@@ -0,0 +1,85 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeActions;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Formatting;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Simplification;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m
[32m+[m[32mnamespace TestHelper[m
[32m+[m[32m{[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Diagnostic Producer class with extra methods dealing with applying codefixes[m
[32m+[m[32m    /// All methods are static[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public abstract partial class CodeFixVerifier : DiagnosticVerifier[m
[32m+[m[32m    {[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Apply the inputted CodeAction to the inputted document.[m
[32m+[m[32m        /// Meant to be used to apply codefixes.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="document">The Document to apply the fix on</param>[m
[32m+[m[32m        /// <param name="codeAction">A CodeAction that will be applied to the Document.</param>[m
[32m+[m[32m        /// <returns>A Document with the changes from the CodeAction</returns>[m
[32m+[m[32m        private static Document ApplyFix(Document document, CodeAction codeAction)[m
[32m+[m[32m        {[m
[32m+[m[32m            var operations = codeAction.GetOperationsAsync(CancellationToken.None).Result;[m
[32m+[m[32m            var solution = operations.OfType<ApplyChangesOperation>().Single().ChangedSolution;[m
[32m+[m[32m            return solution.GetDocument(document.Id);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Compare two collections of Diagnostics,and return a list of any new diagnostics that appear only in the second collection.[m
[32m+[m[32m        /// Note: Considers Diagnostics to be the same if they have the same Ids.  In the case of multiple diagnostics with the same Id in a row,[m
[32m+[m[32m        /// this method may not necessarily return the new one.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="diagnostics">The Diagnostics that existed in the code before the CodeFix was applied</param>[m
[32m+[m[32m        /// <param name="newDiagnostics">The Diagnostics that exist in the code after the CodeFix was applied</param>[m
[32m+[m[32m        /// <returns>A list of Diagnostics that only surfaced in the code after the CodeFix was applied</returns>[m
[32m+[m[32m        private static IEnumerable<Diagnostic> GetNewDiagnostics(IEnumerable<Diagnostic> diagnostics, IEnumerable<Diagnostic> newDiagnostics)[m
[32m+[m[32m        {[m
[32m+[m[32m            var oldArray = diagnostics.OrderBy(d => d.Location.SourceSpan.Start).ToArray();[m
[32m+[m[32m            var newArray = newDiagnostics.OrderBy(d => d.Location.SourceSpan.Start).ToArray();[m
[32m+[m
[32m+[m[32m            int oldIndex = 0;[m
[32m+[m[32m            int newIndex = 0;[m
[32m+[m
[32m+[m[32m            while (newIndex < newArray.Length)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (oldIndex < oldArray.Length && oldArray[oldIndex].Id == newArray[newIndex].Id)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ++oldIndex;[m
[32m+[m[32m                    ++newIndex;[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    yield return newArray[newIndex++];[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Get the existing compiler diagnostics on the inputted document.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="document">The Document to run the compiler diagnostic analyzers on</param>[m
[32m+[m[32m        /// <returns>The compiler diagnostics that were found in the code</returns>[m
[32m+[m[32m        private static IEnumerable<Diagnostic> GetCompilerDiagnostics(Document document)[m
[32m+[m[32m        {[m
[32m+[m[32m            return document.GetSemanticModelAsync().Result.GetDiagnostics();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Given a document, turn it into a string based on the syntax root[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="document">The Document to be converted to a string</param>[m
[32m+[m[32m        /// <returns>A string containing the syntax of the Document after formatting</returns>[m
[32m+[m[32m        private static string GetStringFromDocument(Document document)[m
[32m+[m[32m        {[m
[32m+[m[32m            var simplifiedDoc = Simplifier.ReduceAsync(document, Simplifier.Annotation).Result;[m
[32m+[m[32m            var root = simplifiedDoc.GetSyntaxRootAsync().Result;[m
[32m+[m[32m            root = Formatter.Format(root, Formatter.Annotation, simplifiedDoc.Project.Solution.Workspace);[m
[32m+[m[32m            return root.GetText().ToString();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Helpers/DiagnosticResult.cs b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Helpers/DiagnosticResult.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..5958a4d[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Helpers/DiagnosticResult.cs[m
[36m@@ -0,0 +1,86 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing System;[m
[32m+[m
[32m+[m[32mnamespace TestHelper[m
[32m+[m[32m{[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Location where the diagnostic appears, as determined by path, line number, and column number.[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public struct DiagnosticResultLocation[m
[32m+[m[32m    {[m
[32m+[m[32m        public DiagnosticResultLocation(string path, int line, int column)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (line < 0 && column < 0)[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new ArgumentOutOfRangeException("At least one of line and column must be > 0");[m
[32m+[m[32m            }[m
[32m+[m[32m            if (line < -1 || column < -1)[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new ArgumentOutOfRangeException("Both line and column must be >= -1");[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            this.Path = path;[m
[32m+[m[32m            this.Line = line;[m
[32m+[m[32m            this.Column = column;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public string Path;[m
[32m+[m[32m        public int Line;[m
[32m+[m[32m        public int Column;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Struct that stores information about a Diagnostic appearing in a source[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public struct DiagnosticResult[m
[32m+[m[32m    {[m
[32m+[m[32m        private DiagnosticResultLocation[] locations;[m
[32m+[m
[32m+[m[32m        public DiagnosticResultLocation[] Locations[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                if (this.locations == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    this.locations = new DiagnosticResultLocation[] { };[m
[32m+[m[32m                }[m
[32m+[m[32m                return this.locations;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            set[m
[32m+[m[32m            {[m
[32m+[m[32m                this.locations = value;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public DiagnosticSeverity Severity { get; set; }[m
[32m+[m
[32m+[m[32m        public string Id { get; set; }[m
[32m+[m
[32m+[m[32m        public string Message { get; set; }[m
[32m+[m
[32m+[m[32m        public string Path[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return this.Locations.Length > 0 ? this.Locations[0].Path : "";[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public int Line[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return this.Locations.Length > 0 ? this.Locations[0].Line : -1;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public int Column[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return this.Locations.Length > 0 ? this.Locations[0].Column : -1;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Helpers/DiagnosticVerifier.Helper.cs b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Helpers/DiagnosticVerifier.Helper.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..12b93c2[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Helpers/DiagnosticVerifier.Helper.cs[m
[36m@@ -0,0 +1,179 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Text;[m
[32m+[m[32musing System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Collections.Immutable;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m
[32m+[m[32mnamespace TestHelper[m
[32m+[m[32m{[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Class for turning strings into documents and getting the diagnostics on them[m
[32m+[m[32m    /// All methods are static[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public abstract partial class DiagnosticVerifier[m
[32m+[m[32m    {[m
[32m+[m[32m        private static readonly MetadataReference CorlibReference = MetadataReference.CreateFromAssembly(typeof(object).Assembly);[m
[32m+[m[32m        private static readonly MetadataReference SystemCoreReference = MetadataReference.CreateFromAssembly(typeof(Enumerable).Assembly);[m
[32m+[m[32m        private static readonly MetadataReference CSharpSymbolsReference = MetadataReference.CreateFromAssembly(typeof(CSharpCompilation).Assembly);[m
[32m+[m[32m        private static readonly MetadataReference CodeAnalysisReference = MetadataReference.CreateFromAssembly(typeof(Compilation).Assembly);[m
[32m+[m
[32m+[m[32m        internal static string DefaultFilePathPrefix = "Test";[m
[32m+[m[32m        internal static string CSharpDefaultFileExt = "cs";[m
[32m+[m[32m        internal static string VisualBasicDefaultExt = "vb";[m
[32m+[m[32m        internal static string CSharpDefaultFilePath = DefaultFilePathPrefix + 0 + "." + CSharpDefaultFileExt;[m
[32m+[m[32m        internal static string VisualBasicDefaultFilePath = DefaultFilePathPrefix + 0 + "." + VisualBasicDefaultExt;[m
[32m+[m[32m        internal static string TestProjectName = "TestProject";[m
[32m+[m
[32m+[m[32m        #region  Get Diagnostics[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Given classes in the form of strings, their language, and an IDiagnosticAnlayzer to apply to it, return the diagnostics found in the string after converting it to a document.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">Classes in the form of strings</param>[m
[32m+[m[32m        /// <param name="language">The language the source classes are in</param>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer to be run on the sources</param>[m
[32m+[m[32m        /// <returns>An IEnumerable of Diagnostics that surfaced in the source code, sorted by Location</returns>[m
[32m+[m[32m        private static Diagnostic[] GetSortedDiagnostics(string[] sources, string language, DiagnosticAnalyzer analyzer)[m
[32m+[m[32m        {[m
[32m+[m[32m            return GetSortedDiagnosticsFromDocuments(analyzer, GetDocuments(sources, language));[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Given an analyzer and a document to apply it to, run the analyzer and gather an array of diagnostics found in it.[m
[32m+[m[32m        /// The returned diagnostics are then ordered by location in the source document.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer to run on the documents</param>[m
[32m+[m[32m        /// <param name="documents">The Documents that the analyzer will be run on</param>[m
[32m+[m[32m        /// <param name="spans">Optional TextSpan indicating where a Diagnostic will be found</param>[m
[32m+[m[32m        /// <returns>An IEnumerable of Diagnostics that surfaced in the source code, sorted by Location</returns>[m
[32m+[m[32m        protected static Diagnostic[] GetSortedDiagnosticsFromDocuments(DiagnosticAnalyzer analyzer, Document[] documents)[m
[32m+[m[32m        {[m
[32m+[m[32m            var projects = new HashSet<Project>();[m
[32m+[m[32m            foreach (var document in documents)[m
[32m+[m[32m            {[m
[32m+[m[32m                projects.Add(document.Project);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            var diagnostics = new List<Diagnostic>();[m
[32m+[m[32m            foreach (var project in projects)[m
[32m+[m[32m            {[m
[32m+[m[32m                var compilationWithAnalyzers = project.GetCompilationAsync().Result.WithAnalyzers(ImmutableArray.Create(analyzer));[m
[32m+[m[32m                var diags = compilationWithAnalyzers.GetAnalyzerDiagnosticsAsync().Result;[m
[32m+[m[32m                foreach (var diag in diags)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (diag.Location == Location.None || diag.Location.IsInMetadata)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        diagnostics.Add(diag);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else[m
[32m+[m[32m                    {[m
[32m+[m[32m                        for (int i = 0; i < documents.Length; i++)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            var document = documents[i];[m
[32m+[m[32m                            var tree = document.GetSyntaxTreeAsync().Result;[m
[32m+[m[32m                            if (tree == diag.Location.SourceTree)[m
[32m+[m[32m                            {[m
[32m+[m[32m                                diagnostics.Add(diag);[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            var results = SortDiagnostics(diagnostics);[m
[32m+[m[32m            diagnostics.Clear();[m
[32m+[m[32m            return results;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Sort diagnostics by location in source document[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="diagnostics">The list of Diagnostics to be sorted</param>[m
[32m+[m[32m        /// <returns>An IEnumerable containing the Diagnostics in order of Location</returns>[m
[32m+[m[32m        private static Diagnostic[] SortDiagnostics(IEnumerable<Diagnostic> diagnostics)[m
[32m+[m[32m        {[m
[32m+[m[32m            return diagnostics.OrderBy(d => d.Location.SourceSpan.Start).ToArray();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        #endregion[m
[32m+[m
[32m+[m[32m        #region Set up compilation and documents[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Given an array of strings as sources and a language, turn them into a project and return the documents and spans of it.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">Classes in the form of strings</param>[m
[32m+[m[32m        /// <param name="language">The language the source code is in</param>[m
[32m+[m[32m        /// <returns>A Tuple containing the Documents produced from the sources and their TextSpans if relevant</returns>[m
[32m+[m[32m        private static Document[] GetDocuments(string[] sources, string language)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (language != LanguageNames.CSharp && language != LanguageNames.VisualBasic)[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new ArgumentException("Unsupported Language");[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            for (int i = 0; i < sources.Length; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                string fileName = language == LanguageNames.CSharp ? "Test" + i + ".cs" : "Test" + i + ".vb";[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            var project = CreateProject(sources, language);[m
[32m+[m[32m            var documents = project.Documents.ToArray();[m
[32m+[m
[32m+[m[32m            if (sources.Length != documents.Length)[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new SystemException("Amount of sources did not match amount of Documents created");[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            return documents;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Create a Document from a string through creating a project that contains it.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="source">Classes in the form of a string</param>[m
[32m+[m[32m        /// <param name="language">The language the source code is in</param>[m
[32m+[m[32m        /// <returns>A Document created from the source string</returns>[m
[32m+[m[32m        protected static Document CreateDocument(string source, string language = LanguageNames.CSharp)[m
[32m+[m[32m        {[m
[32m+[m[32m            return CreateProject(new[] { source }, language).Documents.First();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Create a project using the inputted strings as sources.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">Classes in the form of strings</param>[m
[32m+[m[32m        /// <param name="language">The language the source code is in</param>[m
[32m+[m[32m        /// <returns>A Project created out of the Documents created from the source strings</returns>[m
[32m+[m[32m        private static Project CreateProject(string[] sources, string language = LanguageNames.CSharp)[m
[32m+[m[32m        {[m
[32m+[m[32m            string fileNamePrefix = DefaultFilePathPrefix;[m
[32m+[m[32m            string fileExt = language == LanguageNames.CSharp ? CSharpDefaultFileExt : VisualBasicDefaultExt;[m
[32m+[m
[32m+[m[32m            var projectId = ProjectId.CreateNewId(debugName: TestProjectName);[m
[32m+[m
[32m+[m[32m            var solution = new AdhocWorkspace()[m
[32m+[m[32m                .CurrentSolution[m
[32m+[m[32m                .AddProject(projectId, TestProjectName, TestProjectName, language)[m
[32m+[m[32m                .AddMetadataReference(projectId, CorlibReference)[m
[32m+[m[32m                .AddMetadataReference(projectId, SystemCoreReference)[m
[32m+[m[32m                .AddMetadataReference(projectId, CSharpSymbolsReference)[m
[32m+[m[32m                .AddMetadataReference(projectId, CodeAnalysisReference);[m
[32m+[m
[32m+[m[32m            int count = 0;[m
[32m+[m[32m            foreach (var source in sources)[m
[32m+[m[32m            {[m
[32m+[m[32m                var newFileName = fileNamePrefix + count + "." + fileExt;[m
[32m+[m[32m                var documentId = DocumentId.CreateNewId(projectId, debugName: newFileName);[m
[32m+[m[32m                solution = solution.AddDocument(documentId, newFileName, SourceText.From(source));[m
[32m+[m[32m                count++;[m
[32m+[m[32m            }[m
[32m+[m[32m            return solution.GetProject(projectId);[m
[32m+[m[32m        }[m
[32m+[m[32m        #endregion[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/NewAnalyzerTemplate.Test.csproj b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/NewAnalyzerTemplate.Test.csproj[m
[1mnew file mode 100644[m
[1mindex 0000000..db05d36[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/NewAnalyzerTemplate.Test.csproj[m
[36m@@ -0,0 +1,132 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>[m
[32m+[m[32m    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>[m
[32m+[m[32m    <ProductVersion>8.0.30703</ProductVersion>[m
[32m+[m[32m    <SchemaVersion>2.0</SchemaVersion>[m
[32m+[m[32m    <ProjectGuid>{19ADF009-EC92-4CA7-A663-77D12A8503B2}</ProjectGuid>[m
[32m+[m[32m    <OutputType>Library</OutputType>[m
[32m+[m[32m    <AppDesignerFolder>Properties</AppDesignerFolder>[m
[32m+[m[32m    <RootNamespace>NewAnalyzerTemplate.Test</RootNamespace>[m
[32m+[m[32m    <AssemblyName>NewAnalyzerTemplate.Test</AssemblyName>[m
[32m+[m[32m    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>[m
[32m+[m[32m    <FileAlignment>512</FileAlignment>[m
[32m+[m[32m    <TargetFrameworkProfile />[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">[m
[32m+[m[32m    <DebugSymbols>true</DebugSymbols>[m
[32m+[m[32m    <DebugType>full</DebugType>[m
[32m+[m[32m    <Optimize>false</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Debug\</OutputPath>[m
[32m+[m[32m    <DefineConstants>DEBUG;TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m    <Prefer32Bit>false</Prefer32Bit>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">[m
[32m+[m[32m    <DebugType>pdbonly</DebugType>[m
[32m+[m[32m    <Optimize>true</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Release\</OutputPath>[m
[32m+[m[32m    <DefineConstants>TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m    <Prefer32Bit>false</Prefer32Bit>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.Desktop.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.Workspaces.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.Workspaces.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp.Workspaces.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.Workspaces.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.Workspaces.Desktop.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.Desktop.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Workspaces.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.Workspaces.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.Workspaces.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Workspaces.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.Workspaces.Desktop.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System" />[m
[32m+[m[32m    <Reference Include="System.Collections.Immutable, Version=1.1.33.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\System.Collections.Immutable.1.1.33-beta\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.AttributedModel, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.AttributedModel.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Convention, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Convention.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Hosting, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Hosting.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Runtime, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Runtime.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.TypedParts, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.TypedParts.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Core" />[m
[32m+[m[32m    <Reference Include="System.Reflection.Metadata, Version=1.0.18.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\System.Reflection.Metadata.1.0.18-beta\lib\portable-net45+win8\System.Reflection.Metadata.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Xml.Linq" />[m
[32m+[m[32m    <Reference Include="System.Data.DataSetExtensions" />[m
[32m+[m[32m    <Reference Include="Microsoft.CSharp" />[m
[32m+[m[32m    <Reference Include="System.Data" />[m
[32m+[m[32m    <Reference Include="System.Xml" />[m
[32m+[m[32m    <Reference Include="Microsoft.VisualStudio.QualityTools.UnitTestFramework" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Compile Include="Verifiers\CodeFixVerifier.cs" />[m
[32m+[m[32m    <Compile Include="Verifiers\DiagnosticVerifier.cs" />[m
[32m+[m[32m    <Compile Include="Helpers\CodeFixVerifier.Helper.cs" />[m
[32m+[m[32m    <Compile Include="Helpers\DiagnosticResult.cs" />[m
[32m+[m[32m    <Compile Include="Helpers\DiagnosticVerifier.Helper.cs" />[m
[32m+[m[32m    <Compile Include="UnitTests.cs" />[m
[32m+[m[32m    <Compile Include="Properties\AssemblyInfo.cs" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <None Include="packages.config" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <ProjectReference Include="..\NewAnalyzerTemplate\NewAnalyzerTemplate.csproj">[m
[32m+[m[32m      <Project>{702DD21D-86CF-4222-94E3-FC008A2B3423}</Project>[m
[32m+[m[32m      <Name>NewAnalyzerTemplate</Name>[m
[32m+[m[32m    </ProjectReference>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />[m
[32m+[m[32m  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.[m[41m [m
[32m+[m[32m       Other similar extension points exist, see Microsoft.Common.targets.[m
[32m+[m[32m  <Target Name="BeforeBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  <Target Name="AfterBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  -->[m
[32m+[m[32m</Project>[m
\ No newline at end of file[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Properties/AssemblyInfo.cs b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Properties/AssemblyInfo.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..ead1406[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Properties/AssemblyInfo.cs[m
[36m@@ -0,0 +1,32 @@[m
[32m+[m[32m﻿using System.Reflection;[m
[32m+[m[32musing System.Runtime.InteropServices;[m
[32m+[m
[32m+[m[32m// General Information about an assembly is controlled through the following[m[41m [m
[32m+[m[32m// set of attributes. Change these attribute values to modify the information[m
[32m+[m[32m// associated with an assembly.[m
[32m+[m[32m[assembly: AssemblyTitle("NewAnalyzerTemplate.Test")][m
[32m+[m[32m[assembly: AssemblyDescription("")][m
[32m+[m[32m[assembly: AssemblyConfiguration("")][m
[32m+[m[32m[assembly: AssemblyCompany("")][m
[32m+[m[32m[assembly: AssemblyProduct("NewAnalyzerTemplate.Test")][m
[32m+[m[32m[assembly: AssemblyCopyright("Copyright ©  2015")][m
[32m+[m[32m[assembly: AssemblyTrademark("")][m
[32m+[m[32m[assembly: AssemblyCulture("")][m
[32m+[m
[32m+[m[32m// Setting ComVisible to false makes the types in this assembly not visible[m[41m [m
[32m+[m[32m// to COM components.  If you need to access a type in this assembly from[m[41m [m
[32m+[m[32m// COM, set the ComVisible attribute to true on that type.[m
[32m+[m[32m[assembly: ComVisible(false)][m
[32m+[m
[32m+[m[32m// Version information for an assembly consists of the following four values:[m
[32m+[m[32m//[m
[32m+[m[32m//      Major Version[m
[32m+[m[32m//      Minor Version[m[41m [m
[32m+[m[32m//      Build Number[m
[32m+[m[32m//      Revision[m
[32m+[m[32m//[m
[32m+[m[32m// You can specify all the values or you can default the Build and Revision Numbers[m[41m [m
[32m+[m[32m// by using the '*' as shown below:[m
[32m+[m[32m// [assembly: AssemblyVersion("1.0.*")][m
[32m+[m[32m[assembly: AssemblyVersion("1.0.0.0")][m
[32m+[m[32m[assembly: AssemblyFileVersion("1.0.0.0")][m
\ No newline at end of file[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/UnitTests.cs b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/UnitTests.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..76292a4[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/UnitTests.cs[m
[36m@@ -0,0 +1,15 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeFixes;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.VisualStudio.TestTools.UnitTesting;[m
[32m+[m[32musing System;[m
[32m+[m[32musing TestHelper;[m
[32m+[m[32musing NewAnalyzerTemplate;[m
[32m+[m
[32m+[m[32mnamespace NewAnalyzerTemplate.Test[m
[32m+[m[32m{[m
[32m+[m[32m    [TestClass][m
[32m+[m[32m    public class UnitTest : CodeFixVerifier[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Verifiers/CodeFixVerifier.cs b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Verifiers/CodeFixVerifier.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..61549fc[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Verifiers/CodeFixVerifier.cs[m
[36m@@ -0,0 +1,128 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeActions;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeFixes;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Formatting;[m
[32m+[m[32musing Microsoft.VisualStudio.TestTools.UnitTesting;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m
[32m+[m[32mnamespace TestHelper[m
[32m+[m[32m{[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Superclass of all Unit tests made for diagnostics with codefixes.[m
[32m+[m[32m    /// Contains methods used to verify correctness of codefixes[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public abstract partial class CodeFixVerifier : DiagnosticVerifier[m
[32m+[m[32m    {[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Returns the codefix being tested (C#) - to be implemented in non-abstract class[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <returns>The CodeFixProvider to be used for CSharp code</returns>[m
[32m+[m[32m        protected virtual CodeFixProvider GetCSharpCodeFixProvider()[m
[32m+[m[32m        {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Returns the codefix being tested (VB) - to be implemented in non-abstract class[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <returns>The CodeFixProvider to be used for VisualBasic code</returns>[m
[32m+[m[32m        protected virtual CodeFixProvider GetBasicCodeFixProvider()[m
[32m+[m[32m        {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a C# codefix when applied on the inputted string as a source[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="oldSource">A class in the form of a string before the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="newSource">A class in the form of a string after the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="codeFixIndex">Index determining which codefix to apply if there are multiple</param>[m
[32m+[m[32m        /// <param name="allowNewCompilerDiagnostics">A bool controlling whether or not the test will fail if the CodeFix introduces other warnings after being applied</param>[m
[32m+[m[32m        protected void VerifyCSharpFix(string oldSource, string newSource, int? codeFixIndex = null, bool allowNewCompilerDiagnostics = false)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyFix(LanguageNames.CSharp, GetCSharpDiagnosticAnalyzer(), GetCSharpCodeFixProvider(), oldSource, newSource, codeFixIndex, allowNewCompilerDiagnostics);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a VB codefix when applied on the inputted string as a source[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="oldSource">A class in the form of a string before the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="newSource">A class in the form of a string after the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="codeFixIndex">Index determining which codefix to apply if there are multiple</param>[m
[32m+[m[32m        /// <param name="allowNewCompilerDiagnostics">A bool controlling whether or not the test will fail if the CodeFix introduces other warnings after being applied</param>[m
[32m+[m[32m        protected void VerifyBasicFix(string oldSource, string newSource, int? codeFixIndex = null, bool allowNewCompilerDiagnostics = false)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyFix(LanguageNames.VisualBasic, GetBasicDiagnosticAnalyzer(), GetBasicCodeFixProvider(), oldSource, newSource, codeFixIndex, allowNewCompilerDiagnostics);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// General verifier for codefixes.[m
[32m+[m[32m        /// Creates a Document from the source string, then gets diagnostics on it and applies the relevant codefixes.[m
[32m+[m[32m        /// Then gets the string after the codefix is applied and compares it with the expected result.[m
[32m+[m[32m        /// Note: If any codefix causes new diagnostics to show up, the test fails unless allowNewCompilerDiagnostics is set to true.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="language">The language the source code is in</param>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer to be applied to the source code</param>[m
[32m+[m[32m        /// <param name="codeFixProvider">The codefix to be applied to the code wherever the relevant Diagnostic is found</param>[m
[32m+[m[32m        /// <param name="oldSource">A class in the form of a string before the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="newSource">A class in the form of a string after the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="codeFixIndex">Index determining which codefix to apply if there are multiple</param>[m
[32m+[m[32m        /// <param name="allowNewCompilerDiagnostics">A bool controlling whether or not the test will fail if the CodeFix introduces other warnings after being applied</param>[m
[32m+[m[32m        private void VerifyFix(string language, DiagnosticAnalyzer analyzer, CodeFixProvider codeFixProvider, string oldSource, string newSource, int? codeFixIndex, bool allowNewCompilerDiagnostics)[m
[32m+[m[32m        {[m
[32m+[m[32m            var document = CreateDocument(oldSource, language);[m
[32m+[m[32m            var analyzerDiagnostics = GetSortedDiagnosticsFromDocuments(analyzer, new[] { document });[m
[32m+[m[32m            var compilerDiagnostics = GetCompilerDiagnostics(document);[m
[32m+[m[32m            var attempts = analyzerDiagnostics.Length;[m
[32m+[m
[32m+[m[32m            for (int i = 0; i < attempts; ++i)[m
[32m+[m[32m            {[m
[32m+[m[32m                var actions = new List<CodeAction>();[m
[32m+[m[32m                var context = new CodeFixContext(document, analyzerDiagnostics[0], (a, d) => actions.Add(a), CancellationToken.None);[m
[32m+[m[32m                codeFixProvider.RegisterCodeFixesAsync(context).Wait();[m
[32m+[m
[32m+[m[32m                if (!actions.Any())[m
[32m+[m[32m                {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (codeFixIndex != null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    document = ApplyFix(document, actions.ElementAt((int)codeFixIndex));[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                document = ApplyFix(document, actions.ElementAt(0));[m
[32m+[m[32m                analyzerDiagnostics = GetSortedDiagnosticsFromDocuments(analyzer, new[] { document });[m
[32m+[m
[32m+[m[32m                var newCompilerDiagnostics = GetNewDiagnostics(compilerDiagnostics, GetCompilerDiagnostics(document));[m
[32m+[m
[32m+[m[32m                //check if applying the code fix introduced any new compiler diagnostics[m
[32m+[m[32m                if (!allowNewCompilerDiagnostics && newCompilerDiagnostics.Any())[m
[32m+[m[32m                {[m
[32m+[m[32m                    // Format and get the compiler diagnostics again so that the locations make sense in the output[m
[32m+[m[32m                    document = document.WithSyntaxRoot(Formatter.Format(document.GetSyntaxRootAsync().Result, Formatter.Annotation, document.Project.Solution.Workspace));[m
[32m+[m[32m                    newCompilerDiagnostics = GetNewDiagnostics(compilerDiagnostics, GetCompilerDiagnostics(document));[m
[32m+[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Fix introduced new compiler diagnostics:\r\n{0}\r\n\r\nNew document:\r\n{1}\r\n",[m
[32m+[m[32m                            string.Join("\r\n", newCompilerDiagnostics.Select(d => d.ToString())),[m
[32m+[m[32m                            document.GetSyntaxRootAsync().Result.ToFullString()));[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                //check if there are analyzer diagnostics left after the code fix[m
[32m+[m[32m                if (!analyzerDiagnostics.Any())[m
[32m+[m[32m                {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            //after applying all of the code fixes, compare the resulting string to the inputted one[m
[32m+[m[32m            var actual = GetStringFromDocument(document);[m
[32m+[m[32m            Assert.AreEqual(newSource, actual);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Verifiers/DiagnosticVerifier.cs b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Verifiers/DiagnosticVerifier.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..a0124e5[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/Verifiers/DiagnosticVerifier.cs[m
[36m@@ -0,0 +1,270 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.VisualStudio.TestTools.UnitTesting;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Text;[m
[32m+[m
[32m+[m[32mnamespace TestHelper[m
[32m+[m[32m{[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Superclass of all Unit Tests for DiagnosticAnalyzers[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public abstract partial class DiagnosticVerifier[m
[32m+[m[32m    {[m
[32m+[m[32m        #region To be implemented by Test classes[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Get the CSharp analyzer being tested - to be implemented in non-abstract class[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        protected virtual DiagnosticAnalyzer GetCSharpDiagnosticAnalyzer()[m
[32m+[m[32m        {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Get the Visual Basic analyzer being tested (C#) - to be implemented in non-abstract class[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        protected virtual DiagnosticAnalyzer GetBasicDiagnosticAnalyzer()[m
[32m+[m[32m        {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        #endregion[m
[32m+[m
[32m+[m[32m        #region Verifier wrappers[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a C# DiagnosticAnalyzer when applied on the single inputted string as a source[m
[32m+[m[32m        /// Note: input a DiagnosticResult for each Diagnostic expected[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="source">A class in the form of a string to run the analyzer on</param>[m
[32m+[m[32m        /// <param name="expected"> DiagnosticResults that should appear after the analyzer is run on the source</param>[m
[32m+[m[32m        protected void VerifyCSharpDiagnostic(string source, params DiagnosticResult[] expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyDiagnostics(new[] { source }, LanguageNames.CSharp, GetCSharpDiagnosticAnalyzer(), expected);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a VB DiagnosticAnalyzer when applied on the single inputted string as a source[m
[32m+[m[32m        /// Note: input a DiagnosticResult for each Diagnostic expected[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="source">A class in the form of a string to run the analyzer on</param>[m
[32m+[m[32m        /// <param name="expected">DiagnosticResults that should appear after the analyzer is run on the source</param>[m
[32m+[m[32m        protected void VerifyBasicDiagnostic(string source, params DiagnosticResult[] expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyDiagnostics(new[] { source }, LanguageNames.VisualBasic, GetBasicDiagnosticAnalyzer(), expected);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a C# DiagnosticAnalyzer when applied on the inputted strings as a source[m
[32m+[m[32m        /// Note: input a DiagnosticResult for each Diagnostic expected[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">An array of strings to create source documents from to run the analyzers on</param>[m
[32m+[m[32m        /// <param name="expected">DiagnosticResults that should appear after the analyzer is run on the sources</param>[m
[32m+[m[32m        protected void VerifyCSharpDiagnostic(string[] sources, params DiagnosticResult[] expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyDiagnostics(sources, LanguageNames.CSharp, GetCSharpDiagnosticAnalyzer(), expected);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a VB DiagnosticAnalyzer when applied on the inputted strings as a source[m
[32m+[m[32m        /// Note: input a DiagnosticResult for each Diagnostic expected[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">An array of strings to create source documents from to run the analyzers on</param>[m
[32m+[m[32m        /// <param name="expected">DiagnosticResults that should appear after the analyzer is run on the sources</param>[m
[32m+[m[32m        protected void VerifyBasicDiagnostic(string[] sources, params DiagnosticResult[] expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyDiagnostics(sources, LanguageNames.VisualBasic, GetBasicDiagnosticAnalyzer(), expected);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// General method that gets a collection of actual diagnostics found in the source after the analyzer is run,[m[41m [m
[32m+[m[32m        /// then verifies each of them.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">An array of strings to create source documents from to run the analyzers on</param>[m
[32m+[m[32m        /// <param name="language">The language of the classes represented by the source strings</param>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer to be run on the source code</param>[m
[32m+[m[32m        /// <param name="expected">DiagnosticResults that should appear after the analyzer is run on the sources</param>[m
[32m+[m[32m        private void VerifyDiagnostics(string[] sources, string language, DiagnosticAnalyzer analyzer, params DiagnosticResult[] expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            var diagnostics = GetSortedDiagnostics(sources, language, analyzer);[m
[32m+[m[32m            VerifyDiagnosticResults(diagnostics, analyzer, expected);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        #endregion[m
[32m+[m
[32m+[m[32m        #region Actual comparisons and verifications[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Checks each of the actual Diagnostics found and compares them with the corresponding DiagnosticResult in the array of expected results.[m
[32m+[m[32m        /// Diagnostics are considered equal only if the DiagnosticResultLocation, Id, Severity, and Message of the DiagnosticResult match the actual diagnostic.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="actualResults">The Diagnostics found by the compiler after running the analyzer on the source code</param>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer that was being run on the sources</param>[m
[32m+[m[32m        /// <param name="expectedResults">Diagnostic Results that should have appeared in the code</param>[m
[32m+[m[32m        private static void VerifyDiagnosticResults(IEnumerable<Diagnostic> actualResults, DiagnosticAnalyzer analyzer, params DiagnosticResult[] expectedResults)[m
[32m+[m[32m        {[m
[32m+[m[32m            int expectedCount = expectedResults.Count();[m
[32m+[m[32m            int actualCount = actualResults.Count();[m
[32m+[m
[32m+[m[32m            if (expectedCount != actualCount)[m
[32m+[m[32m            {[m
[32m+[m[32m                string diagnosticsOutput = actualResults.Any() ? FormatDiagnostics(analyzer, actualResults.ToArray()) : "    NONE.";[m
[32m+[m
[32m+[m[32m                Assert.IsTrue(false,[m
[32m+[m[32m                    string.Format("Mismatch between number of diagnostics returned, expected \"{0}\" actual \"{1}\"\r\n\r\nDiagnostics:\r\n{2}\r\n", expectedCount, actualCount, diagnosticsOutput));[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            for (int i = 0; i < expectedResults.Length; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                var actual = actualResults.ElementAt(i);[m
[32m+[m[32m                var expected = expectedResults[i];[m
[32m+[m
[32m+[m[32m                if (expected.Line == -1 && expected.Column == -1)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (actual.Location != Location.None)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        Assert.IsTrue(false,[m
[32m+[m[32m                            string.Format("Expected:\nA project diagnostic with No location\nActual:\n{0}",[m
[32m+[m[32m                            FormatDiagnostics(analyzer, actual)));[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    VerifyDiagnosticLocation(analyzer, actual, actual.Location, expected.Locations.First());[m
[32m+[m[32m                    var additionalLocations = actual.AdditionalLocations.ToArray();[m
[32m+[m
[32m+[m[32m                    if (additionalLocations.Length != expected.Locations.Length - 1)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        Assert.IsTrue(false,[m
[32m+[m[32m                            string.Format("Expected {0} additional locations but got {1} for Diagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                                expected.Locations.Length - 1, additionalLocations.Length,[m
[32m+[m[32m                                FormatDiagnostics(analyzer, actual)));[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    for (int j = 0; j < additionalLocations.Length; ++j)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        VerifyDiagnosticLocation(analyzer, actual, additionalLocations[j], expected.Locations[j + 1]);[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (actual.Id != expected.Id)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Expected diagnostic id to be \"{0}\" was \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                            expected.Id, actual.Id, FormatDiagnostics(analyzer, actual)));[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (actual.Severity != expected.Severity)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Expected diagnostic severity to be \"{0}\" was \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                            expected.Severity, actual.Severity, FormatDiagnostics(analyzer, actual)));[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (actual.GetMessage() != expected.Message)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Expected diagnostic message to be \"{0}\" was \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                            expected.Message, actual.GetMessage(), FormatDiagnostics(analyzer, actual)));[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Helper method to VerifyDiagnosticResult that checks the location of a diagnostic and compares it with the location in the expected DiagnosticResult.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer that was being run on the sources</param>[m
[32m+[m[32m        /// <param name="diagnostic">The diagnostic that was found in the code</param>[m
[32m+[m[32m        /// <param name="actual">The Location of the Diagnostic found in the code</param>[m
[32m+[m[32m        /// <param name="expected">The DiagnosticResultLocation that should have been found</param>[m
[32m+[m[32m        private static void VerifyDiagnosticLocation(DiagnosticAnalyzer analyzer, Diagnostic diagnostic, Location actual, DiagnosticResultLocation expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            var actualSpan = actual.GetLineSpan();[m
[32m+[m
[32m+[m[32m            Assert.IsTrue(actualSpan.Path == expected.Path || (actualSpan.Path != null && actualSpan.Path.Contains("Test0.") && expected.Path.Contains("Test.")),[m
[32m+[m[32m                string.Format("Expected diagnostic to be in file \"{0}\" was actually in file \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                    expected.Path, actualSpan.Path, FormatDiagnostics(analyzer, diagnostic)));[m
[32m+[m
[32m+[m[32m            var actualLinePosition = actualSpan.StartLinePosition;[m
[32m+[m
[32m+[m[32m            // Only check line position if there is an actual line in the real diagnostic[m
[32m+[m[32m            if (actualLinePosition.Line > 0)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (actualLinePosition.Line + 1 != expected.Line)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Expected diagnostic to be on line \"{0}\" was actually on line \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                            expected.Line, actualLinePosition.Line + 1, FormatDiagnostics(analyzer, diagnostic)));[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Only check column position if there is an actual column position in the real diagnostic[m
[32m+[m[32m            if (actualLinePosition.Character > 0)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (actualLinePosition.Character + 1 != expected.Column)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Expected diagnostic to start at column \"{0}\" was actually at column \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                            expected.Column, actualLinePosition.Character + 1, FormatDiagnostics(analyzer, diagnostic)));[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        #endregion[m
[32m+[m
[32m+[m[32m        #region Formatting Diagnostics[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Helper method to format a Diagnostic into an easily readable string[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer that this verifier tests</param>[m
[32m+[m[32m        /// <param name="diagnostics">The Diagnostics to be formatted</param>[m
[32m+[m[32m        /// <returns>The Diagnostics formatted as a string</returns>[m
[32m+[m[32m        private static string FormatDiagnostics(DiagnosticAnalyzer analyzer, params Diagnostic[] diagnostics)[m
[32m+[m[32m        {[m
[32m+[m[32m            var builder = new StringBuilder();[m
[32m+[m[32m            for (int i = 0; i < diagnostics.Length; ++i)[m
[32m+[m[32m            {[m
[32m+[m[32m                builder.AppendLine("// " + diagnostics[i].ToString());[m
[32m+[m
[32m+[m[32m                var analyzerType = analyzer.GetType();[m
[32m+[m[32m                var rules = analyzer.SupportedDiagnostics;[m
[32m+[m
[32m+[m[32m                foreach (var rule in rules)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (rule != null && rule.Id == diagnostics[i].Id)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        var location = diagnostics[i].Location;[m
[32m+[m[32m                        if (location == Location.None)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            builder.AppendFormat("GetGlobalResult({0}.{1})", analyzerType.Name, rule.Id);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else[m
[32m+[m[32m                        {[m
[32m+[m[32m                            Assert.IsTrue(location.IsInSource,[m
[32m+[m[32m                                string.Format("Test base does not currently handle diagnostics in metadata locations. Diagnostic in metadata:\r\n", diagnostics[i]));[m
[32m+[m
[32m+[m[32m                            string resultMethodName = diagnostics[i].Location.SourceTree.FilePath.EndsWith(".cs") ? "GetCSharpResultAt" : "GetBasicResultAt";[m
[32m+[m[32m                            var linePosition = diagnostics[i].Location.GetLineSpan().StartLinePosition;[m
[32m+[m
[32m+[m[32m                            builder.AppendFormat("{0}({1}, {2}, {3}.{4})",[m
[32m+[m[32m                                resultMethodName,[m
[32m+[m[32m                                linePosition.Line + 1,[m
[32m+[m[32m                                linePosition.Character + 1,[m
[32m+[m[32m                                analyzerType.Name,[m
[32m+[m[32m                                rule.Id);[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        if (i != diagnostics.Length - 1)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            builder.Append(',');[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        builder.AppendLine();[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            return builder.ToString();[m
[32m+[m[32m        }[m
[32m+[m[32m        #endregion[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/packages.config b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/packages.config[m
[1mnew file mode 100644[m
[1mindex 0000000..fd6eb05[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Test/packages.config[m
[36m@@ -0,0 +1,10 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<packages>[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.Common" version="1.0.0-rc2" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.CSharp" version="1.0.0-rc2" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.CSharp.Workspaces" version="1.0.0-rc2" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.Workspaces.Common" version="1.0.0-rc2" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.Composition" version="1.0.27" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="System.Collections.Immutable" version="1.1.33-beta" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="System.Reflection.Metadata" version="1.0.18-beta" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m</packages>[m
\ No newline at end of file[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Vsix/NewAnalyzerTemplate.Vsix.csproj b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Vsix/NewAnalyzerTemplate.Vsix.csproj[m
[1mnew file mode 100644[m
[1mindex 0000000..a417196[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Vsix/NewAnalyzerTemplate.Vsix.csproj[m
[36m@@ -0,0 +1,69 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>[m
[32m+[m[32m    <VSToolsPath Condition="'$(VSToolsPath)' == ''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>[m
[32m+[m[32m    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>[m
[32m+[m[32m    <SchemaVersion>2.0</SchemaVersion>[m
[32m+[m[32m    <ProjectTypeGuids>{82b43b9b-a64c-4715-b499-d71e9ca2bd60};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>[m
[32m+[m[32m    <ProjectGuid>{0C7CED5F-F00E-4EF2-9DFE-8AFD9DFC8483}</ProjectGuid>[m
[32m+[m[32m    <OutputType>Library</OutputType>[m
[32m+[m[32m    <AppDesignerFolder>Properties</AppDesignerFolder>[m
[32m+[m[32m    <RootNamespace>NewAnalyzerTemplate</RootNamespace>[m
[32m+[m[32m    <AssemblyName>NewAnalyzerTemplate</AssemblyName>[m
[32m+[m[32m    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>[m
[32m+[m[32m    <GeneratePkgDefFile>false</GeneratePkgDefFile>[m
[32m+[m[32m    <IncludeAssemblyInVSIXContainer>false</IncludeAssemblyInVSIXContainer>[m
[32m+[m[32m    <IncludeDebugSymbolsInVSIXContainer>false</IncludeDebugSymbolsInVSIXContainer>[m
[32m+[m[32m    <IncludeDebugSymbolsInLocalVSIXDeployment>false</IncludeDebugSymbolsInLocalVSIXDeployment>[m
[32m+[m[32m    <CopyBuildOutputToOutputDirectory>false</CopyBuildOutputToOutputDirectory>[m
[32m+[m[32m    <CopyOutputSymbolsToOutputDirectory>false</CopyOutputSymbolsToOutputDirectory>[m
[32m+[m[32m    <VSSDKTargetPlatformRegRootSuffix>Roslyn</VSSDKTargetPlatformRegRootSuffix>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">[m
[32m+[m[32m    <DebugSymbols>true</DebugSymbols>[m
[32m+[m[32m    <DebugType>full</DebugType>[m
[32m+[m[32m    <Optimize>false</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Debug\</OutputPath>[m
[32m+[m[32m    <DefineConstants>DEBUG;TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">[m
[32m+[m[32m    <DebugType>pdbonly</DebugType>[m
[32m+[m[32m    <Optimize>true</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Release\</OutputPath>[m
[32m+[m[32m    <DefineConstants>TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <StartAction>Program</StartAction>[m
[32m+[m[32m    <StartProgram>$(DevEnvDir)devenv.exe</StartProgram>[m
[32m+[m[32m    <StartArguments>/rootsuffix Roslyn</StartArguments>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <None Include="source.extension.vsixmanifest">[m
[32m+[m[32m      <SubType>Designer</SubType>[m
[32m+[m[32m    </None>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <ProjectReference Include="..\NewAnalyzerTemplate\NewAnalyzerTemplate.csproj">[m
[32m+[m[32m      <Project>{702DD21D-86CF-4222-94E3-FC008A2B3423}</Project>[m
[32m+[m[32m      <Name>NewAnalyzerTemplate</Name>[m
[32m+[m[32m    </ProjectReference>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />[m
[32m+[m[32m  <Import Project="$(VSToolsPath)\VSSDK\Microsoft.VsSDK.targets" Condition="'$(VSToolsPath)' != ''" />[m
[32m+[m[32m  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.[m[41m [m
[32m+[m[32m       Other similar extension points exist, see Microsoft.Common.targets.[m
[32m+[m[32m  <Target Name="BeforeBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  <Target Name="AfterBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  -->[m
[32m+[m[32m</Project>[m
\ No newline at end of file[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Vsix/source.extension.vsixmanifest b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Vsix/source.extension.vsixmanifest[m
[1mnew file mode 100644[m
[1mindex 0000000..8b05526[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.Vsix/source.extension.vsixmanifest[m
[36m@@ -0,0 +1,21 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<PackageManifest Version="2.0.0" xmlns="http://schemas.microsoft.com/developer/vsx-schema/2011" xmlns:d="http://schemas.microsoft.com/developer/vsx-schema-design/2011">[m
[32m+[m[32m  <Metadata>[m
[32m+[m[32m    <Identity Id="NewAnalyzerTemplate.Vsix..9167350e-11c0-4b55-96da-ba52951ae87d" Version="1.0" Language="en-US" Publisher="Administrator"/>[m
[32m+[m[32m    <DisplayName>NewAnalyzerTemplate.Vsix</DisplayName>[m
[32m+[m[32m    <Description xml:space="preserve">This is a sample diagnostic extension for the .NET Compiler Platform ("Roslyn").</Description>[m
[32m+[m[32m  </Metadata>[m
[32m+[m[32m  <Installation>[m
[32m+[m[32m    <InstallationTarget Version="[14.0,]" Id="Microsoft.VisualStudio.Pro" />[m
[32m+[m[32m    <InstallationTarget Version="[14.0,]" Id="Microsoft.VisualStudio.VSWinDesktopExpress" />[m
[32m+[m[32m    <InstallationTarget Version="[14.0,]" Id="Microsoft.VisualStudio.VWDExpress" />[m
[32m+[m[32m    <InstallationTarget Version="[14.0,]" Id="Microsoft.VisualStudio.VSWinExpress" />[m
[32m+[m[32m  </Installation>[m
[32m+[m[32m  <Dependencies>[m
[32m+[m[32m    <Dependency Id="Microsoft.Framework.NDP" DisplayName="Microsoft .NET Framework" d:Source="Manual" Version="[4.5,)" />[m
[32m+[m[32m  </Dependencies>[m
[32m+[m[32m  <Assets>[m
[32m+[m[32m    <Asset Type="Microsoft.VisualStudio.MefComponent" d:Source="Project" d:ProjectName="NewAnalyzerTemplate" Path="|NewAnalyzerTemplate|"/>[m
[32m+[m[32m    <Asset Type="Microsoft.VisualStudio.Analyzer" d:Source="Project" d:ProjectName="NewAnalyzerTemplate" Path="|NewAnalyzerTemplate|"/>[m
[32m+[m[32m  </Assets>[m
[32m+[m[32m</PackageManifest>[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/CodeFixProvider.cs b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/CodeFixProvider.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..49c1258[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/CodeFixProvider.cs[m
[36m@@ -0,0 +1,34 @@[m
[32m+[m[32m﻿using System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Collections.Immutable;[m
[32m+[m[32musing System.Composition;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m[32musing System.Threading.Tasks;[m
[32m+[m[32musing Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeFixes;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeActions;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Rename;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Text;[m
[32m+[m
[32m+[m[32mnamespace NewAnalyzerTemplate[m
[32m+[m[32m{[m
[32m+[m[32m    [ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(NewAnalyzerTemplateCodeFixProvider)), Shared][m
[32m+[m[32m    public class NewAnalyzerTemplateCodeFixProvider : CodeFixProvider[m
[32m+[m[32m    {[m
[32m+[m[32m        public override ImmutableArray<string> FixableDiagnosticIds[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new NotImplementedException();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public override Task RegisterCodeFixesAsync(CodeFixContext context)[m
[32m+[m[32m        {[m
[32m+[m[32m            throw new NotImplementedException();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/Diagnostic.nuspec b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/Diagnostic.nuspec[m
[1mnew file mode 100644[m
[1mindex 0000000..3032b95[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/Diagnostic.nuspec[m
[36m@@ -0,0 +1,25 @@[m
[32m+[m[32m﻿<?xml version="1.0"?>[m
[32m+[m[32m<package xmlns="http://schemas.microsoft.com/packaging/2011/08/nuspec.xsd">[m
[32m+[m[32m  <metadata>[m
[32m+[m[32m    <id>NewAnalyzerTemplate</id>[m
[32m+[m[32m    <version>1.0.0.0</version>[m
[32m+[m[32m    <title>NewAnalyzerTemplate</title>[m
[32m+[m[32m    <authors>NewAnalyzerTemplate</authors>[m
[32m+[m[32m    <owners>NewAnalyzerTemplate</owners>[m
[32m+[m[32m    <licenseUrl>http://LICENSE_URL_HERE_OR_DELETE_THIS_LINE</licenseUrl>[m
[32m+[m[32m    <projectUrl>http://PROJECT_URL_HERE_OR_DELETE_THIS_LINE</projectUrl>[m
[32m+[m[32m    <iconUrl>http://ICON_URL_HERE_OR_DELETE_THIS_LINE</iconUrl>[m
[32m+[m[32m    <requireLicenseAcceptance>false</requireLicenseAcceptance>[m
[32m+[m[32m    <description>NewAnalyzerTemplate</description>[m
[32m+[m[32m    <releaseNotes>Summary of changes made in this release of the package.</releaseNotes>[m
[32m+[m[32m    <copyright>Copyright</copyright>[m
[32m+[m[32m    <tags>NewAnalyzerTemplate, analyzers</tags>[m
[32m+[m[32m    <frameworkAssemblies>[m
[32m+[m[32m      <frameworkAssembly assemblyName="System" targetFramework="" />[m
[32m+[m[32m    </frameworkAssemblies>[m
[32m+[m[32m  </metadata>[m
[32m+[m[32m  <files>[m
[32m+[m[32m    <file src="*.dll" target="tools\analyzers\" exclude="**\Microsoft.CodeAnalysis.*;**\System.Collections.Immutable.*;**\System.Reflection.Metadata.*" />[m
[32m+[m[32m    <file src="tools\*.ps1" target="tools\" />[m
[32m+[m[32m  </files>[m
[32m+[m[32m</package>[m
\ No newline at end of file[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/DiagnosticAnalyzer.cs b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/DiagnosticAnalyzer.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..35b74d5[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/DiagnosticAnalyzer.cs[m
[36m@@ -0,0 +1,29 @@[m
[32m+[m[32musing System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Collections.Immutable;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m[32musing Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m
[32m+[m[32mnamespace NewAnalyzerTemplate[m
[32m+[m[32m{[m
[32m+[m[32m    [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[32m+[m[32m    public class NewAnalyzerTemplateAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m    {[m
[32m+[m[32m        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new NotImplementedException();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public override void Initialize(AnalysisContext context)[m
[32m+[m[32m        {[m
[32m+[m[41m            [m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.csproj b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.csproj[m
[1mnew file mode 100644[m
[1mindex 0000000..5fac347[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate.csproj[m
[36m@@ -0,0 +1,126 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">[m
[32m+[m[32m  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <MinimumVisualStudioVersion>11.0</MinimumVisualStudioVersion>[m
[32m+[m[32m    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>[m
[32m+[m[32m    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>[m
[32m+[m[32m    <ProjectGuid>{702DD21D-86CF-4222-94E3-FC008A2B3423}</ProjectGuid>[m
[32m+[m[32m    <OutputType>Library</OutputType>[m
[32m+[m[32m    <AppDesignerFolder>Properties</AppDesignerFolder>[m
[32m+[m[32m    <RootNamespace>NewAnalyzerTemplate</RootNamespace>[m
[32m+[m[32m    <AssemblyName>NewAnalyzerTemplate</AssemblyName>[m
[32m+[m[32m    <ProjectTypeGuids>{786C830F-07A1-408B-BD7F-6EE04809D6DB};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>[m
[32m+[m[32m    <TargetFrameworkProfile>Profile7</TargetFrameworkProfile>[m
[32m+[m[32m    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">[m
[32m+[m[32m    <DebugSymbols>true</DebugSymbols>[m
[32m+[m[32m    <DebugType>full</DebugType>[m
[32m+[m[32m    <Optimize>false</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Debug\</OutputPath>[m
[32m+[m[32m    <DefineConstants>DEBUG;TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">[m
[32m+[m[32m    <DebugType>pdbonly</DebugType>[m
[32m+[m[32m    <Optimize>true</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Release\</OutputPath>[m
[32m+[m[32m    <DefineConstants>TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Compile Include="CodeFixProvider.cs" />[m
[32m+[m[32m    <Compile Include="DiagnosticAnalyzer.cs" />[m
[32m+[m[32m    <Compile Include="Properties\AssemblyInfo.cs" />[m
[32m+[m[32m    <Compile Include="Resources.Designer.cs">[m
[32m+[m[32m      <AutoGen>True</AutoGen>[m
[32m+[m[32m      <DesignTime>True</DesignTime>[m
[32m+[m[32m      <DependentUpon>Resources.resx</DependentUpon>[m
[32m+[m[32m    </Compile>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <EmbeddedResource Include="Resources.resx">[m
[32m+[m[32m      <Generator>ResXFileCodeGenerator</Generator>[m
[32m+[m[32m      <LastGenOutput>Resources.Designer.cs</LastGenOutput>[m
[32m+[m[32m    </EmbeddedResource>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <None Include="Diagnostic.nuspec">[m
[32m+[m[32m      <SubType>Designer</SubType>[m
[32m+[m[32m      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>[m
[32m+[m[32m    </None>[m
[32m+[m[32m    <None Include="packages.config" />[m
[32m+[m[32m    <None Include="tools\install.ps1">[m
[32m+[m[32m      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>[m
[32m+[m[32m    </None>[m
[32m+[m[32m    <None Include="tools\uninstall.ps1">[m
[32m+[m[32m      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>[m
[32m+[m[32m    </None>[m
[32m+[m[32m    <None Include="ReadMe.txt" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Analyzer Include="..\..\packages\Microsoft.CodeAnalysis.Analyzers.1.0.0-rc2\tools\analyzers\C#\Microsoft.CodeAnalysis.Analyzers.dll" />[m
[32m+[m[32m    <Analyzer Include="..\..\packages\Microsoft.CodeAnalysis.Analyzers.1.0.0-rc2\tools\analyzers\C#\Microsoft.CodeAnalysis.CSharp.Analyzers.dll" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Common.1.0.0-rc2\lib\portable-net45+win8\Microsoft.CodeAnalysis.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.1.0.0-rc2\lib\portable-net45+win8\Microsoft.CodeAnalysis.CSharp.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.Workspaces.1.0.0-rc2\lib\portable-net45+win8\Microsoft.CodeAnalysis.CSharp.Workspaces.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Workspaces.Common.1.0.0-rc2\lib\portable-net45+win8\Microsoft.CodeAnalysis.Workspaces.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Collections.Immutable, Version=1.1.33.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\System.Collections.Immutable.1.1.33-beta\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.AttributedModel, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.AttributedModel.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Convention, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Convention.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Hosting, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Hosting.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Runtime, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Runtime.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.TypedParts, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.TypedParts.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Reflection.Metadata, Version=1.0.18.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\System.Reflection.Metadata.1.0.18-beta\lib\portable-net45+win8\System.Reflection.Metadata.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <Import Project="$(MSBuildExtensionsPath32)\Microsoft\Portable\v4.6\Microsoft.Portable.CSharp.targets" />[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <PostBuildEvent>"$(SolutionDir)\packages\NuGet.CommandLine.2.8.2\tools\NuGet.exe" pack Diagnostic.nuspec -NoPackageAnalysis -OutputDirectory .</PostBuildEvent>[m
[32m+[m[32m    <RunPostBuildEvent>OnOutputUpdated</RunPostBuildEvent>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.[m[41m [m
[32m+[m[32m       Other similar extension points exist, see Microsoft.Common.targets.[m
[32m+[m[32m  <Target Name="BeforeBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  <Target Name="AfterBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  -->[m
[32m+[m[32m</Project>[m
\ No newline at end of file[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/Properties/AssemblyInfo.cs b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/Properties/AssemblyInfo.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..111a9fb[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/Properties/AssemblyInfo.cs[m
[36m@@ -0,0 +1,31 @@[m
[32m+[m[32m﻿using System.Reflection;[m
[32m+[m[32musing System.Runtime.InteropServices;[m
[32m+[m
[32m+[m[32m// General Information about an assembly is controlled through the following[m[41m [m
[32m+[m[32m// set of attributes. Change these attribute values to modify the information[m
[32m+[m[32m// associated with an assembly.[m
[32m+[m[32m[assembly: AssemblyTitle("NewAnalyzerTemplate")][m
[32m+[m[32m[assembly: AssemblyDescription("")][m
[32m+[m[32m[assembly: AssemblyConfiguration("")][m
[32m+[m[32m[assembly: AssemblyCompany("")][m
[32m+[m[32m[assembly: AssemblyProduct("NewAnalyzerTemplate")][m
[32m+[m[32m[assembly: AssemblyCopyright("Copyright ©  2015")][m
[32m+[m[32m[assembly: AssemblyTrademark("")][m
[32m+[m[32m[assembly: AssemblyCulture("")][m
[32m+[m
[32m+[m[32m// Setting ComVisible to false makes the types in this assembly not visible[m[41m [m
[32m+[m[32m// to COM components.  If you need to access a type in this assembly from[m[41m [m
[32m+[m[32m// COM, set the ComVisible attribute to true on that type.[m
[32m+[m[32m[assembly: ComVisible(false)][m
[32m+[m
[32m+[m[32m// Version information for an assembly consists of the following four values:[m
[32m+[m[32m//[m
[32m+[m[32m//      Major Version[m
[32m+[m[32m//      Minor Version[m[41m [m
[32m+[m[32m//      Build Number[m
[32m+[m[32m//      Revision[m
[32m+[m[32m//[m
[32m+[m[32m// You can specify all the values or you can default the Build and Revision Numbers[m[41m [m
[32m+[m[32m// by using the '*' as shown below:[m
[32m+[m[32m[assembly: AssemblyVersion("1.0.*")][m
[32m+[m[32m[assembly: AssemblyFileVersion("1.0.0.0")][m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/ReadMe.txt b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/ReadMe.txt[m
[1mnew file mode 100644[m
[1mindex 0000000..56da5d5[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/ReadMe.txt[m
[36m@@ -0,0 +1,5 @@[m
[32m+[m[32m﻿-more info on syntax trees, symbols, compilations, analyzers, possibly on the different options[m
[32m+[m[32m-basic instructions[m
[32m+[m[32m-make sure you read this[m
[32m+[m[32m-installing whatever packages are needed[m
[32m+[m[32m-instructions for debugging/writing using 2nd VS instance[m
\ No newline at end of file[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/Resources.Designer.cs b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/Resources.Designer.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..23502b8[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/Resources.Designer.cs[m
[36m@@ -0,0 +1,106 @@[m
[32m+[m[32m﻿//------------------------------------------------------------------------------[m
[32m+[m[32m// <auto-generated>[m
[32m+[m[32m//     This code was generated by a tool.[m
[32m+[m[32m//     Runtime Version:4.0.30319.0[m
[32m+[m[32m//[m
[32m+[m[32m//     Changes to this file may cause incorrect behavior and will be lost if[m
[32m+[m[32m//     the code is regenerated.[m
[32m+[m[32m// </auto-generated>[m
[32m+[m[32m//------------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mnamespace NewAnalyzerTemplate[m
[32m+[m[32m{[m
[32m+[m[32m    using System;[m
[32m+[m[32m    using System.Reflection;[m
[32m+[m
[32m+[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    ///   A strongly-typed resource class, for looking up localized strings, etc.[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    // This class was auto-generated by the StronglyTypedResourceBuilder[m
[32m+[m[32m    // class via a tool like ResGen or Visual Studio.[m
[32m+[m[32m    // To add or remove a member, edit your .ResX file then rerun ResGen[m
[32m+[m[32m    // with the /str option, or rebuild your VS project.[m
[32m+[m[32m    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")][m
[32m+[m[32m    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()][m
[32m+[m[32m    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()][m
[32m+[m[32m    internal class Resources[m
[32m+[m[32m    {[m
[32m+[m
[32m+[m[32m        private static global::System.Resources.ResourceManager resourceMan;[m
[32m+[m
[32m+[m[32m        private static global::System.Globalization.CultureInfo resourceCulture;[m
[32m+[m
[32m+[m[32m        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")][m
[32m+[m[32m        internal Resources()[m
[32m+[m[32m        {[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        ///   Returns the cached ResourceManager instance used by this class.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)][m
[32m+[m[32m        internal static global::System.Resources.ResourceManager ResourceManager[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                if (object.ReferenceEquals(resourceMan, null))[m
[32m+[m[32m                {[m
[32m+[m[32m                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("NewAnalyzerTemplate.Resources", typeof(Resources).GetTypeInfo().Assembly);[m
[32m+[m[32m                    resourceMan = temp;[m
[32m+[m[32m                }[m
[32m+[m[32m                return resourceMan;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        ///   Overrides the current thread's CurrentUICulture property for all[m
[32m+[m[32m        ///   resource lookups using this strongly typed resource class.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)][m
[32m+[m[32m        internal static global::System.Globalization.CultureInfo Culture[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return resourceCulture;[m
[32m+[m[32m            }[m
[32m+[m[32m            set[m
[32m+[m[32m            {[m
[32m+[m[32m                resourceCulture = value;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        ///   Looks up a localized string similar to Type names should be all uppercase..[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        internal static string AnalyzerDescription[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return ResourceManager.GetString("AnalyzerDescription", resourceCulture);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        ///   Looks up a localized string similar to Type name &apos;{0}&apos; contains lowercase letters.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        internal static string AnalyzerMessageFormat[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return ResourceManager.GetString("AnalyzerMessageFormat", resourceCulture);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        ///   Looks up a localized string similar to Type name contains lowercase letters.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        internal static string AnalyzerTitle[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return ResourceManager.GetString("AnalyzerTitle", resourceCulture);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/Resources.resx b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/Resources.resx[m
[1mnew file mode 100644[m
[1mindex 0000000..c97ee9b[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/Resources.resx[m
[36m@@ -0,0 +1,132 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<root>[m
[32m+[m[32m  <!--[m[41m [m
[32m+[m[32m    Microsoft ResX Schema[m[41m [m
[32m+[m[41m    [m
[32m+[m[32m    Version 2.0[m
[32m+[m[41m    [m
[32m+[m[32m    The primary goals of this format is to allow a simple XML format[m[41m [m
[32m+[m[32m    that is mostly human readable. The generation and parsing of the[m[41m [m
[32m+[m[32m    various data types are done through the TypeConverter classes[m[41m [m
[32m+[m[32m    associated with the data types.[m
[32m+[m[41m    [m
[32m+[m[32m    Example:[m
[32m+[m[41m    [m
[32m+[m[32m    ... ado.net/XML headers & schema ...[m
[32m+[m[32m    <resheader name="resmimetype">text/microsoft-resx</resheader>[m
[32m+[m[32m    <resheader name="version">2.0</resheader>[m
[32m+[m[32m    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>[m
[32m+[m[32m    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>[m
[32m+[m[32m    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>[m
[32m+[m[32m    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>[m
[32m+[m[32m    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">[m
[32m+[m[32m        <value>[base64 mime encoded serialized .NET Framework object]</value>[m
[32m+[m[32m    </data>[m
[32m+[m[32m    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">[m
[32m+[m[32m        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>[m
[32m+[m[32m        <comment>This is a comment</comment>[m
[32m+[m[32m    </data>[m
[32m+[m[41m                [m
[32m+[m[32m    There are any number of "resheader" rows that contain simple[m[41m [m
[32m+[m[32m    name/value pairs.[m
[32m+[m[41m    [m
[32m+[m[32m    Each data row contains a name, and value. The row also contains a[m[41m [m
[32m+[m[32m    type or mimetype. Type corresponds to a .NET class that support[m[41m [m
[32m+[m[32m    text/value conversion through the TypeConverter architecture.[m[41m [m
[32m+[m[32m    Classes that don't support this are serialized and stored with the[m[41m [m
[32m+[m[32m    mimetype set.[m
[32m+[m[41m    [m
[32m+[m[32m    The mimetype is used for serialized objects, and tells the[m[41m [m
[32m+[m[32m    ResXResourceReader how to depersist the object. This is currently not[m[41m [m
[32m+[m[32m    extensible. For a given mimetype the value must be set accordingly:[m
[32m+[m[41m    [m
[32m+[m[32m    Note - application/x-microsoft.net.object.binary.base64 is the format[m[41m [m
[32m+[m[32m    that the ResXResourceWriter will generate, however the reader can[m[41m [m
[32m+[m[32m    read any of the formats listed below.[m
[32m+[m[41m    [m
[32m+[m[32m    mimetype: application/x-microsoft.net.object.binary.base64[m
[32m+[m[32m    value   : The object must be serialized with[m[41m [m
[32m+[m[32m            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter[m
[32m+[m[32m            : and then encoded with base64 encoding.[m
[32m+[m[41m    [m
[32m+[m[32m    mimetype: application/x-microsoft.net.object.soap.base64[m
[32m+[m[32m    value   : The object must be serialized with[m[41m [m
[32m+[m[32m            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter[m
[32m+[m[32m            : and then encoded with base64 encoding.[m
[32m+[m
[32m+[m[32m    mimetype: application/x-microsoft.net.object.bytearray.base64[m
[32m+[m[32m    value   : The object must be serialized into a byte array[m[41m [m
[32m+[m[32m            : using a System.ComponentModel.TypeConverter[m
[32m+[m[32m            : and then encoded with base64 encoding.[m
[32m+[m[32m    -->[m
[32m+[m[32m  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">[m
[32m+[m[32m    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />[m
[32m+[m[32m    <xsd:element name="root" msdata:IsDataSet="true">[m
[32m+[m[32m      <xsd:complexType>[m
[32m+[m[32m        <xsd:choice maxOccurs="unbounded">[m
[32m+[m[32m          <xsd:element name="metadata">[m
[32m+[m[32m            <xsd:complexType>[m
[32m+[m[32m              <xsd:sequence>[m
[32m+[m[32m                <xsd:element name="value" type="xsd:string" minOccurs="0" />[m
[32m+[m[32m              </xsd:sequence>[m
[32m+[m[32m              <xsd:attribute name="name" use="required" type="xsd:string" />[m
[32m+[m[32m              <xsd:attribute name="type" type="xsd:string" />[m
[32m+[m[32m              <xsd:attribute name="mimetype" type="xsd:string" />[m
[32m+[m[32m              <xsd:attribute ref="xml:space" />[m
[32m+[m[32m            </xsd:complexType>[m
[32m+[m[32m          </xsd:element>[m
[32m+[m[32m          <xsd:element name="assembly">[m
[32m+[m[32m            <xsd:complexType>[m
[32m+[m[32m              <xsd:attribute name="alias" type="xsd:string" />[m
[32m+[m[32m              <xsd:attribute name="name" type="xsd:string" />[m
[32m+[m[32m            </xsd:complexType>[m
[32m+[m[32m          </xsd:element>[m
[32m+[m[32m          <xsd:element name="data">[m
[32m+[m[32m            <xsd:complexType>[m
[32m+[m[32m              <xsd:sequence>[m
[32m+[m[32m                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />[m
[32m+[m[32m                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />[m
[32m+[m[32m              </xsd:sequence>[m
[32m+[m[32m              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />[m
[32m+[m[32m              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />[m
[32m+[m[32m              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />[m
[32m+[m[32m              <xsd:attribute ref="xml:space" />[m
[32m+[m[32m            </xsd:complexType>[m
[32m+[m[32m          </xsd:element>[m
[32m+[m[32m          <xsd:element name="resheader">[m
[32m+[m[32m            <xsd:complexType>[m
[32m+[m[32m              <xsd:sequence>[m
[32m+[m[32m                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />[m
[32m+[m[32m              </xsd:sequence>[m
[32m+[m[32m              <xsd:attribute name="name" type="xsd:string" use="required" />[m
[32m+[m[32m            </xsd:complexType>[m
[32m+[m[32m          </xsd:element>[m
[32m+[m[32m        </xsd:choice>[m
[32m+[m[32m      </xsd:complexType>[m
[32m+[m[32m    </xsd:element>[m
[32m+[m[32m  </xsd:schema>[m
[32m+[m[32m  <resheader name="resmimetype">[m
[32m+[m[32m    <value>text/microsoft-resx</value>[m
[32m+[m[32m  </resheader>[m
[32m+[m[32m  <resheader name="version">[m
[32m+[m[32m    <value>2.0</value>[m
[32m+[m[32m  </resheader>[m
[32m+[m[32m  <resheader name="reader">[m
[32m+[m[32m    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>[m
[32m+[m[32m  </resheader>[m
[32m+[m[32m  <resheader name="writer">[m
[32m+[m[32m    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>[m
[32m+[m[32m  </resheader>[m
[32m+[m[32m  <data name="AnalyzerDescription" xml:space="preserve">[m
[32m+[m[32m    <value>Type names should be all uppercase.</value>[m
[32m+[m[32m    <comment>An optional longer localizable description of the diagnostic.</comment>[m
[32m+[m[32m  </data>[m
[32m+[m[32m  <data name="AnalyzerMessageFormat" xml:space="preserve">[m
[32m+[m[32m    <value>Type name '{0}' contains lowercase letters</value>[m
[32m+[m[32m    <comment>The format-able message the diagnostic displays.</comment>[m
[32m+[m[32m  </data>[m
[32m+[m[32m  <data name="AnalyzerTitle" xml:space="preserve">[m
[32m+[m[32m    <value>Type name contains lowercase letters</value>[m
[32m+[m[32m    <comment>The title of the diagnostic.</comment>[m
[32m+[m[32m  </data>[m
[32m+[m[32m</root>[m
\ No newline at end of file[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/packages.config b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/packages.config[m
[1mnew file mode 100644[m
[1mindex 0000000..ec9b94c[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/packages.config[m
[36m@@ -0,0 +1,12 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<packages>[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.Analyzers" version="1.0.0-rc2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.Common" version="1.0.0-rc2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.CSharp" version="1.0.0-rc2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.CSharp.Workspaces" version="1.0.0-rc2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.Workspaces.Common" version="1.0.0-rc2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.Composition" version="1.0.27" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="NuGet.CommandLine" version="2.8.2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="System.Collections.Immutable" version="1.1.33-beta" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="System.Reflection.Metadata" version="1.0.18-beta" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m</packages>[m
\ No newline at end of file[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/tools/install.ps1 b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/tools/install.ps1[m
[1mnew file mode 100644[m
[1mindex 0000000..6a2b94d[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/tools/install.ps1[m
[36m@@ -0,0 +1,24 @@[m
[32m+[m[32m﻿param($installPath, $toolsPath, $package, $project)[m
[32m+[m
[32m+[m[32m$analyzersPath = join-path $toolsPath "analyzers"[m
[32m+[m
[32m+[m[32m# Install the language agnostic analyzers.[m
[32m+[m[32mforeach ($analyzerFilePath in Get-ChildItem $analyzersPath -Filter *.dll)[m
[32m+[m[32m{[m
[32m+[m[32m    if($project.Object.AnalyzerReferences)[m
[32m+[m[32m    {[m
[32m+[m[32m        $project.Object.AnalyzerReferences.Add($analyzerFilePath.FullName)[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m# Install language specific analyzers.[m
[32m+[m[32m# $project.Type gives the language name like (C# or VB.NET)[m
[32m+[m[32m$languageAnalyzersPath = join-path $analyzersPath $project.Type[m
[32m+[m
[32m+[m[32mforeach ($analyzerFilePath in Get-ChildItem $languageAnalyzersPath -Filter *.dll)[m
[32m+[m[32m{[m
[32m+[m[32m    if($project.Object.AnalyzerReferences)[m
[32m+[m[32m    {[m
[32m+[m[32m        $project.Object.AnalyzerReferences.Add($analyzerFilePath.FullName)[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/tools/uninstall.ps1 b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/tools/uninstall.ps1[m
[1mnew file mode 100644[m
[1mindex 0000000..de0016c[m
[1m--- /dev/null[m
[1m+++ b/NewAnalyzerTemplate/NewAnalyzerTemplate/NewAnalyzerTemplate/tools/uninstall.ps1[m
[36m@@ -0,0 +1,24 @@[m
[32m+[m[32m﻿param($installPath, $toolsPath, $package, $project)[m
[32m+[m
[32m+[m[32m# Uninstall the language agnostic analyzers.[m
[32m+[m[32m$analyzersPath = join-path $toolsPath "analyzers"[m
[32m+[m
[32m+[m[32mforeach ($analyzerFilePath in Get-ChildItem $analyzersPath -Filter *.dll)[m
[32m+[m[32m{[m
[32m+[m[32m    if($project.Object.AnalyzerReferences)[m
[32m+[m[32m    {[m
[32m+[m[32m        $project.Object.AnalyzerReferences.Remove($analyzerFilePath.FullName)[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m# Uninstall language specific analyzers.[m
[32m+[m[32m# $project.Type gives the language name like (C# or VB.NET)[m
[32m+[m[32m$languageAnalyzersPath = join-path $analyzersPath $project.Type[m
[32m+[m
[32m+[m[32mforeach ($analyzerFilePath in Get-ChildItem $languageAnalyzersPath -Filter *.dll)[m
[32m+[m[32m{[m
[32m+[m[32m    if($project.Object.AnalyzerReferences)[m
[32m+[m[32m    {[m
[32m+[m[32m        $project.Object.AnalyzerReferences.Remove($analyzerFilePath.FullName)[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.sln b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.sln[m
[1mnew file mode 100644[m
[1mindex 0000000..7fe2e00[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.sln[m
[36m@@ -0,0 +1,34 @@[m
[32m+[m[32m﻿[m
[32m+[m[32mMicrosoft Visual Studio Solution File, Format Version 12.00[m
[32m+[m[32m# Visual Studio 14[m
[32m+[m[32mVisualStudioVersion = 14.0.22823.1[m
[32m+[m[32mMinimumVisualStudioVersion = 10.0.40219.1[m
[32m+[m[32mProject("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "SyntaxNodeAnalyzer", "SyntaxNodeAnalyzer\SyntaxNodeAnalyzer\SyntaxNodeAnalyzer.csproj", "{2D370822-C5D4-49BB-ADB5-15916A1AB229}"[m
[32m+[m[32mEndProject[m
[32m+[m[32mProject("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "SyntaxNodeAnalyzer.Test", "SyntaxNodeAnalyzer\SyntaxNodeAnalyzer.Test\SyntaxNodeAnalyzer.Test.csproj", "{F72FFEC7-640A-4F39-BD70-71EC8181DA04}"[m
[32m+[m[32mEndProject[m
[32m+[m[32mProject("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "SyntaxNodeAnalyzer.Vsix", "SyntaxNodeAnalyzer\SyntaxNodeAnalyzer.Vsix\SyntaxNodeAnalyzer.Vsix.csproj", "{4FF4DFA1-B646-481E-8C5B-52BD1DEA23BC}"[m
[32m+[m[32mEndProject[m
[32m+[m[32mGlobal[m
[32m+[m	[32mGlobalSection(SolutionConfigurationPlatforms) = preSolution[m
[32m+[m		[32mDebug|Any CPU = Debug|Any CPU[m
[32m+[m		[32mRelease|Any CPU = Release|Any CPU[m
[32m+[m	[32mEndGlobalSection[m
[32m+[m	[32mGlobalSection(ProjectConfigurationPlatforms) = postSolution[m
[32m+[m		[32m{2D370822-C5D4-49BB-ADB5-15916A1AB229}.Debug|Any CPU.ActiveCfg = Debug|Any CPU[m
[32m+[m		[32m{2D370822-C5D4-49BB-ADB5-15916A1AB229}.Debug|Any CPU.Build.0 = Debug|Any CPU[m
[32m+[m		[32m{2D370822-C5D4-49BB-ADB5-15916A1AB229}.Release|Any CPU.ActiveCfg = Release|Any CPU[m
[32m+[m		[32m{2D370822-C5D4-49BB-ADB5-15916A1AB229}.Release|Any CPU.Build.0 = Release|Any CPU[m
[32m+[m		[32m{F72FFEC7-640A-4F39-BD70-71EC8181DA04}.Debug|Any CPU.ActiveCfg = Debug|Any CPU[m
[32m+[m		[32m{F72FFEC7-640A-4F39-BD70-71EC8181DA04}.Debug|Any CPU.Build.0 = Debug|Any CPU[m
[32m+[m		[32m{F72FFEC7-640A-4F39-BD70-71EC8181DA04}.Release|Any CPU.ActiveCfg = Release|Any CPU[m
[32m+[m		[32m{F72FFEC7-640A-4F39-BD70-71EC8181DA04}.Release|Any CPU.Build.0 = Release|Any CPU[m
[32m+[m		[32m{4FF4DFA1-B646-481E-8C5B-52BD1DEA23BC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU[m
[32m+[m		[32m{4FF4DFA1-B646-481E-8C5B-52BD1DEA23BC}.Debug|Any CPU.Build.0 = Debug|Any CPU[m
[32m+[m		[32m{4FF4DFA1-B646-481E-8C5B-52BD1DEA23BC}.Release|Any CPU.ActiveCfg = Release|Any CPU[m
[32m+[m		[32m{4FF4DFA1-B646-481E-8C5B-52BD1DEA23BC}.Release|Any CPU.Build.0 = Release|Any CPU[m
[32m+[m	[32mEndGlobalSection[m
[32m+[m	[32mGlobalSection(SolutionProperties) = preSolution[m
[32m+[m		[32mHideSolutionNode = FALSE[m
[32m+[m	[32mEndGlobalSection[m
[32m+[m[32mEndGlobal[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Helpers/CodeFixVerifier.Helper.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Helpers/CodeFixVerifier.Helper.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..0f73d06[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Helpers/CodeFixVerifier.Helper.cs[m
[36m@@ -0,0 +1,85 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeActions;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Formatting;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Simplification;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m
[32m+[m[32mnamespace TestHelper[m
[32m+[m[32m{[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Diagnostic Producer class with extra methods dealing with applying codefixes[m
[32m+[m[32m    /// All methods are static[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public abstract partial class CodeFixVerifier : DiagnosticVerifier[m
[32m+[m[32m    {[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Apply the inputted CodeAction to the inputted document.[m
[32m+[m[32m        /// Meant to be used to apply codefixes.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="document">The Document to apply the fix on</param>[m
[32m+[m[32m        /// <param name="codeAction">A CodeAction that will be applied to the Document.</param>[m
[32m+[m[32m        /// <returns>A Document with the changes from the CodeAction</returns>[m
[32m+[m[32m        private static Document ApplyFix(Document document, CodeAction codeAction)[m
[32m+[m[32m        {[m
[32m+[m[32m            var operations = codeAction.GetOperationsAsync(CancellationToken.None).Result;[m
[32m+[m[32m            var solution = operations.OfType<ApplyChangesOperation>().Single().ChangedSolution;[m
[32m+[m[32m            return solution.GetDocument(document.Id);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Compare two collections of Diagnostics,and return a list of any new diagnostics that appear only in the second collection.[m
[32m+[m[32m        /// Note: Considers Diagnostics to be the same if they have the same Ids.  In the case of multiple diagnostics with the same Id in a row,[m
[32m+[m[32m        /// this method may not necessarily return the new one.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="diagnostics">The Diagnostics that existed in the code before the CodeFix was applied</param>[m
[32m+[m[32m        /// <param name="newDiagnostics">The Diagnostics that exist in the code after the CodeFix was applied</param>[m
[32m+[m[32m        /// <returns>A list of Diagnostics that only surfaced in the code after the CodeFix was applied</returns>[m
[32m+[m[32m        private static IEnumerable<Diagnostic> GetNewDiagnostics(IEnumerable<Diagnostic> diagnostics, IEnumerable<Diagnostic> newDiagnostics)[m
[32m+[m[32m        {[m
[32m+[m[32m            var oldArray = diagnostics.OrderBy(d => d.Location.SourceSpan.Start).ToArray();[m
[32m+[m[32m            var newArray = newDiagnostics.OrderBy(d => d.Location.SourceSpan.Start).ToArray();[m
[32m+[m
[32m+[m[32m            int oldIndex = 0;[m
[32m+[m[32m            int newIndex = 0;[m
[32m+[m
[32m+[m[32m            while (newIndex < newArray.Length)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (oldIndex < oldArray.Length && oldArray[oldIndex].Id == newArray[newIndex].Id)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ++oldIndex;[m
[32m+[m[32m                    ++newIndex;[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    yield return newArray[newIndex++];[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Get the existing compiler diagnostics on the inputted document.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="document">The Document to run the compiler diagnostic analyzers on</param>[m
[32m+[m[32m        /// <returns>The compiler diagnostics that were found in the code</returns>[m
[32m+[m[32m        private static IEnumerable<Diagnostic> GetCompilerDiagnostics(Document document)[m
[32m+[m[32m        {[m
[32m+[m[32m            return document.GetSemanticModelAsync().Result.GetDiagnostics();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Given a document, turn it into a string based on the syntax root[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="document">The Document to be converted to a string</param>[m
[32m+[m[32m        /// <returns>A string containing the syntax of the Document after formatting</returns>[m
[32m+[m[32m        private static string GetStringFromDocument(Document document)[m
[32m+[m[32m        {[m
[32m+[m[32m            var simplifiedDoc = Simplifier.ReduceAsync(document, Simplifier.Annotation).Result;[m
[32m+[m[32m            var root = simplifiedDoc.GetSyntaxRootAsync().Result;[m
[32m+[m[32m            root = Formatter.Format(root, Formatter.Annotation, simplifiedDoc.Project.Solution.Workspace);[m
[32m+[m[32m            return root.GetText().ToString();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Helpers/DiagnosticResult.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Helpers/DiagnosticResult.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..5958a4d[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Helpers/DiagnosticResult.cs[m
[36m@@ -0,0 +1,86 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing System;[m
[32m+[m
[32m+[m[32mnamespace TestHelper[m
[32m+[m[32m{[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Location where the diagnostic appears, as determined by path, line number, and column number.[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public struct DiagnosticResultLocation[m
[32m+[m[32m    {[m
[32m+[m[32m        public DiagnosticResultLocation(string path, int line, int column)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (line < 0 && column < 0)[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new ArgumentOutOfRangeException("At least one of line and column must be > 0");[m
[32m+[m[32m            }[m
[32m+[m[32m            if (line < -1 || column < -1)[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new ArgumentOutOfRangeException("Both line and column must be >= -1");[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            this.Path = path;[m
[32m+[m[32m            this.Line = line;[m
[32m+[m[32m            this.Column = column;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public string Path;[m
[32m+[m[32m        public int Line;[m
[32m+[m[32m        public int Column;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Struct that stores information about a Diagnostic appearing in a source[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public struct DiagnosticResult[m
[32m+[m[32m    {[m
[32m+[m[32m        private DiagnosticResultLocation[] locations;[m
[32m+[m
[32m+[m[32m        public DiagnosticResultLocation[] Locations[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                if (this.locations == null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    this.locations = new DiagnosticResultLocation[] { };[m
[32m+[m[32m                }[m
[32m+[m[32m                return this.locations;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            set[m
[32m+[m[32m            {[m
[32m+[m[32m                this.locations = value;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public DiagnosticSeverity Severity { get; set; }[m
[32m+[m
[32m+[m[32m        public string Id { get; set; }[m
[32m+[m
[32m+[m[32m        public string Message { get; set; }[m
[32m+[m
[32m+[m[32m        public string Path[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return this.Locations.Length > 0 ? this.Locations[0].Path : "";[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public int Line[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return this.Locations.Length > 0 ? this.Locations[0].Line : -1;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public int Column[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return this.Locations.Length > 0 ? this.Locations[0].Column : -1;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Helpers/DiagnosticVerifier.Helper.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Helpers/DiagnosticVerifier.Helper.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..12b93c2[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Helpers/DiagnosticVerifier.Helper.cs[m
[36m@@ -0,0 +1,179 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Text;[m
[32m+[m[32musing System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Collections.Immutable;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m
[32m+[m[32mnamespace TestHelper[m
[32m+[m[32m{[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Class for turning strings into documents and getting the diagnostics on them[m
[32m+[m[32m    /// All methods are static[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public abstract partial class DiagnosticVerifier[m
[32m+[m[32m    {[m
[32m+[m[32m        private static readonly MetadataReference CorlibReference = MetadataReference.CreateFromAssembly(typeof(object).Assembly);[m
[32m+[m[32m        private static readonly MetadataReference SystemCoreReference = MetadataReference.CreateFromAssembly(typeof(Enumerable).Assembly);[m
[32m+[m[32m        private static readonly MetadataReference CSharpSymbolsReference = MetadataReference.CreateFromAssembly(typeof(CSharpCompilation).Assembly);[m
[32m+[m[32m        private static readonly MetadataReference CodeAnalysisReference = MetadataReference.CreateFromAssembly(typeof(Compilation).Assembly);[m
[32m+[m
[32m+[m[32m        internal static string DefaultFilePathPrefix = "Test";[m
[32m+[m[32m        internal static string CSharpDefaultFileExt = "cs";[m
[32m+[m[32m        internal static string VisualBasicDefaultExt = "vb";[m
[32m+[m[32m        internal static string CSharpDefaultFilePath = DefaultFilePathPrefix + 0 + "." + CSharpDefaultFileExt;[m
[32m+[m[32m        internal static string VisualBasicDefaultFilePath = DefaultFilePathPrefix + 0 + "." + VisualBasicDefaultExt;[m
[32m+[m[32m        internal static string TestProjectName = "TestProject";[m
[32m+[m
[32m+[m[32m        #region  Get Diagnostics[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Given classes in the form of strings, their language, and an IDiagnosticAnlayzer to apply to it, return the diagnostics found in the string after converting it to a document.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">Classes in the form of strings</param>[m
[32m+[m[32m        /// <param name="language">The language the source classes are in</param>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer to be run on the sources</param>[m
[32m+[m[32m        /// <returns>An IEnumerable of Diagnostics that surfaced in the source code, sorted by Location</returns>[m
[32m+[m[32m        private static Diagnostic[] GetSortedDiagnostics(string[] sources, string language, DiagnosticAnalyzer analyzer)[m
[32m+[m[32m        {[m
[32m+[m[32m            return GetSortedDiagnosticsFromDocuments(analyzer, GetDocuments(sources, language));[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Given an analyzer and a document to apply it to, run the analyzer and gather an array of diagnostics found in it.[m
[32m+[m[32m        /// The returned diagnostics are then ordered by location in the source document.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer to run on the documents</param>[m
[32m+[m[32m        /// <param name="documents">The Documents that the analyzer will be run on</param>[m
[32m+[m[32m        /// <param name="spans">Optional TextSpan indicating where a Diagnostic will be found</param>[m
[32m+[m[32m        /// <returns>An IEnumerable of Diagnostics that surfaced in the source code, sorted by Location</returns>[m
[32m+[m[32m        protected static Diagnostic[] GetSortedDiagnosticsFromDocuments(DiagnosticAnalyzer analyzer, Document[] documents)[m
[32m+[m[32m        {[m
[32m+[m[32m            var projects = new HashSet<Project>();[m
[32m+[m[32m            foreach (var document in documents)[m
[32m+[m[32m            {[m
[32m+[m[32m                projects.Add(document.Project);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            var diagnostics = new List<Diagnostic>();[m
[32m+[m[32m            foreach (var project in projects)[m
[32m+[m[32m            {[m
[32m+[m[32m                var compilationWithAnalyzers = project.GetCompilationAsync().Result.WithAnalyzers(ImmutableArray.Create(analyzer));[m
[32m+[m[32m                var diags = compilationWithAnalyzers.GetAnalyzerDiagnosticsAsync().Result;[m
[32m+[m[32m                foreach (var diag in diags)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (diag.Location == Location.None || diag.Location.IsInMetadata)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        diagnostics.Add(diag);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else[m
[32m+[m[32m                    {[m
[32m+[m[32m                        for (int i = 0; i < documents.Length; i++)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            var document = documents[i];[m
[32m+[m[32m                            var tree = document.GetSyntaxTreeAsync().Result;[m
[32m+[m[32m                            if (tree == diag.Location.SourceTree)[m
[32m+[m[32m                            {[m
[32m+[m[32m                                diagnostics.Add(diag);[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            var results = SortDiagnostics(diagnostics);[m
[32m+[m[32m            diagnostics.Clear();[m
[32m+[m[32m            return results;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Sort diagnostics by location in source document[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="diagnostics">The list of Diagnostics to be sorted</param>[m
[32m+[m[32m        /// <returns>An IEnumerable containing the Diagnostics in order of Location</returns>[m
[32m+[m[32m        private static Diagnostic[] SortDiagnostics(IEnumerable<Diagnostic> diagnostics)[m
[32m+[m[32m        {[m
[32m+[m[32m            return diagnostics.OrderBy(d => d.Location.SourceSpan.Start).ToArray();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        #endregion[m
[32m+[m
[32m+[m[32m        #region Set up compilation and documents[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Given an array of strings as sources and a language, turn them into a project and return the documents and spans of it.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">Classes in the form of strings</param>[m
[32m+[m[32m        /// <param name="language">The language the source code is in</param>[m
[32m+[m[32m        /// <returns>A Tuple containing the Documents produced from the sources and their TextSpans if relevant</returns>[m
[32m+[m[32m        private static Document[] GetDocuments(string[] sources, string language)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (language != LanguageNames.CSharp && language != LanguageNames.VisualBasic)[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new ArgumentException("Unsupported Language");[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            for (int i = 0; i < sources.Length; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                string fileName = language == LanguageNames.CSharp ? "Test" + i + ".cs" : "Test" + i + ".vb";[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            var project = CreateProject(sources, language);[m
[32m+[m[32m            var documents = project.Documents.ToArray();[m
[32m+[m
[32m+[m[32m            if (sources.Length != documents.Length)[m
[32m+[m[32m            {[m
[32m+[m[32m                throw new SystemException("Amount of sources did not match amount of Documents created");[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            return documents;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Create a Document from a string through creating a project that contains it.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="source">Classes in the form of a string</param>[m
[32m+[m[32m        /// <param name="language">The language the source code is in</param>[m
[32m+[m[32m        /// <returns>A Document created from the source string</returns>[m
[32m+[m[32m        protected static Document CreateDocument(string source, string language = LanguageNames.CSharp)[m
[32m+[m[32m        {[m
[32m+[m[32m            return CreateProject(new[] { source }, language).Documents.First();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Create a project using the inputted strings as sources.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">Classes in the form of strings</param>[m
[32m+[m[32m        /// <param name="language">The language the source code is in</param>[m
[32m+[m[32m        /// <returns>A Project created out of the Documents created from the source strings</returns>[m
[32m+[m[32m        private static Project CreateProject(string[] sources, string language = LanguageNames.CSharp)[m
[32m+[m[32m        {[m
[32m+[m[32m            string fileNamePrefix = DefaultFilePathPrefix;[m
[32m+[m[32m            string fileExt = language == LanguageNames.CSharp ? CSharpDefaultFileExt : VisualBasicDefaultExt;[m
[32m+[m
[32m+[m[32m            var projectId = ProjectId.CreateNewId(debugName: TestProjectName);[m
[32m+[m
[32m+[m[32m            var solution = new AdhocWorkspace()[m
[32m+[m[32m                .CurrentSolution[m
[32m+[m[32m                .AddProject(projectId, TestProjectName, TestProjectName, language)[m
[32m+[m[32m                .AddMetadataReference(projectId, CorlibReference)[m
[32m+[m[32m                .AddMetadataReference(projectId, SystemCoreReference)[m
[32m+[m[32m                .AddMetadataReference(projectId, CSharpSymbolsReference)[m
[32m+[m[32m                .AddMetadataReference(projectId, CodeAnalysisReference);[m
[32m+[m
[32m+[m[32m            int count = 0;[m
[32m+[m[32m            foreach (var source in sources)[m
[32m+[m[32m            {[m
[32m+[m[32m                var newFileName = fileNamePrefix + count + "." + fileExt;[m
[32m+[m[32m                var documentId = DocumentId.CreateNewId(projectId, debugName: newFileName);[m
[32m+[m[32m                solution = solution.AddDocument(documentId, newFileName, SourceText.From(source));[m
[32m+[m[32m                count++;[m
[32m+[m[32m            }[m
[32m+[m[32m            return solution.GetProject(projectId);[m
[32m+[m[32m        }[m
[32m+[m[32m        #endregion[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Properties/AssemblyInfo.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Properties/AssemblyInfo.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..70ce4f9[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Properties/AssemblyInfo.cs[m
[36m@@ -0,0 +1,32 @@[m
[32m+[m[32m﻿using System.Reflection;[m
[32m+[m[32musing System.Runtime.InteropServices;[m
[32m+[m
[32m+[m[32m// General Information about an assembly is controlled through the following[m[41m [m
[32m+[m[32m// set of attributes. Change these attribute values to modify the information[m
[32m+[m[32m// associated with an assembly.[m
[32m+[m[32m[assembly: AssemblyTitle("SyntaxNodeAnalyzer.Test")][m
[32m+[m[32m[assembly: AssemblyDescription("")][m
[32m+[m[32m[assembly: AssemblyConfiguration("")][m
[32m+[m[32m[assembly: AssemblyCompany("")][m
[32m+[m[32m[assembly: AssemblyProduct("SyntaxNodeAnalyzer.Test")][m
[32m+[m[32m[assembly: AssemblyCopyright("Copyright ©  2015")][m
[32m+[m[32m[assembly: AssemblyTrademark("")][m
[32m+[m[32m[assembly: AssemblyCulture("")][m
[32m+[m
[32m+[m[32m// Setting ComVisible to false makes the types in this assembly not visible[m[41m [m
[32m+[m[32m// to COM components.  If you need to access a type in this assembly from[m[41m [m
[32m+[m[32m// COM, set the ComVisible attribute to true on that type.[m
[32m+[m[32m[assembly: ComVisible(false)][m
[32m+[m
[32m+[m[32m// Version information for an assembly consists of the following four values:[m
[32m+[m[32m//[m
[32m+[m[32m//      Major Version[m
[32m+[m[32m//      Minor Version[m[41m [m
[32m+[m[32m//      Build Number[m
[32m+[m[32m//      Revision[m
[32m+[m[32m//[m
[32m+[m[32m// You can specify all the values or you can default the Build and Revision Numbers[m[41m [m
[32m+[m[32m// by using the '*' as shown below:[m
[32m+[m[32m// [assembly: AssemblyVersion("1.0.*")][m
[32m+[m[32m[assembly: AssemblyVersion("1.0.0.0")][m
[32m+[m[32m[assembly: AssemblyFileVersion("1.0.0.0")][m
\ No newline at end of file[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/SyntaxNodeAnalyzer.Test.csproj b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/SyntaxNodeAnalyzer.Test.csproj[m
[1mnew file mode 100644[m
[1mindex 0000000..4c83ade[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/SyntaxNodeAnalyzer.Test.csproj[m
[36m@@ -0,0 +1,135 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>[m
[32m+[m[32m    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>[m
[32m+[m[32m    <ProductVersion>8.0.30703</ProductVersion>[m
[32m+[m[32m    <SchemaVersion>2.0</SchemaVersion>[m
[32m+[m[32m    <ProjectGuid>{F72FFEC7-640A-4F39-BD70-71EC8181DA04}</ProjectGuid>[m
[32m+[m[32m    <OutputType>Library</OutputType>[m
[32m+[m[32m    <AppDesignerFolder>Properties</AppDesignerFolder>[m
[32m+[m[32m    <RootNamespace>SyntaxNodeAnalyzer.Test</RootNamespace>[m
[32m+[m[32m    <AssemblyName>SyntaxNodeAnalyzer.Test</AssemblyName>[m
[32m+[m[32m    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>[m
[32m+[m[32m    <FileAlignment>512</FileAlignment>[m
[32m+[m[32m    <TargetFrameworkProfile />[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">[m
[32m+[m[32m    <DebugSymbols>true</DebugSymbols>[m
[32m+[m[32m    <DebugType>full</DebugType>[m
[32m+[m[32m    <Optimize>false</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Debug\</OutputPath>[m
[32m+[m[32m    <DefineConstants>DEBUG;TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m    <Prefer32Bit>false</Prefer32Bit>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">[m
[32m+[m[32m    <DebugType>pdbonly</DebugType>[m
[32m+[m[32m    <Optimize>true</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Release\</OutputPath>[m
[32m+[m[32m    <DefineConstants>TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m    <Prefer32Bit>false</Prefer32Bit>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.Desktop.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.Workspaces.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.Workspaces.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp.Workspaces.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.Workspaces.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.Workspaces.Desktop.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.Desktop.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Workspaces.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.Workspaces.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.Workspaces.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Workspaces.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.Workspaces.Desktop.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System" />[m
[32m+[m[32m    <Reference Include="System.Collections.Immutable, Version=1.1.33.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\System.Collections.Immutable.1.1.33-beta\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.AttributedModel, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.AttributedModel.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Convention, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Convention.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Hosting, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Hosting.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Runtime, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Runtime.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.TypedParts, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.TypedParts.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Core" />[m
[32m+[m[32m    <Reference Include="System.Reflection.Metadata, Version=1.0.18.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\System.Reflection.Metadata.1.0.18-beta\lib\portable-net45+win8\System.Reflection.Metadata.dll</HintPath>[m
[32m+[m[32m      <Private>True</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Xml.Linq" />[m
[32m+[m[32m    <Reference Include="System.Data.DataSetExtensions" />[m
[32m+[m[32m    <Reference Include="Microsoft.CSharp" />[m
[32m+[m[32m    <Reference Include="System.Data" />[m
[32m+[m[32m    <Reference Include="System.Xml" />[m
[32m+[m[32m    <Reference Include="Microsoft.VisualStudio.QualityTools.UnitTestFramework" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Compile Include="Verifiers\CodeFixVerifier.cs" />[m
[32m+[m[32m    <Compile Include="Verifiers\DiagnosticVerifier.cs" />[m
[32m+[m[32m    <Compile Include="Helpers\CodeFixVerifier.Helper.cs" />[m
[32m+[m[32m    <Compile Include="Helpers\DiagnosticResult.cs" />[m
[32m+[m[32m    <Compile Include="Helpers\DiagnosticVerifier.Helper.cs" />[m
[32m+[m[32m    <Compile Include="UnitTests.cs" />[m
[32m+[m[32m    <Compile Include="Properties\AssemblyInfo.cs" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <None Include="packages.config" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <ProjectReference Include="..\SyntaxNodeAnalyzer\SyntaxNodeAnalyzer.csproj">[m
[32m+[m[32m      <Project>{2D370822-C5D4-49BB-ADB5-15916A1AB229}</Project>[m
[32m+[m[32m      <Name>SyntaxNodeAnalyzer</Name>[m
[32m+[m[32m    </ProjectReference>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Service Include="{82A7F48D-3B50-4B1E-B82E-3ADA8210C358}" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />[m
[32m+[m[32m  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.[m[41m [m
[32m+[m[32m       Other similar extension points exist, see Microsoft.Common.targets.[m
[32m+[m[32m  <Target Name="BeforeBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  <Target Name="AfterBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  -->[m
[32m+[m[32m</Project>[m
\ No newline at end of file[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/UnitTests.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/UnitTests.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..11bad68[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/UnitTests.cs[m
[36m@@ -0,0 +1,96 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeFixes;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.VisualStudio.TestTools.UnitTesting;[m
[32m+[m[32musing System;[m
[32m+[m[32musing TestHelper;[m
[32m+[m[32musing SyntaxNodeAnalyzer;[m
[32m+[m
[32m+[m[32mnamespace SyntaxNodeAnalyzer.Test[m
[32m+[m[32m{[m
[32m+[m[32m    [TestClass][m
[32m+[m[32m    public class UnitTest : CodeFixVerifier[m
[32m+[m[32m    {[m
[32m+[m
[32m+[m[32m        //No diagnostics expected to show up[m
[32m+[m[32m        [TestMethod][m
[32m+[m[32m        public void TestMethod1()[m
[32m+[m[32m        {[m
[32m+[m[32m            var test = @"";[m
[32m+[m
[32m+[m[32m            VerifyCSharpDiagnostic(test);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        //Diagnostic and CodeFix both triggered and checked for[m
[32m+[m[32m        [TestMethod][m
[32m+[m[32m        public void TestMethod2()[m
[32m+[m[32m        {[m
[32m+[m[32m            var test = @"[m
[32m+[m[32m    using System;[m
[32m+[m[32m    using System.Collections.Generic;[m
[32m+[m[32m    using System.Linq;[m
[32m+[m[32m    using System.Text;[m
[32m+[m[32m    using System.Threading.Tasks;[m
[32m+[m[32m    using System.Diagnostics;[m
[32m+[m
[32m+[m[32m    namespace ConsoleApplication1[m
[32m+[m[32m    {[m
[32m+[m[32m        class TypeName[m
[32m+[m[32m        {[m
[32m+[m[32m            static void Main(string[] args)[m
[32m+[m[32m            {[m
[32m+[m[32m                if                 (true)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Console.WriteLine(""Hello World"");[m[41m    [m
[32m+[m[32m                }[m
[32m+[m[32m            }[m[41m          [m
[32m+[m[32m        }[m
[32m+[m[32m    }";[m
[32m+[m[32m            var expected = new DiagnosticResult[m
[32m+[m[32m            {[m
[32m+[m[32m                Id = SyntaxNodeAnalyzerAnalyzer.spacingRuleId,[m
[32m+[m[32m                Message = String.Format("If statements must contain a space between the 'if' keyword and the boolean expression)"), //make sure this message matches the original message[m
[32m+[m[32m                Severity = DiagnosticSeverity.Warning, //make sure this matches the original[m
[32m+[m[32m                Locations =[m
[32m+[m[32m                    new[] {[m
[32m+[m[32m                            new DiagnosticResultLocation("Test0.cs", 15, 17)[m
[32m+[m[32m                        }[m
[32m+[m[32m            };[m
[32m+[m
[32m+[m[32m            VerifyCSharpDiagnostic(test, expected);[m
[32m+[m
[32m+[m[32m            var fixtest = @"[m
[32m+[m[32m    using System;[m
[32m+[m[32m    using System.Collections.Generic;[m
[32m+[m[32m    using System.Linq;[m
[32m+[m[32m    using System.Text;[m
[32m+[m[32m    using System.Threading.Tasks;[m
[32m+[m[32m    using System.Diagnostics;[m
[32m+[m
[32m+[m[32m    namespace ConsoleApplication1[m
[32m+[m[32m    {[m
[32m+[m[32m        class TypeName[m
[32m+[m[32m        {[m
[32m+[m[32m            static void Main(string[] args)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (true)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Console.WriteLine(""Hello World"");[m[41m    [m
[32m+[m[32m                }[m
[32m+[m[32m            }[m[41m          [m
[32m+[m[32m        }[m
[32m+[m[32m    }";[m
[32m+[m[32m            VerifyCSharpFix(test, fixtest);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        protected override CodeFixProvider GetCSharpCodeFixProvider()[m
[32m+[m[32m        {[m
[32m+[m[32m            return new SyntaxNodeAnalyzerCodeFixProvider();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        protected override DiagnosticAnalyzer GetCSharpDiagnosticAnalyzer()[m
[32m+[m[32m        {[m
[32m+[m[32m            return new SyntaxNodeAnalyzerAnalyzer();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Verifiers/CodeFixVerifier.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Verifiers/CodeFixVerifier.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..61549fc[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Verifiers/CodeFixVerifier.cs[m
[36m@@ -0,0 +1,128 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeActions;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeFixes;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Formatting;[m
[32m+[m[32musing Microsoft.VisualStudio.TestTools.UnitTesting;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m
[32m+[m[32mnamespace TestHelper[m
[32m+[m[32m{[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Superclass of all Unit tests made for diagnostics with codefixes.[m
[32m+[m[32m    /// Contains methods used to verify correctness of codefixes[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public abstract partial class CodeFixVerifier : DiagnosticVerifier[m
[32m+[m[32m    {[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Returns the codefix being tested (C#) - to be implemented in non-abstract class[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <returns>The CodeFixProvider to be used for CSharp code</returns>[m
[32m+[m[32m        protected virtual CodeFixProvider GetCSharpCodeFixProvider()[m
[32m+[m[32m        {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Returns the codefix being tested (VB) - to be implemented in non-abstract class[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <returns>The CodeFixProvider to be used for VisualBasic code</returns>[m
[32m+[m[32m        protected virtual CodeFixProvider GetBasicCodeFixProvider()[m
[32m+[m[32m        {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a C# codefix when applied on the inputted string as a source[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="oldSource">A class in the form of a string before the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="newSource">A class in the form of a string after the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="codeFixIndex">Index determining which codefix to apply if there are multiple</param>[m
[32m+[m[32m        /// <param name="allowNewCompilerDiagnostics">A bool controlling whether or not the test will fail if the CodeFix introduces other warnings after being applied</param>[m
[32m+[m[32m        protected void VerifyCSharpFix(string oldSource, string newSource, int? codeFixIndex = null, bool allowNewCompilerDiagnostics = false)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyFix(LanguageNames.CSharp, GetCSharpDiagnosticAnalyzer(), GetCSharpCodeFixProvider(), oldSource, newSource, codeFixIndex, allowNewCompilerDiagnostics);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a VB codefix when applied on the inputted string as a source[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="oldSource">A class in the form of a string before the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="newSource">A class in the form of a string after the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="codeFixIndex">Index determining which codefix to apply if there are multiple</param>[m
[32m+[m[32m        /// <param name="allowNewCompilerDiagnostics">A bool controlling whether or not the test will fail if the CodeFix introduces other warnings after being applied</param>[m
[32m+[m[32m        protected void VerifyBasicFix(string oldSource, string newSource, int? codeFixIndex = null, bool allowNewCompilerDiagnostics = false)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyFix(LanguageNames.VisualBasic, GetBasicDiagnosticAnalyzer(), GetBasicCodeFixProvider(), oldSource, newSource, codeFixIndex, allowNewCompilerDiagnostics);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// General verifier for codefixes.[m
[32m+[m[32m        /// Creates a Document from the source string, then gets diagnostics on it and applies the relevant codefixes.[m
[32m+[m[32m        /// Then gets the string after the codefix is applied and compares it with the expected result.[m
[32m+[m[32m        /// Note: If any codefix causes new diagnostics to show up, the test fails unless allowNewCompilerDiagnostics is set to true.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="language">The language the source code is in</param>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer to be applied to the source code</param>[m
[32m+[m[32m        /// <param name="codeFixProvider">The codefix to be applied to the code wherever the relevant Diagnostic is found</param>[m
[32m+[m[32m        /// <param name="oldSource">A class in the form of a string before the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="newSource">A class in the form of a string after the CodeFix was applied to it</param>[m
[32m+[m[32m        /// <param name="codeFixIndex">Index determining which codefix to apply if there are multiple</param>[m
[32m+[m[32m        /// <param name="allowNewCompilerDiagnostics">A bool controlling whether or not the test will fail if the CodeFix introduces other warnings after being applied</param>[m
[32m+[m[32m        private void VerifyFix(string language, DiagnosticAnalyzer analyzer, CodeFixProvider codeFixProvider, string oldSource, string newSource, int? codeFixIndex, bool allowNewCompilerDiagnostics)[m
[32m+[m[32m        {[m
[32m+[m[32m            var document = CreateDocument(oldSource, language);[m
[32m+[m[32m            var analyzerDiagnostics = GetSortedDiagnosticsFromDocuments(analyzer, new[] { document });[m
[32m+[m[32m            var compilerDiagnostics = GetCompilerDiagnostics(document);[m
[32m+[m[32m            var attempts = analyzerDiagnostics.Length;[m
[32m+[m
[32m+[m[32m            for (int i = 0; i < attempts; ++i)[m
[32m+[m[32m            {[m
[32m+[m[32m                var actions = new List<CodeAction>();[m
[32m+[m[32m                var context = new CodeFixContext(document, analyzerDiagnostics[0], (a, d) => actions.Add(a), CancellationToken.None);[m
[32m+[m[32m                codeFixProvider.RegisterCodeFixesAsync(context).Wait();[m
[32m+[m
[32m+[m[32m                if (!actions.Any())[m
[32m+[m[32m                {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (codeFixIndex != null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    document = ApplyFix(document, actions.ElementAt((int)codeFixIndex));[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                document = ApplyFix(document, actions.ElementAt(0));[m
[32m+[m[32m                analyzerDiagnostics = GetSortedDiagnosticsFromDocuments(analyzer, new[] { document });[m
[32m+[m
[32m+[m[32m                var newCompilerDiagnostics = GetNewDiagnostics(compilerDiagnostics, GetCompilerDiagnostics(document));[m
[32m+[m
[32m+[m[32m                //check if applying the code fix introduced any new compiler diagnostics[m
[32m+[m[32m                if (!allowNewCompilerDiagnostics && newCompilerDiagnostics.Any())[m
[32m+[m[32m                {[m
[32m+[m[32m                    // Format and get the compiler diagnostics again so that the locations make sense in the output[m
[32m+[m[32m                    document = document.WithSyntaxRoot(Formatter.Format(document.GetSyntaxRootAsync().Result, Formatter.Annotation, document.Project.Solution.Workspace));[m
[32m+[m[32m                    newCompilerDiagnostics = GetNewDiagnostics(compilerDiagnostics, GetCompilerDiagnostics(document));[m
[32m+[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Fix introduced new compiler diagnostics:\r\n{0}\r\n\r\nNew document:\r\n{1}\r\n",[m
[32m+[m[32m                            string.Join("\r\n", newCompilerDiagnostics.Select(d => d.ToString())),[m
[32m+[m[32m                            document.GetSyntaxRootAsync().Result.ToFullString()));[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                //check if there are analyzer diagnostics left after the code fix[m
[32m+[m[32m                if (!analyzerDiagnostics.Any())[m
[32m+[m[32m                {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            //after applying all of the code fixes, compare the resulting string to the inputted one[m
[32m+[m[32m            var actual = GetStringFromDocument(document);[m
[32m+[m[32m            Assert.AreEqual(newSource, actual);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Verifiers/DiagnosticVerifier.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Verifiers/DiagnosticVerifier.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..a0124e5[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/Verifiers/DiagnosticVerifier.cs[m
[36m@@ -0,0 +1,270 @@[m
[32m+[m[32m﻿using Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.VisualStudio.TestTools.UnitTesting;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Text;[m
[32m+[m
[32m+[m[32mnamespace TestHelper[m
[32m+[m[32m{[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Superclass of all Unit Tests for DiagnosticAnalyzers[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public abstract partial class DiagnosticVerifier[m
[32m+[m[32m    {[m
[32m+[m[32m        #region To be implemented by Test classes[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Get the CSharp analyzer being tested - to be implemented in non-abstract class[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        protected virtual DiagnosticAnalyzer GetCSharpDiagnosticAnalyzer()[m
[32m+[m[32m        {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Get the Visual Basic analyzer being tested (C#) - to be implemented in non-abstract class[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        protected virtual DiagnosticAnalyzer GetBasicDiagnosticAnalyzer()[m
[32m+[m[32m        {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        #endregion[m
[32m+[m
[32m+[m[32m        #region Verifier wrappers[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a C# DiagnosticAnalyzer when applied on the single inputted string as a source[m
[32m+[m[32m        /// Note: input a DiagnosticResult for each Diagnostic expected[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="source">A class in the form of a string to run the analyzer on</param>[m
[32m+[m[32m        /// <param name="expected"> DiagnosticResults that should appear after the analyzer is run on the source</param>[m
[32m+[m[32m        protected void VerifyCSharpDiagnostic(string source, params DiagnosticResult[] expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyDiagnostics(new[] { source }, LanguageNames.CSharp, GetCSharpDiagnosticAnalyzer(), expected);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a VB DiagnosticAnalyzer when applied on the single inputted string as a source[m
[32m+[m[32m        /// Note: input a DiagnosticResult for each Diagnostic expected[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="source">A class in the form of a string to run the analyzer on</param>[m
[32m+[m[32m        /// <param name="expected">DiagnosticResults that should appear after the analyzer is run on the source</param>[m
[32m+[m[32m        protected void VerifyBasicDiagnostic(string source, params DiagnosticResult[] expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyDiagnostics(new[] { source }, LanguageNames.VisualBasic, GetBasicDiagnosticAnalyzer(), expected);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a C# DiagnosticAnalyzer when applied on the inputted strings as a source[m
[32m+[m[32m        /// Note: input a DiagnosticResult for each Diagnostic expected[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">An array of strings to create source documents from to run the analyzers on</param>[m
[32m+[m[32m        /// <param name="expected">DiagnosticResults that should appear after the analyzer is run on the sources</param>[m
[32m+[m[32m        protected void VerifyCSharpDiagnostic(string[] sources, params DiagnosticResult[] expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyDiagnostics(sources, LanguageNames.CSharp, GetCSharpDiagnosticAnalyzer(), expected);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Called to test a VB DiagnosticAnalyzer when applied on the inputted strings as a source[m
[32m+[m[32m        /// Note: input a DiagnosticResult for each Diagnostic expected[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">An array of strings to create source documents from to run the analyzers on</param>[m
[32m+[m[32m        /// <param name="expected">DiagnosticResults that should appear after the analyzer is run on the sources</param>[m
[32m+[m[32m        protected void VerifyBasicDiagnostic(string[] sources, params DiagnosticResult[] expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            VerifyDiagnostics(sources, LanguageNames.VisualBasic, GetBasicDiagnosticAnalyzer(), expected);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// General method that gets a collection of actual diagnostics found in the source after the analyzer is run,[m[41m [m
[32m+[m[32m        /// then verifies each of them.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="sources">An array of strings to create source documents from to run the analyzers on</param>[m
[32m+[m[32m        /// <param name="language">The language of the classes represented by the source strings</param>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer to be run on the source code</param>[m
[32m+[m[32m        /// <param name="expected">DiagnosticResults that should appear after the analyzer is run on the sources</param>[m
[32m+[m[32m        private void VerifyDiagnostics(string[] sources, string language, DiagnosticAnalyzer analyzer, params DiagnosticResult[] expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            var diagnostics = GetSortedDiagnostics(sources, language, analyzer);[m
[32m+[m[32m            VerifyDiagnosticResults(diagnostics, analyzer, expected);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        #endregion[m
[32m+[m
[32m+[m[32m        #region Actual comparisons and verifications[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Checks each of the actual Diagnostics found and compares them with the corresponding DiagnosticResult in the array of expected results.[m
[32m+[m[32m        /// Diagnostics are considered equal only if the DiagnosticResultLocation, Id, Severity, and Message of the DiagnosticResult match the actual diagnostic.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="actualResults">The Diagnostics found by the compiler after running the analyzer on the source code</param>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer that was being run on the sources</param>[m
[32m+[m[32m        /// <param name="expectedResults">Diagnostic Results that should have appeared in the code</param>[m
[32m+[m[32m        private static void VerifyDiagnosticResults(IEnumerable<Diagnostic> actualResults, DiagnosticAnalyzer analyzer, params DiagnosticResult[] expectedResults)[m
[32m+[m[32m        {[m
[32m+[m[32m            int expectedCount = expectedResults.Count();[m
[32m+[m[32m            int actualCount = actualResults.Count();[m
[32m+[m
[32m+[m[32m            if (expectedCount != actualCount)[m
[32m+[m[32m            {[m
[32m+[m[32m                string diagnosticsOutput = actualResults.Any() ? FormatDiagnostics(analyzer, actualResults.ToArray()) : "    NONE.";[m
[32m+[m
[32m+[m[32m                Assert.IsTrue(false,[m
[32m+[m[32m                    string.Format("Mismatch between number of diagnostics returned, expected \"{0}\" actual \"{1}\"\r\n\r\nDiagnostics:\r\n{2}\r\n", expectedCount, actualCount, diagnosticsOutput));[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            for (int i = 0; i < expectedResults.Length; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                var actual = actualResults.ElementAt(i);[m
[32m+[m[32m                var expected = expectedResults[i];[m
[32m+[m
[32m+[m[32m                if (expected.Line == -1 && expected.Column == -1)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (actual.Location != Location.None)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        Assert.IsTrue(false,[m
[32m+[m[32m                            string.Format("Expected:\nA project diagnostic with No location\nActual:\n{0}",[m
[32m+[m[32m                            FormatDiagnostics(analyzer, actual)));[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    VerifyDiagnosticLocation(analyzer, actual, actual.Location, expected.Locations.First());[m
[32m+[m[32m                    var additionalLocations = actual.AdditionalLocations.ToArray();[m
[32m+[m
[32m+[m[32m                    if (additionalLocations.Length != expected.Locations.Length - 1)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        Assert.IsTrue(false,[m
[32m+[m[32m                            string.Format("Expected {0} additional locations but got {1} for Diagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                                expected.Locations.Length - 1, additionalLocations.Length,[m
[32m+[m[32m                                FormatDiagnostics(analyzer, actual)));[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    for (int j = 0; j < additionalLocations.Length; ++j)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        VerifyDiagnosticLocation(analyzer, actual, additionalLocations[j], expected.Locations[j + 1]);[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (actual.Id != expected.Id)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Expected diagnostic id to be \"{0}\" was \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                            expected.Id, actual.Id, FormatDiagnostics(analyzer, actual)));[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (actual.Severity != expected.Severity)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Expected diagnostic severity to be \"{0}\" was \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                            expected.Severity, actual.Severity, FormatDiagnostics(analyzer, actual)));[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (actual.GetMessage() != expected.Message)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Expected diagnostic message to be \"{0}\" was \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                            expected.Message, actual.GetMessage(), FormatDiagnostics(analyzer, actual)));[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Helper method to VerifyDiagnosticResult that checks the location of a diagnostic and compares it with the location in the expected DiagnosticResult.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer that was being run on the sources</param>[m
[32m+[m[32m        /// <param name="diagnostic">The diagnostic that was found in the code</param>[m
[32m+[m[32m        /// <param name="actual">The Location of the Diagnostic found in the code</param>[m
[32m+[m[32m        /// <param name="expected">The DiagnosticResultLocation that should have been found</param>[m
[32m+[m[32m        private static void VerifyDiagnosticLocation(DiagnosticAnalyzer analyzer, Diagnostic diagnostic, Location actual, DiagnosticResultLocation expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            var actualSpan = actual.GetLineSpan();[m
[32m+[m
[32m+[m[32m            Assert.IsTrue(actualSpan.Path == expected.Path || (actualSpan.Path != null && actualSpan.Path.Contains("Test0.") && expected.Path.Contains("Test.")),[m
[32m+[m[32m                string.Format("Expected diagnostic to be in file \"{0}\" was actually in file \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                    expected.Path, actualSpan.Path, FormatDiagnostics(analyzer, diagnostic)));[m
[32m+[m
[32m+[m[32m            var actualLinePosition = actualSpan.StartLinePosition;[m
[32m+[m
[32m+[m[32m            // Only check line position if there is an actual line in the real diagnostic[m
[32m+[m[32m            if (actualLinePosition.Line > 0)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (actualLinePosition.Line + 1 != expected.Line)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Expected diagnostic to be on line \"{0}\" was actually on line \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                            expected.Line, actualLinePosition.Line + 1, FormatDiagnostics(analyzer, diagnostic)));[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Only check column position if there is an actual column position in the real diagnostic[m
[32m+[m[32m            if (actualLinePosition.Character > 0)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (actualLinePosition.Character + 1 != expected.Column)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Assert.IsTrue(false,[m
[32m+[m[32m                        string.Format("Expected diagnostic to start at column \"{0}\" was actually at column \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",[m
[32m+[m[32m                            expected.Column, actualLinePosition.Character + 1, FormatDiagnostics(analyzer, diagnostic)));[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        #endregion[m
[32m+[m
[32m+[m[32m        #region Formatting Diagnostics[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        /// Helper method to format a Diagnostic into an easily readable string[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        /// <param name="analyzer">The analyzer that this verifier tests</param>[m
[32m+[m[32m        /// <param name="diagnostics">The Diagnostics to be formatted</param>[m
[32m+[m[32m        /// <returns>The Diagnostics formatted as a string</returns>[m
[32m+[m[32m        private static string FormatDiagnostics(DiagnosticAnalyzer analyzer, params Diagnostic[] diagnostics)[m
[32m+[m[32m        {[m
[32m+[m[32m            var builder = new StringBuilder();[m
[32m+[m[32m            for (int i = 0; i < diagnostics.Length; ++i)[m
[32m+[m[32m            {[m
[32m+[m[32m                builder.AppendLine("// " + diagnostics[i].ToString());[m
[32m+[m
[32m+[m[32m                var analyzerType = analyzer.GetType();[m
[32m+[m[32m                var rules = analyzer.SupportedDiagnostics;[m
[32m+[m
[32m+[m[32m                foreach (var rule in rules)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (rule != null && rule.Id == diagnostics[i].Id)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        var location = diagnostics[i].Location;[m
[32m+[m[32m                        if (location == Location.None)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            builder.AppendFormat("GetGlobalResult({0}.{1})", analyzerType.Name, rule.Id);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else[m
[32m+[m[32m                        {[m
[32m+[m[32m                            Assert.IsTrue(location.IsInSource,[m
[32m+[m[32m                                string.Format("Test base does not currently handle diagnostics in metadata locations. Diagnostic in metadata:\r\n", diagnostics[i]));[m
[32m+[m
[32m+[m[32m                            string resultMethodName = diagnostics[i].Location.SourceTree.FilePath.EndsWith(".cs") ? "GetCSharpResultAt" : "GetBasicResultAt";[m
[32m+[m[32m                            var linePosition = diagnostics[i].Location.GetLineSpan().StartLinePosition;[m
[32m+[m
[32m+[m[32m                            builder.AppendFormat("{0}({1}, {2}, {3}.{4})",[m
[32m+[m[32m                                resultMethodName,[m
[32m+[m[32m                                linePosition.Line + 1,[m
[32m+[m[32m                                linePosition.Character + 1,[m
[32m+[m[32m                                analyzerType.Name,[m
[32m+[m[32m                                rule.Id);[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        if (i != diagnostics.Length - 1)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            builder.Append(',');[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        builder.AppendLine();[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            return builder.ToString();[m
[32m+[m[32m        }[m
[32m+[m[32m        #endregion[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/packages.config b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/packages.config[m
[1mnew file mode 100644[m
[1mindex 0000000..fd6eb05[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Test/packages.config[m
[36m@@ -0,0 +1,10 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<packages>[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.Common" version="1.0.0-rc2" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.CSharp" version="1.0.0-rc2" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.CSharp.Workspaces" version="1.0.0-rc2" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.Workspaces.Common" version="1.0.0-rc2" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.Composition" version="1.0.27" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="System.Collections.Immutable" version="1.1.33-beta" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m  <package id="System.Reflection.Metadata" version="1.0.18-beta" targetFramework="net452" userInstalled="true" />[m
[32m+[m[32m</packages>[m
\ No newline at end of file[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Vsix/SyntaxNodeAnalyzer.Vsix.csproj b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Vsix/SyntaxNodeAnalyzer.Vsix.csproj[m
[1mnew file mode 100644[m
[1mindex 0000000..39b3696[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Vsix/SyntaxNodeAnalyzer.Vsix.csproj[m
[36m@@ -0,0 +1,69 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>[m
[32m+[m[32m    <VSToolsPath Condition="'$(VSToolsPath)' == ''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>[m
[32m+[m[32m    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>[m
[32m+[m[32m    <SchemaVersion>2.0</SchemaVersion>[m
[32m+[m[32m    <ProjectTypeGuids>{82b43b9b-a64c-4715-b499-d71e9ca2bd60};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>[m
[32m+[m[32m    <ProjectGuid>{4FF4DFA1-B646-481E-8C5B-52BD1DEA23BC}</ProjectGuid>[m
[32m+[m[32m    <OutputType>Library</OutputType>[m
[32m+[m[32m    <AppDesignerFolder>Properties</AppDesignerFolder>[m
[32m+[m[32m    <RootNamespace>SyntaxNodeAnalyzer</RootNamespace>[m
[32m+[m[32m    <AssemblyName>SyntaxNodeAnalyzer</AssemblyName>[m
[32m+[m[32m    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>[m
[32m+[m[32m    <GeneratePkgDefFile>false</GeneratePkgDefFile>[m
[32m+[m[32m    <IncludeAssemblyInVSIXContainer>false</IncludeAssemblyInVSIXContainer>[m
[32m+[m[32m    <IncludeDebugSymbolsInVSIXContainer>false</IncludeDebugSymbolsInVSIXContainer>[m
[32m+[m[32m    <IncludeDebugSymbolsInLocalVSIXDeployment>false</IncludeDebugSymbolsInLocalVSIXDeployment>[m
[32m+[m[32m    <CopyBuildOutputToOutputDirectory>false</CopyBuildOutputToOutputDirectory>[m
[32m+[m[32m    <CopyOutputSymbolsToOutputDirectory>false</CopyOutputSymbolsToOutputDirectory>[m
[32m+[m[32m    <VSSDKTargetPlatformRegRootSuffix>Roslyn</VSSDKTargetPlatformRegRootSuffix>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">[m
[32m+[m[32m    <DebugSymbols>true</DebugSymbols>[m
[32m+[m[32m    <DebugType>full</DebugType>[m
[32m+[m[32m    <Optimize>false</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Debug\</OutputPath>[m
[32m+[m[32m    <DefineConstants>DEBUG;TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">[m
[32m+[m[32m    <DebugType>pdbonly</DebugType>[m
[32m+[m[32m    <Optimize>true</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Release\</OutputPath>[m
[32m+[m[32m    <DefineConstants>TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <StartAction>Program</StartAction>[m
[32m+[m[32m    <StartProgram>$(DevEnvDir)devenv.exe</StartProgram>[m
[32m+[m[32m    <StartArguments>/rootsuffix Roslyn</StartArguments>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <None Include="source.extension.vsixmanifest">[m
[32m+[m[32m      <SubType>Designer</SubType>[m
[32m+[m[32m    </None>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <ProjectReference Include="..\SyntaxNodeAnalyzer\SyntaxNodeAnalyzer.csproj">[m
[32m+[m[32m      <Project>{2D370822-C5D4-49BB-ADB5-15916A1AB229}</Project>[m
[32m+[m[32m      <Name>SyntaxNodeAnalyzer</Name>[m
[32m+[m[32m    </ProjectReference>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />[m
[32m+[m[32m  <Import Project="$(VSToolsPath)\VSSDK\Microsoft.VsSDK.targets" Condition="'$(VSToolsPath)' != ''" />[m
[32m+[m[32m  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.[m[41m [m
[32m+[m[32m       Other similar extension points exist, see Microsoft.Common.targets.[m
[32m+[m[32m  <Target Name="BeforeBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  <Target Name="AfterBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  -->[m
[32m+[m[32m</Project>[m
\ No newline at end of file[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Vsix/source.extension.vsixmanifest b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Vsix/source.extension.vsixmanifest[m
[1mnew file mode 100644[m
[1mindex 0000000..554f003[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.Vsix/source.extension.vsixmanifest[m
[36m@@ -0,0 +1,21 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<PackageManifest Version="2.0.0" xmlns="http://schemas.microsoft.com/developer/vsx-schema/2011" xmlns:d="http://schemas.microsoft.com/developer/vsx-schema-design/2011">[m
[32m+[m[32m  <Metadata>[m
[32m+[m[32m    <Identity Id="SyntaxNodeAnalyzer.Vsix..beeb294a-1ec8-4635-b933-de412f944500" Version="1.0" Language="en-US" Publisher="Administrator"/>[m
[32m+[m[32m    <DisplayName>SyntaxNodeAnalyzer.Vsix</DisplayName>[m
[32m+[m[32m    <Description xml:space="preserve">This is a sample diagnostic extension for the .NET Compiler Platform ("Roslyn").</Description>[m
[32m+[m[32m  </Metadata>[m
[32m+[m[32m  <Installation>[m
[32m+[m[32m    <InstallationTarget Version="[14.0,]" Id="Microsoft.VisualStudio.Pro" />[m
[32m+[m[32m    <InstallationTarget Version="[14.0,]" Id="Microsoft.VisualStudio.VSWinDesktopExpress" />[m
[32m+[m[32m    <InstallationTarget Version="[14.0,]" Id="Microsoft.VisualStudio.VWDExpress" />[m
[32m+[m[32m    <InstallationTarget Version="[14.0,]" Id="Microsoft.VisualStudio.VSWinExpress" />[m
[32m+[m[32m  </Installation>[m
[32m+[m[32m  <Dependencies>[m
[32m+[m[32m    <Dependency Id="Microsoft.Framework.NDP" DisplayName="Microsoft .NET Framework" d:Source="Manual" Version="[4.5,)" />[m
[32m+[m[32m  </Dependencies>[m
[32m+[m[32m  <Assets>[m
[32m+[m[32m    <Asset Type="Microsoft.VisualStudio.MefComponent" d:Source="Project" d:ProjectName="SyntaxNodeAnalyzer" Path="|SyntaxNodeAnalyzer|"/>[m
[32m+[m[32m    <Asset Type="Microsoft.VisualStudio.Analyzer" d:Source="Project" d:ProjectName="SyntaxNodeAnalyzer" Path="|SyntaxNodeAnalyzer|"/>[m
[32m+[m[32m  </Assets>[m
[32m+[m[32m</PackageManifest>[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/CodeFixProvider.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/CodeFixProvider.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..51b78b2[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/CodeFixProvider.cs[m
[36m@@ -0,0 +1,65 @@[m
[32m+[m[32m﻿using System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Collections.Immutable;[m
[32m+[m[32musing System.Composition;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m[32musing System.Threading.Tasks;[m
[32m+[m[32musing Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeFixes;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CodeActions;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Rename;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Text;[m
[32m+[m
[32m+[m[32mnamespace SyntaxNodeAnalyzer[m
[32m+[m[32m{[m
[32m+[m[32m    [ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(SyntaxNodeAnalyzerCodeFixProvider)), Shared][m
[32m+[m[32m    public class SyntaxNodeAnalyzerCodeFixProvider : CodeFixProvider[m
[32m+[m[32m    {[m
[32m+[m[32m        public override ImmutableArray<string> FixableDiagnosticIds[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return ImmutableArray.Create(SyntaxNodeAnalyzerAnalyzer.spacingRuleId);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public override async Task RegisterCodeFixesAsync(CodeFixContext context)[m
[32m+[m[32m        {[m
[32m+[m[32m            var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);[m
[32m+[m
[32m+[m[32m            var diagnostic = context.Diagnostics.First();[m
[32m+[m[32m            var diagnosticSpan = diagnostic.Location.SourceSpan;[m
[32m+[m
[32m+[m[32m            var ifStatement = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<IfStatementSyntax>().First();[m
[32m+[m
[32m+[m[32m            context.RegisterCodeFix([m
[32m+[m[32m                CodeAction.Create("Fix spacing", c => FixSpacingAsync(context.Document, ifStatement, c)),[m
[32m+[m[32m                diagnostic);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        private async Task<Document> FixSpacingAsync(Document document, IfStatementSyntax ifStatement, CancellationToken c)[m
[32m+[m[32m        {[m
[32m+[m[32m            var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m            var openParen = ifStatement.OpenParenToken;[m
[32m+[m
[32m+[m[32m            var whitespace = SyntaxFactory.SyntaxTrivia(SyntaxKind.WhitespaceTrivia, " ");[m
[32m+[m[32m            var trailingTrivia = SyntaxFactory.TriviaList(whitespace);[m
[32m+[m[32m            var newIfKeyword = SyntaxFactory.Token(ifKeyword.LeadingTrivia, SyntaxKind.IfKeyword, trailingTrivia);[m
[32m+[m
[32m+[m[32m            var newOpenParen = SyntaxFactory.Token(SyntaxFactory.TriviaList(), SyntaxKind.OpenParenToken, openParen.TrailingTrivia);[m
[32m+[m
[32m+[m
[32m+[m[32m            var newIfStatement = SyntaxFactory.IfStatement(newIfKeyword, newOpenParen, ifStatement.Condition, ifStatement.CloseParenToken, ifStatement.Statement, ifStatement.Else);[m
[32m+[m
[32m+[m[41m            [m
[32m+[m
[32m+[m[32m            var root = await document.GetSyntaxRootAsync();[m
[32m+[m[32m            var newRoot = root.ReplaceNode(ifStatement, newIfStatement);[m
[32m+[m[32m            var newDocument = document.WithSyntaxRoot(newRoot);[m
[32m+[m[32m            return newDocument;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/Diagnostic.nuspec b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/Diagnostic.nuspec[m
[1mnew file mode 100644[m
[1mindex 0000000..e7639a1[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/Diagnostic.nuspec[m
[36m@@ -0,0 +1,25 @@[m
[32m+[m[32m﻿<?xml version="1.0"?>[m
[32m+[m[32m<package xmlns="http://schemas.microsoft.com/packaging/2011/08/nuspec.xsd">[m
[32m+[m[32m  <metadata>[m
[32m+[m[32m    <id>SyntaxNodeAnalyzer</id>[m
[32m+[m[32m    <version>1.0.0.0</version>[m
[32m+[m[32m    <title>SyntaxNodeAnalyzer</title>[m
[32m+[m[32m    <authors>SyntaxNodeAnalyzer</authors>[m
[32m+[m[32m    <owners>SyntaxNodeAnalyzer</owners>[m
[32m+[m[32m    <licenseUrl>http://LICENSE_URL_HERE_OR_DELETE_THIS_LINE</licenseUrl>[m
[32m+[m[32m    <projectUrl>http://PROJECT_URL_HERE_OR_DELETE_THIS_LINE</projectUrl>[m
[32m+[m[32m    <iconUrl>http://ICON_URL_HERE_OR_DELETE_THIS_LINE</iconUrl>[m
[32m+[m[32m    <requireLicenseAcceptance>false</requireLicenseAcceptance>[m
[32m+[m[32m    <description>SyntaxNodeAnalyzer</description>[m
[32m+[m[32m    <releaseNotes>Summary of changes made in this release of the package.</releaseNotes>[m
[32m+[m[32m    <copyright>Copyright</copyright>[m
[32m+[m[32m    <tags>SyntaxNodeAnalyzer, analyzers</tags>[m
[32m+[m[32m    <frameworkAssemblies>[m
[32m+[m[32m      <frameworkAssembly assemblyName="System" targetFramework="" />[m
[32m+[m[32m    </frameworkAssemblies>[m
[32m+[m[32m  </metadata>[m
[32m+[m[32m  <files>[m
[32m+[m[32m    <file src="*.dll" target="tools\analyzers\" exclude="**\Microsoft.CodeAnalysis.*;**\System.Collections.Immutable.*;**\System.Reflection.Metadata.*" />[m
[32m+[m[32m    <file src="tools\*.ps1" target="tools\" />[m
[32m+[m[32m  </files>[m
[32m+[m[32m</package>[m
\ No newline at end of file[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..5547a42[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/DiagnosticAnalyzer.cs[m
[36m@@ -0,0 +1,63 @@[m
[32m+[m[32musing System;[m
[32m+[m[32musing System.Collections.Generic;[m
[32m+[m[32musing System.Collections.Immutable;[m
[32m+[m[32musing System.Linq;[m
[32m+[m[32musing System.Threading;[m
[32m+[m[32musing Microsoft.CodeAnalysis;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp;[m
[32m+[m[32musing Microsoft.CodeAnalysis.CSharp.Syntax;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Diagnostics;[m
[32m+[m[32musing Microsoft.CodeAnalysis.Text;[m
[32m+[m
[32m+[m[32mnamespace SyntaxNodeAnalyzer[m
[32m+[m[32m{[m
[32m+[m[32m    [DiagnosticAnalyzer(LanguageNames.CSharp)][m
[32m+[m[32m    public class SyntaxNodeAnalyzerAnalyzer : DiagnosticAnalyzer[m
[32m+[m[32m    {[m
[32m+[m[32m        public const string spacingRuleId = "IfSpacing";[m
[32m+[m
[32m+[m[32m        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor([m
[32m+[m[32m            id: spacingRuleId, //make the id specific[m
[32m+[m[32m            title: "If statement must have a space between 'if' and the boolean expression", //allow any title[m
[32m+[m[32m            messageFormat: "If statements must contain a space between the 'if' keyword and the boolean expression", //allow any message[m
[32m+[m[32m            category: "Syntax", //make the category specific[m
[32m+[m[32m            defaultSeverity: DiagnosticSeverity.Warning, //possible options[m
[32m+[m[32m            isEnabledByDefault: true);[m
[32m+[m
[32m+[m[32m        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return ImmutableArray.Create(Rule);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        public override void Initialize(AnalysisContext context)[m
[32m+[m[32m        {[m
[32m+[m[32m            context.RegisterSyntaxNodeAction(AnalyzeIfStatement, SyntaxKind.IfStatement);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        private void AnalyzeIfStatement(SyntaxNodeAnalysisContext obj)[m
[32m+[m[32m        {[m
[32m+[m[32m            var ifStatement = (IfStatementSyntax)obj.Node;[m
[32m+[m[32m            var ifKeyword = ifStatement.IfKeyword;[m
[32m+[m[32m            var openParen = ifStatement.OpenParenToken;[m
[32m+[m[32m            var diagnosticLocation = Location.Create(ifStatement.SyntaxTree, TextSpan.FromBounds(ifKeyword.Span.Start, openParen.Span.Start));[m
[32m+[m
[32m+[m[32m            if (ifKeyword.HasTrailingTrivia)[m
[32m+[m[32m            {[m
[32m+[m[32m                var trailingTrivia = ifKeyword.TrailingTrivia.Last();[m
[32m+[m[32m                if (trailingTrivia.Kind() == SyntaxKind.WhitespaceTrivia)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (trailingTrivia.ToString() == " ")[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            var diagnostic = Diagnostic.Create(Rule, diagnosticLocation, Rule.MessageFormat);[m
[32m+[m[32m            obj.ReportDiagnostic(diagnostic);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/Properties/AssemblyInfo.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/Properties/AssemblyInfo.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..d6774b9[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/Properties/AssemblyInfo.cs[m
[36m@@ -0,0 +1,31 @@[m
[32m+[m[32m﻿using System.Reflection;[m
[32m+[m[32musing System.Runtime.InteropServices;[m
[32m+[m
[32m+[m[32m// General Information about an assembly is controlled through the following[m[41m [m
[32m+[m[32m// set of attributes. Change these attribute values to modify the information[m
[32m+[m[32m// associated with an assembly.[m
[32m+[m[32m[assembly: AssemblyTitle("SyntaxNodeAnalyzer")][m
[32m+[m[32m[assembly: AssemblyDescription("")][m
[32m+[m[32m[assembly: AssemblyConfiguration("")][m
[32m+[m[32m[assembly: AssemblyCompany("")][m
[32m+[m[32m[assembly: AssemblyProduct("SyntaxNodeAnalyzer")][m
[32m+[m[32m[assembly: AssemblyCopyright("Copyright ©  2015")][m
[32m+[m[32m[assembly: AssemblyTrademark("")][m
[32m+[m[32m[assembly: AssemblyCulture("")][m
[32m+[m
[32m+[m[32m// Setting ComVisible to false makes the types in this assembly not visible[m[41m [m
[32m+[m[32m// to COM components.  If you need to access a type in this assembly from[m[41m [m
[32m+[m[32m// COM, set the ComVisible attribute to true on that type.[m
[32m+[m[32m[assembly: ComVisible(false)][m
[32m+[m
[32m+[m[32m// Version information for an assembly consists of the following four values:[m
[32m+[m[32m//[m
[32m+[m[32m//      Major Version[m
[32m+[m[32m//      Minor Version[m[41m [m
[32m+[m[32m//      Build Number[m
[32m+[m[32m//      Revision[m
[32m+[m[32m//[m
[32m+[m[32m// You can specify all the values or you can default the Build and Revision Numbers[m[41m [m
[32m+[m[32m// by using the '*' as shown below:[m
[32m+[m[32m[assembly: AssemblyVersion("1.0.*")][m
[32m+[m[32m[assembly: AssemblyFileVersion("1.0.0.0")][m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/ReadMe.txt b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/ReadMe.txt[m
[1mnew file mode 100644[m
[1mindex 0000000..1b92bfa[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/ReadMe.txt[m
[36m@@ -0,0 +1,33 @@[m
[32m+[m[32m﻿[m
[32m+[m[32mBuilding this project will produce an analyzer .dll, as well as the[m
[32m+[m[32mfollowing two ways you may wish to package that analyzer:[m
[32m+[m[32m * A NuGet package (.nupkg file) that will add your assembly as a[m
[32m+[m[32m   project-local analyzer that participates in builds.[m
[32m+[m[32m * A VSIX extension (.vsix file) that will apply your analyzer to all projects[m
[32m+[m[32m   and works just in the IDE.[m
[32m+[m
[32m+[m[32mTo debug your analyzer, make sure the default project is the VSIX project and[m
[32m+[m[32mstart debugging.  This will deploy the analyzer as a VSIX into another instance[m
[32m+[m[32mof Visual Studio, which is useful for debugging, even if you intend to produce[m
[32m+[m[32ma NuGet package.[m
[32m+[m
[32m+[m
[32m+[m[32mTRYING OUT YOUR NUGET PACKAGE[m
[32m+[m
[32m+[m[32mTo try out the NuGet package:[m
[32m+[m[32m 1. Create a local NuGet feed by following the instructions here:[m
[32m+[m[32m    > http://docs.nuget.org/docs/creating-packages/hosting-your-own-nuget-feeds[m
[32m+[m[32m 2. Copy the .nupkg file into that folder.[m
[32m+[m[32m 3. Open the target project in Visual Studio 2015.[m
[32m+[m[32m 4. Right-click on the project node in Solution Explorer and choose Manage[m
[32m+[m[32m    NuGet Packages.[m
[32m+[m[32m 5. Select the NuGet feed you created on the left.[m
[32m+[m[32m 6. Choose your analyzer from the list and click Install.[m
[32m+[m
[32m+[m[32mIf you want to automatically deploy the .nupkg file to the local feed folder[m
[32m+[m[32mwhen you build this project, follow these steps:[m
[32m+[m[32m 1. Right-click on this project in Solution Explorer and choose Properties.[m
[32m+[m[32m 2. Go to the Compile tab.[m
[32m+[m[32m 3. Click the Build Events button.[m
[32m+[m[32m 4. In the "Post-build event command line" box, change the -OutputDirectory[m
[32m+[m[32m    path to point to your local NuGet feed folder.[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/Resources.Designer.cs b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/Resources.Designer.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..1effa53[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/Resources.Designer.cs[m
[36m@@ -0,0 +1,106 @@[m
[32m+[m[32m﻿//------------------------------------------------------------------------------[m
[32m+[m[32m// <auto-generated>[m
[32m+[m[32m//     This code was generated by a tool.[m
[32m+[m[32m//     Runtime Version:4.0.30319.0[m
[32m+[m[32m//[m
[32m+[m[32m//     Changes to this file may cause incorrect behavior and will be lost if[m
[32m+[m[32m//     the code is regenerated.[m
[32m+[m[32m// </auto-generated>[m
[32m+[m[32m//------------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mnamespace SyntaxNodeAnalyzer[m
[32m+[m[32m{[m
[32m+[m[32m    using System;[m
[32m+[m[32m    using System.Reflection;[m
[32m+[m
[32m+[m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    ///   A strongly-typed resource class, for looking up localized strings, etc.[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    // This class was auto-generated by the StronglyTypedResourceBuilder[m
[32m+[m[32m    // class via a tool like ResGen or Visual Studio.[m
[32m+[m[32m    // To add or remove a member, edit your .ResX file then rerun ResGen[m
[32m+[m[32m    // with the /str option, or rebuild your VS project.[m
[32m+[m[32m    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")][m
[32m+[m[32m    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()][m
[32m+[m[32m    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()][m
[32m+[m[32m    internal class Resources[m
[32m+[m[32m    {[m
[32m+[m
[32m+[m[32m        private static global::System.Resources.ResourceManager resourceMan;[m
[32m+[m
[32m+[m[32m        private static global::System.Globalization.CultureInfo resourceCulture;[m
[32m+[m
[32m+[m[32m        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")][m
[32m+[m[32m        internal Resources()[m
[32m+[m[32m        {[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        ///   Returns the cached ResourceManager instance used by this class.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)][m
[32m+[m[32m        internal static global::System.Resources.ResourceManager ResourceManager[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                if (object.ReferenceEquals(resourceMan, null))[m
[32m+[m[32m                {[m
[32m+[m[32m                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("SyntaxNodeAnalyzer.Resources", typeof(Resources).GetTypeInfo().Assembly);[m
[32m+[m[32m                    resourceMan = temp;[m
[32m+[m[32m                }[m
[32m+[m[32m                return resourceMan;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        ///   Overrides the current thread's CurrentUICulture property for all[m
[32m+[m[32m        ///   resource lookups using this strongly typed resource class.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)][m
[32m+[m[32m        internal static global::System.Globalization.CultureInfo Culture[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return resourceCulture;[m
[32m+[m[32m            }[m
[32m+[m[32m            set[m
[32m+[m[32m            {[m
[32m+[m[32m                resourceCulture = value;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        ///   Looks up a localized string similar to Type names should be all uppercase..[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        internal static string AnalyzerDescription[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return ResourceManager.GetString("AnalyzerDescription", resourceCulture);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        ///   Looks up a localized string similar to Type name &apos;{0}&apos; contains lowercase letters.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        internal static string AnalyzerMessageFormat[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return ResourceManager.GetString("AnalyzerMessageFormat", resourceCulture);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /// <summary>[m
[32m+[m[32m        ///   Looks up a localized string similar to Type name contains lowercase letters.[m
[32m+[m[32m        /// </summary>[m
[32m+[m[32m        internal static string AnalyzerTitle[m
[32m+[m[32m        {[m
[32m+[m[32m            get[m
[32m+[m[32m            {[m
[32m+[m[32m                return ResourceManager.GetString("AnalyzerTitle", resourceCulture);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/Resources.resx b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/Resources.resx[m
[1mnew file mode 100644[m
[1mindex 0000000..c97ee9b[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/Resources.resx[m
[36m@@ -0,0 +1,132 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<root>[m
[32m+[m[32m  <!--[m[41m [m
[32m+[m[32m    Microsoft ResX Schema[m[41m [m
[32m+[m[41m    [m
[32m+[m[32m    Version 2.0[m
[32m+[m[41m    [m
[32m+[m[32m    The primary goals of this format is to allow a simple XML format[m[41m [m
[32m+[m[32m    that is mostly human readable. The generation and parsing of the[m[41m [m
[32m+[m[32m    various data types are done through the TypeConverter classes[m[41m [m
[32m+[m[32m    associated with the data types.[m
[32m+[m[41m    [m
[32m+[m[32m    Example:[m
[32m+[m[41m    [m
[32m+[m[32m    ... ado.net/XML headers & schema ...[m
[32m+[m[32m    <resheader name="resmimetype">text/microsoft-resx</resheader>[m
[32m+[m[32m    <resheader name="version">2.0</resheader>[m
[32m+[m[32m    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>[m
[32m+[m[32m    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>[m
[32m+[m[32m    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>[m
[32m+[m[32m    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>[m
[32m+[m[32m    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">[m
[32m+[m[32m        <value>[base64 mime encoded serialized .NET Framework object]</value>[m
[32m+[m[32m    </data>[m
[32m+[m[32m    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">[m
[32m+[m[32m        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>[m
[32m+[m[32m        <comment>This is a comment</comment>[m
[32m+[m[32m    </data>[m
[32m+[m[41m                [m
[32m+[m[32m    There are any number of "resheader" rows that contain simple[m[41m [m
[32m+[m[32m    name/value pairs.[m
[32m+[m[41m    [m
[32m+[m[32m    Each data row contains a name, and value. The row also contains a[m[41m [m
[32m+[m[32m    type or mimetype. Type corresponds to a .NET class that support[m[41m [m
[32m+[m[32m    text/value conversion through the TypeConverter architecture.[m[41m [m
[32m+[m[32m    Classes that don't support this are serialized and stored with the[m[41m [m
[32m+[m[32m    mimetype set.[m
[32m+[m[41m    [m
[32m+[m[32m    The mimetype is used for serialized objects, and tells the[m[41m [m
[32m+[m[32m    ResXResourceReader how to depersist the object. This is currently not[m[41m [m
[32m+[m[32m    extensible. For a given mimetype the value must be set accordingly:[m
[32m+[m[41m    [m
[32m+[m[32m    Note - application/x-microsoft.net.object.binary.base64 is the format[m[41m [m
[32m+[m[32m    that the ResXResourceWriter will generate, however the reader can[m[41m [m
[32m+[m[32m    read any of the formats listed below.[m
[32m+[m[41m    [m
[32m+[m[32m    mimetype: application/x-microsoft.net.object.binary.base64[m
[32m+[m[32m    value   : The object must be serialized with[m[41m [m
[32m+[m[32m            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter[m
[32m+[m[32m            : and then encoded with base64 encoding.[m
[32m+[m[41m    [m
[32m+[m[32m    mimetype: application/x-microsoft.net.object.soap.base64[m
[32m+[m[32m    value   : The object must be serialized with[m[41m [m
[32m+[m[32m            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter[m
[32m+[m[32m            : and then encoded with base64 encoding.[m
[32m+[m
[32m+[m[32m    mimetype: application/x-microsoft.net.object.bytearray.base64[m
[32m+[m[32m    value   : The object must be serialized into a byte array[m[41m [m
[32m+[m[32m            : using a System.ComponentModel.TypeConverter[m
[32m+[m[32m            : and then encoded with base64 encoding.[m
[32m+[m[32m    -->[m
[32m+[m[32m  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">[m
[32m+[m[32m    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />[m
[32m+[m[32m    <xsd:element name="root" msdata:IsDataSet="true">[m
[32m+[m[32m      <xsd:complexType>[m
[32m+[m[32m        <xsd:choice maxOccurs="unbounded">[m
[32m+[m[32m          <xsd:element name="metadata">[m
[32m+[m[32m            <xsd:complexType>[m
[32m+[m[32m              <xsd:sequence>[m
[32m+[m[32m                <xsd:element name="value" type="xsd:string" minOccurs="0" />[m
[32m+[m[32m              </xsd:sequence>[m
[32m+[m[32m              <xsd:attribute name="name" use="required" type="xsd:string" />[m
[32m+[m[32m              <xsd:attribute name="type" type="xsd:string" />[m
[32m+[m[32m              <xsd:attribute name="mimetype" type="xsd:string" />[m
[32m+[m[32m              <xsd:attribute ref="xml:space" />[m
[32m+[m[32m            </xsd:complexType>[m
[32m+[m[32m          </xsd:element>[m
[32m+[m[32m          <xsd:element name="assembly">[m
[32m+[m[32m            <xsd:complexType>[m
[32m+[m[32m              <xsd:attribute name="alias" type="xsd:string" />[m
[32m+[m[32m              <xsd:attribute name="name" type="xsd:string" />[m
[32m+[m[32m            </xsd:complexType>[m
[32m+[m[32m          </xsd:element>[m
[32m+[m[32m          <xsd:element name="data">[m
[32m+[m[32m            <xsd:complexType>[m
[32m+[m[32m              <xsd:sequence>[m
[32m+[m[32m                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />[m
[32m+[m[32m                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />[m
[32m+[m[32m              </xsd:sequence>[m
[32m+[m[32m              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />[m
[32m+[m[32m              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />[m
[32m+[m[32m              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />[m
[32m+[m[32m              <xsd:attribute ref="xml:space" />[m
[32m+[m[32m            </xsd:complexType>[m
[32m+[m[32m          </xsd:element>[m
[32m+[m[32m          <xsd:element name="resheader">[m
[32m+[m[32m            <xsd:complexType>[m
[32m+[m[32m              <xsd:sequence>[m
[32m+[m[32m                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />[m
[32m+[m[32m              </xsd:sequence>[m
[32m+[m[32m              <xsd:attribute name="name" type="xsd:string" use="required" />[m
[32m+[m[32m            </xsd:complexType>[m
[32m+[m[32m          </xsd:element>[m
[32m+[m[32m        </xsd:choice>[m
[32m+[m[32m      </xsd:complexType>[m
[32m+[m[32m    </xsd:element>[m
[32m+[m[32m  </xsd:schema>[m
[32m+[m[32m  <resheader name="resmimetype">[m
[32m+[m[32m    <value>text/microsoft-resx</value>[m
[32m+[m[32m  </resheader>[m
[32m+[m[32m  <resheader name="version">[m
[32m+[m[32m    <value>2.0</value>[m
[32m+[m[32m  </resheader>[m
[32m+[m[32m  <resheader name="reader">[m
[32m+[m[32m    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>[m
[32m+[m[32m  </resheader>[m
[32m+[m[32m  <resheader name="writer">[m
[32m+[m[32m    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>[m
[32m+[m[32m  </resheader>[m
[32m+[m[32m  <data name="AnalyzerDescription" xml:space="preserve">[m
[32m+[m[32m    <value>Type names should be all uppercase.</value>[m
[32m+[m[32m    <comment>An optional longer localizable description of the diagnostic.</comment>[m
[32m+[m[32m  </data>[m
[32m+[m[32m  <data name="AnalyzerMessageFormat" xml:space="preserve">[m
[32m+[m[32m    <value>Type name '{0}' contains lowercase letters</value>[m
[32m+[m[32m    <comment>The format-able message the diagnostic displays.</comment>[m
[32m+[m[32m  </data>[m
[32m+[m[32m  <data name="AnalyzerTitle" xml:space="preserve">[m
[32m+[m[32m    <value>Type name contains lowercase letters</value>[m
[32m+[m[32m    <comment>The title of the diagnostic.</comment>[m
[32m+[m[32m  </data>[m
[32m+[m[32m</root>[m
\ No newline at end of file[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.csproj b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.csproj[m
[1mnew file mode 100644[m
[1mindex 0000000..003b523[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer.csproj[m
[36m@@ -0,0 +1,126 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">[m
[32m+[m[32m  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <MinimumVisualStudioVersion>11.0</MinimumVisualStudioVersion>[m
[32m+[m[32m    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>[m
[32m+[m[32m    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>[m
[32m+[m[32m    <ProjectGuid>{2D370822-C5D4-49BB-ADB5-15916A1AB229}</ProjectGuid>[m
[32m+[m[32m    <OutputType>Library</OutputType>[m
[32m+[m[32m    <AppDesignerFolder>Properties</AppDesignerFolder>[m
[32m+[m[32m    <RootNamespace>SyntaxNodeAnalyzer</RootNamespace>[m
[32m+[m[32m    <AssemblyName>SyntaxNodeAnalyzer</AssemblyName>[m
[32m+[m[32m    <ProjectTypeGuids>{786C830F-07A1-408B-BD7F-6EE04809D6DB};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>[m
[32m+[m[32m    <TargetFrameworkProfile>Profile7</TargetFrameworkProfile>[m
[32m+[m[32m    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">[m
[32m+[m[32m    <DebugSymbols>true</DebugSymbols>[m
[32m+[m[32m    <DebugType>full</DebugType>[m
[32m+[m[32m    <Optimize>false</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Debug\</OutputPath>[m
[32m+[m[32m    <DefineConstants>DEBUG;TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">[m
[32m+[m[32m    <DebugType>pdbonly</DebugType>[m
[32m+[m[32m    <Optimize>true</Optimize>[m
[32m+[m[32m    <OutputPath>bin\Release\</OutputPath>[m
[32m+[m[32m    <DefineConstants>TRACE</DefineConstants>[m
[32m+[m[32m    <ErrorReport>prompt</ErrorReport>[m
[32m+[m[32m    <WarningLevel>4</WarningLevel>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Compile Include="CodeFixProvider.cs" />[m
[32m+[m[32m    <Compile Include="DiagnosticAnalyzer.cs" />[m
[32m+[m[32m    <Compile Include="Properties\AssemblyInfo.cs" />[m
[32m+[m[32m    <Compile Include="Resources.Designer.cs">[m
[32m+[m[32m      <AutoGen>True</AutoGen>[m
[32m+[m[32m      <DesignTime>True</DesignTime>[m
[32m+[m[32m      <DependentUpon>Resources.resx</DependentUpon>[m
[32m+[m[32m    </Compile>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <EmbeddedResource Include="Resources.resx">[m
[32m+[m[32m      <Generator>ResXFileCodeGenerator</Generator>[m
[32m+[m[32m      <LastGenOutput>Resources.Designer.cs</LastGenOutput>[m
[32m+[m[32m    </EmbeddedResource>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <None Include="Diagnostic.nuspec">[m
[32m+[m[32m      <SubType>Designer</SubType>[m
[32m+[m[32m      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>[m
[32m+[m[32m    </None>[m
[32m+[m[32m    <None Include="packages.config" />[m
[32m+[m[32m    <None Include="tools\install.ps1">[m
[32m+[m[32m      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>[m
[32m+[m[32m    </None>[m
[32m+[m[32m    <None Include="tools\uninstall.ps1">[m
[32m+[m[32m      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>[m
[32m+[m[32m    </None>[m
[32m+[m[32m    <None Include="ReadMe.txt" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Analyzer Include="..\..\packages\Microsoft.CodeAnalysis.Analyzers.1.0.0-rc2\tools\analyzers\C#\Microsoft.CodeAnalysis.Analyzers.dll" />[m
[32m+[m[32m    <Analyzer Include="..\..\packages\Microsoft.CodeAnalysis.Analyzers.1.0.0-rc2\tools\analyzers\C#\Microsoft.CodeAnalysis.CSharp.Analyzers.dll" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Common.1.0.0-rc2\lib\portable-net45+win8\Microsoft.CodeAnalysis.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.1.0.0-rc2\lib\portable-net45+win8\Microsoft.CodeAnalysis.CSharp.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.CSharp.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.Workspaces.1.0.0-rc2\lib\portable-net45+win8\Microsoft.CodeAnalysis.CSharp.Workspaces.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="Microsoft.CodeAnalysis.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Workspaces.Common.1.0.0-rc2\lib\portable-net45+win8\Microsoft.CodeAnalysis.Workspaces.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Collections.Immutable, Version=1.1.33.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\System.Collections.Immutable.1.1.33-beta\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.AttributedModel, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.AttributedModel.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Convention, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Convention.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Hosting, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Hosting.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.Runtime, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Runtime.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Composition.TypedParts, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.TypedParts.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m    <Reference Include="System.Reflection.Metadata, Version=1.0.18.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">[m
[32m+[m[32m      <HintPath>..\..\packages\System.Reflection.Metadata.1.0.18-beta\lib\portable-net45+win8\System.Reflection.Metadata.dll</HintPath>[m
[32m+[m[32m      <Private>False</Private>[m
[32m+[m[32m    </Reference>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <Import Project="$(MSBuildExtensionsPath32)\Microsoft\Portable\v4.6\Microsoft.Portable.CSharp.targets" />[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <PostBuildEvent>"$(SolutionDir)\packages\NuGet.CommandLine.2.8.2\tools\NuGet.exe" pack Diagnostic.nuspec -NoPackageAnalysis -OutputDirectory .</PostBuildEvent>[m
[32m+[m[32m    <RunPostBuildEvent>OnOutputUpdated</RunPostBuildEvent>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.[m[41m [m
[32m+[m[32m       Other similar extension points exist, see Microsoft.Common.targets.[m
[32m+[m[32m  <Target Name="BeforeBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  <Target Name="AfterBuild">[m
[32m+[m[32m  </Target>[m
[32m+[m[32m  -->[m
[32m+[m[32m</Project>[m
\ No newline at end of file[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/packages.config b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/packages.config[m
[1mnew file mode 100644[m
[1mindex 0000000..ec9b94c[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/packages.config[m
[36m@@ -0,0 +1,12 @@[m
[32m+[m[32m﻿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<packages>[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.Analyzers" version="1.0.0-rc2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.Common" version="1.0.0-rc2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.CSharp" version="1.0.0-rc2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.CSharp.Workspaces" version="1.0.0-rc2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.CodeAnalysis.Workspaces.Common" version="1.0.0-rc2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="Microsoft.Composition" version="1.0.27" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="NuGet.CommandLine" version="2.8.2" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="System.Collections.Immutable" version="1.1.33-beta" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m  <package id="System.Reflection.Metadata" version="1.0.18-beta" targetFramework="portable45-net45+win8" userInstalled="true" />[m
[32m+[m[32m</packages>[m
\ No newline at end of file[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/tools/install.ps1 b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/tools/install.ps1[m
[1mnew file mode 100644[m
[1mindex 0000000..6a2b94d[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/tools/install.ps1[m
[36m@@ -0,0 +1,24 @@[m
[32m+[m[32m﻿param($installPath, $toolsPath, $package, $project)[m
[32m+[m
[32m+[m[32m$analyzersPath = join-path $toolsPath "analyzers"[m
[32m+[m
[32m+[m[32m# Install the language agnostic analyzers.[m
[32m+[m[32mforeach ($analyzerFilePath in Get-ChildItem $analyzersPath -Filter *.dll)[m
[32m+[m[32m{[m
[32m+[m[32m    if($project.Object.AnalyzerReferences)[m
[32m+[m[32m    {[m
[32m+[m[32m        $project.Object.AnalyzerReferences.Add($analyzerFilePath.FullName)[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m# Install language specific analyzers.[m
[32m+[m[32m# $project.Type gives the language name like (C# or VB.NET)[m
[32m+[m[32m$languageAnalyzersPath = join-path $analyzersPath $project.Type[m
[32m+[m
[32m+[m[32mforeach ($analyzerFilePath in Get-ChildItem $languageAnalyzersPath -Filter *.dll)[m
[32m+[m[32m{[m
[32m+[m[32m    if($project.Object.AnalyzerReferences)[m
[32m+[m[32m    {[m
[32m+[m[32m        $project.Object.AnalyzerReferences.Add($analyzerFilePath.FullName)[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/tools/uninstall.ps1 b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/tools/uninstall.ps1[m
[1mnew file mode 100644[m
[1mindex 0000000..de0016c[m
[1m--- /dev/null[m
[1m+++ b/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/SyntaxNodeAnalyzer/tools/uninstall.ps1[m
[36m@@ -0,0 +1,24 @@[m
[32m+[m[32m﻿param($installPath, $toolsPath, $package, $project)[m
[32m+[m
[32m+[m[32m# Uninstall the language agnostic analyzers.[m
[32m+[m[32m$analyzersPath = join-path $toolsPath "analyzers"[m
[32m+[m
[32m+[m[32mforeach ($analyzerFilePath in Get-ChildItem $analyzersPath -Filter *.dll)[m
[32m+[m[32m{[m
[32m+[m[32m    if($project.Object.AnalyzerReferences)[m
[32m+[m[32m    {[m
[32m+[m[32m        $project.Object.AnalyzerReferences.Remove($analyzerFilePath.FullName)[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m# Uninstall language specific analyzers.[m
[32m+[m[32m# $project.Type gives the language name like (C# or VB.NET)[m
[32m+[m[32m$languageAnalyzersPath = join-path $analyzersPath $project.Type[m
[32m+[m
[32m+[m[32mforeach ($analyzerFilePath in Get-ChildItem $languageAnalyzersPath -Filter *.dll)[m
[32m+[m[32m{[m
[32m+[m[32m    if($project.Object.AnalyzerReferences)[m
[32m+[m[32m    {[m
[32m+[m[32m        $project.Object.AnalyzerReferences.Remove($analyzerFilePath.FullName)[m
[32m+[m[32m    }[m
[32m+[m[32m}[m

[33mcommit 13f3692b8268997cbe1a5964d2ce284c958bbf4d[m
Author: Jared Parsons <jaredpparsons@gmail.com>
Date:   Fri Jun 5 10:48:08 2015 -0700

    Initial commit

[1mdiff --git a/.gitignore b/.gitignore[m
[1mnew file mode 100644[m
[1mindex 0000000..57a1574[m
[1m--- /dev/null[m
[1m+++ b/.gitignore[m
[36m@@ -0,0 +1,196 @@[m
[32m+[m[32m## Ignore Visual Studio temporary files, build results, and[m
[32m+[m[32m## files generated by popular Visual Studio add-ons.[m
[32m+[m
[32m+[m[32m# User-specific files[m
[32m+[m[32m*.suo[m
[32m+[m[32m*.user[m
[32m+[m[32m*.userosscache[m
[32m+[m[32m*.sln.docstates[m
[32m+[m
[32m+[m[32m# User-specific files (MonoDevelop/Xamarin Studio)[m
[32m+[m[32m*.userprefs[m
[32m+[m
[32m+[m[32m# Build results[m
[32m+[m[32m[Dd]ebug/[m
[32m+[m[32m[Dd]ebugPublic/[m
[32m+[m[32m[Rr]elease/[m
[32m+[m[32m[Rr]eleases/[m
[32m+[m[32mx64/[m
[32m+[m[32mx86/[m
[32m+[m[32mbuild/[m
[32m+[m[32mbld/[m
[32m+[m[32m[Bb]in/[m
[32m+[m[32m[Oo]bj/[m
[32m+[m
[32m+[m[32m# Visual Studo 2015 cache/options directory[m
[32m+[m[32m.vs/[m
[32m+[m
[32m+[m[32m# MSTest test Results[m
[32m+[m[32m[Tt]est[Rr]esult*/[m
[32m+[m[32m[Bb]uild[Ll]og.*[m
[32m+[m
[32m+[m[32m# NUNIT[m
[32m+[m[32m*.VisualState.xml[m
[32m+[m[32mTestResult.xml[m
[32m+[m
[32m+[m[32m# Build Results of an ATL Project[m
[32m+[m[32m[Dd]ebugPS/[m
[32m+[m[32m[Rr]eleasePS/[m
[32m+[m[32mdlldata.c[m
[32m+[m
[32m+[m[32m*_i.c[m
[32m+[m[32m*_p.c[m
[32m+[m[32m*_i.h[m
[32m+[m[32m*.ilk[m
[32m+[m[32m*.meta[m
[32m+[m[32m*.obj[m
[32m+[m[32m*.pch[m
[32m+[m[32m*.pdb[m
[32m+[m[32m*.pgc[m
[32m+[m[32m*.pgd[m
[32m+[m[32m*.rsp[m
[32m+[m[32m*.sbr[m
[32m+[m[32m*.tlb[m
[32m+[m[32m*.tli[m
[32m+[m[32m*.tlh[m
[32m+[m[32m*.tmp[m
[32m+[m[32m*.tmp_proj[m
[32m+[m[32m*.log[m
[32m+[m[32m*.vspscc[m
[32m+[m[32m*.vssscc[m
[32m+[m[32m.builds[m
[32m+[m[32m*.pidb[m
[32m+[m[32m*.svclog[m
[32m+[m[32m*.scc[m
[32m+[m
[32m+[m[32m# Chutzpah Test files[m
[32m+[m[32m_Chutzpah*[m
[32m+[m
[32m+[m[32m# Visual C++ cache files[m
[32m+[m[32mipch/[m
[32m+[m[32m*.aps[m
[32m+[m[32m*.ncb[m
[32m+[m[32m*.opensdf[m
[32m+[m[32m*.sdf[m
[32m+[m[32m*.cachefile[m
[32m+[m
[32m+[m[32m# Visual Studio profiler[m
[32m+[m[32m*.psess[m
[32m+[m[32m*.vsp[m
[32m+[m[32m*.vspx[m
[32m+[m
[32m+[m[32m# TFS 2012 Local Workspace[m
[32m+[m[32m$tf/[m
[32m+[m
[32m+[m[32m# Guidance Automation Toolkit[m
[32m+[m[32m*.gpState[m
[32m+[m
[32m+[m[32m# ReSharper is a .NET coding add-in[m
[32m+[m[32m_ReSharper*/[m
[32m+[m[32m*.[Rr]e[Ss]harper[m
[32m+[m[32m*.DotSettings.user[m
[32m+[m
[32m+[m[32m# JustCode is a .NET coding addin-in[m
[32m+[m[32m.JustCode[m
[32m+[m
[32m+[m[32m# TeamCity is a build add-in[m
[32m+[m[32m_TeamCity*[m
[32m+[m
[32m+[m[32m# DotCover is a Code Coverage Tool[m
[32m+[m[32m*.dotCover[m
[32m+[m
[32m+[m[32m# NCrunch[m
[32m+[m[32m_NCrunch_*[m
[32m+[m[32m.*crunch*.local.xml[m
[32m+[m
[32m+[m[32m# MightyMoose[m
[32m+[m[32m*.mm.*[m
[32m+[m[32mAutoTest.Net/[m
[32m+[m
[32m+[m[32m# Web workbench (sass)[m
[32m+[m[32m.sass-cache/[m
[32m+[m
[32m+[m[32m# Installshield output folder[m
[32m+[m[32m[Ee]xpress/[m
[32m+[m
[32m+[m[32m# DocProject is a documentation generator add-in[m
[32m+[m[32mDocProject/buildhelp/[m
[32m+[m[32mDocProject/Help/*.HxT[m
[32m+[m[32mDocProject/Help/*.HxC[m
[32m+[m[32mDocProject/Help/*.hhc[m
[32m+[m[32mDocProject/Help/*.hhk[m
[32m+[m[32mDocProject/Help/*.hhp[m
[32m+[m[32mDocProject/Help/Html2[m
[32m+[m[32mDocProject/Help/html[m
[32m+[m
[32m+[m[32m# Click-Once directory[m
[32m+[m[32mpublish/[m
[32m+[m
[32m+[m[32m# Publish Web Output[m
[32m+[m[32m*.[Pp]ublish.xml[m
[32m+[m[32m*.azurePubxml[m
[32m+[m[32m# TODO: Comment the next line if you want to checkin your web deploy settings[m[41m [m
[32m+[m[32m# but database connection strings (with potential passwords) will be unencrypted[m
[32m+[m[32m*.pubxml[m
[32m+[m[32m*.publishproj[m
[32m+[m
[32m+[m[32m# NuGet Packages[m
[32m+[m[32m*.nupkg[m
[32m+[m[32m# The packages folder can be ignored because of Package Restore[m
[32m+[m[32m**/packages/*[m
[32m+[m[32m# except build/, which is used as an MSBuild target.[m
[32m+[m[32m!**/packages/build/[m
[32m+[m[32m# Uncomment if necessary however generally it will be regenerated when needed[m
[32m+[m[32m#!**/packages/repositories.config[m
[32m+[m
[32m+[m[32m# Windows Azure Build Output[m
[32m+[m[32mcsx/[m
[32m+[m[32m*.build.csdef[m
[32m+[m
[32m+[m[32m# Windows Store app package directory[m
[32m+[m[32mAppPackages/[m
[32m+[m
[32m+[m[32m# Others[m
[32m+[m[32m*.[Cc]ache[m
[32m+[m[32mClientBin/[m
[32m+[m[32m[Ss]tyle[Cc]op.*[m
[32m+[m[32m~$*[m
[32m+[m[32m*~[m
[32m+[m[32m*.dbmdl[m
[32m+[m[32m*.dbproj.schemaview[m
[32m+[m[32m*.pfx[m
[32m+[m[32m*.publishsettings[m
[32m+[m[32mnode_modules/[m
[32m+[m[32mbower_components/[m
[32m+[m
[32m+[m[32m# RIA/Silverlight projects[m
[32m+[m[32mGenerated_Code/[m
[32m+[m
[32m+[m[32m# Backup & report files from converting an old project file[m
[32m+[m[32m# to a newer Visual Studio version. Backup files are not needed,[m
[32m+[m[32m# because we have git ;-)[m
[32m+[m[32m_UpgradeReport_Files/[m
[32m+[m[32mBackup*/[m
[32m+[m[32mUpgradeLog*.XML[m
[32m+[m[32mUpgradeLog*.htm[m
[32m+[m
[32m+[m[32m# SQL Server files[m
[32m+[m[32m*.mdf[m
[32m+[m[32m*.ldf[m
[32m+[m
[32m+[m[32m# Business Intelligence projects[m
[32m+[m[32m*.rdl.data[m
[32m+[m[32m*.bim.layout[m
[32m+[m[32m*.bim_*.settings[m
[32m+[m
[32m+[m[32m# Microsoft Fakes[m
[32m+[m[32mFakesAssemblies/[m
[32m+[m
[32m+[m[32m# Node.js Tools for Visual Studio[m
[32m+[m[32m.ntvs_analysis.dat[m
[32m+[m
[32m+[m[32m# Visual Studio 6 build log[m
[32m+[m[32m*.plg[m
[32m+[m
[32m+[m[32m# Visual Studio 6 workspace options file[m
[32m+[m[32m*.opt[m
[1mdiff --git a/LICENSE b/LICENSE[m
[1mnew file mode 100644[m
[1mindex 0000000..8f71f43[m
[1m--- /dev/null[m
[1m+++ b/LICENSE[m
[36m@@ -0,0 +1,202 @@[m
[32m+[m[32m                                 Apache License[m
[32m+[m[32m                           Version 2.0, January 2004[m
[32m+[m[32m                        http://www.apache.org/licenses/[m
[32m+[m
[32m+[m[32m   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION[m
[32m+[m
[32m+[m[32m   1. Definitions.[m
[32m+[m
[32m+[m[32m      "License" shall mean the terms and conditions for use, reproduction,[m
[32m+[m[32m      and distribution as defined by Sections 1 through 9 of this document.[m
[32m+[m
[32m+[m[32m      "Licensor" shall mean the copyright owner or entity authorized by[m
[32m+[m[32m      the copyright owner that is granting the License.[m
[32m+[m
[32m+[m[32m      "Legal Entity" shall mean the union of the acting entity and all[m
[32m+[m[32m      other entities that control, are controlled by, or are under common[m
[32m+[m[32m      control with that entity. For the purposes of this definition,[m
[32m+[m[32m      "control" means (i) the power, direct or indirect, to cause the[m
[32m+[m[32m      direction or management of such entity, whether by contract or[m
[32m+[m[32m      otherwise, or (ii) ownership of fifty percent (50%) or more of the[m
[32m+[m[32m      outstanding shares, or (iii) beneficial ownership of such entity.[m
[32m+[m
[32m+[m[32m      "You" (or "Your") shall mean an individual or Legal Entity[m
[32m+[m[32m      exercising permissions granted by this License.[m
[32m+[m
[32m+[m[32m      "Source" form shall mean the preferred form for making modifications,[m
[32m+[m[32m      including but not limited to software source code, documentation[m
[32m+[m[32m      source, and configuration files.[m
[32m+[m
[32m+[m[32m      "Object" form shall mean any form resulting from mechanical[m
[32m+[m[32m      transformation or translation of a Source form, including but[m
[32m+[m[32m      not limited to compiled object code, generated documentation,[m
[32m+[m[32m      and conversions to other media types.[m
[32m+[m
[32m+[m[32m      "Work" shall mean the work of authorship, whether in Source or[m
[32m+[m[32m      Object form, made available under the License, as indicated by a[m
[32m+[m[32m      copyright notice that is included in or attached to the work[m
[32m+[m[32m      (an example is provided in the Appendix below).[m
[32m+[m
[32m+[m[32m      "Derivative Works" shall mean any work, whether in Source or Object[m
[32m+[m[32m      form, that is based on (or derived from) the Work and for which the[m
[32m+[m[32m      editorial revisions, annotations, elaborations, or other modifications[m
[32m+[m[32m      represent, as a whole, an original work of authorship. For the purposes[m
[32m+[m[32m      of this License, Derivative Works shall not include works that remain[m
[32m+[m[32m      separable from, or merely link (or bind by name) to the interfaces of,[m
[32m+[m[32m      the Work and Derivative Works thereof.[m
[32m+[m
[32m+[m[32m      "Contribution" shall mean any work of authorship, including[m
[32m+[m[32m      the original version of the Work and any modifications or additions[m
[32m+[m[32m      to that Work or Derivative Works thereof, that is intentionally[m
[32m+[m[32m      submitted to Licensor for inclusion in the Work by the copyright owner[m
[32m+[m[32m      or by an individual or Legal Entity authorized to submit on behalf of[m
[32m+[m[32m      the copyright owner. For the purposes of this definition, "submitted"[m
[32m+[m[32m      means any form of electronic, verbal, or written communication sent[m
[32m+[m[32m      to the Licensor or its representatives, including but not limited to[m
[32m+[m[32m      communication on electronic mailing lists, source code control systems,[m
[32m+[m[32m      and issue tracking systems that are managed by, or on behalf of, the[m
[32m+[m[32m      Licensor for the purpose of discussing and improving the Work, but[m
[32m+[m[32m      excluding communication that is conspicuously marked or otherwise[m
[32m+[m[32m      designated in writing by the copyright owner as "Not a Contribution."[m
[32m+[m
[32m+[m[32m      "Contributor" shall mean Licensor and any individual or Legal Entity[m
[32m+[m[32m      on behalf of whom a Contribution has been received by Licensor and[m
[32m+[m[32m      subsequently incorporated within the Work.[m
[32m+[m
[32m+[m[32m   2. Grant of Copyright License. Subject to the terms and conditions of[m
[32m+[m[32m      this License, each Contributor hereby grants to You a perpetual,[m
[32m+[m[32m      worldwide, non-exclusive, no-charge, royalty-free, irrevocable[m
[32m+[m[32m      copyright license to reproduce, prepare Derivative Works of,[m
[32m+[m[32m      publicly display, publicly perform, sublicense, and distribute the[m
[32m+[m[32m      Work and such Derivative Works in Source or Object form.[m
[32m+[m
[32m+[m[32m   3. Grant of Patent License. Subject to the terms and conditions of[m
[32m+[m[32m      this License, each Contributor hereby grants to You a perpetual,[m
[32m+[m[32m      worldwide, non-exclusive, no-charge, royalty-free, irrevocable[m
[32m+[m[32m      (except as stated in this section) patent license to make, have made,[m
[32m+[m[32m      use, offer to sell, sell, import, and otherwise transfer the Work,[m
[32m+[m[32m      where such license applies only to those patent claims licensable[m
[32m+[m[32m      by such Contributor that are necessarily infringed by their[m
[32m+[m[32m      Contribution(s) alone or by combination of their Contribution(s)[m
[32m+[m[32m      with the Work to which such Contribution(s) was submitted. If You[m
[32m+[m[32m      institute patent litigation against any entity (including a[m
[32m+[m[32m      cross-claim or counterclaim in a lawsuit) alleging that the Work[m
[32m+[m[32m      or a Contribution incorporated within the Work constitutes direct[m
[32m+[m[32m      or contributory patent infringement, then any patent licenses[m
[32m+[m[32m      granted to You under this License for that Work shall terminate[m
[32m+[m[32m      as of the date such litigation is filed.[m
[32m+[m
[32m+[m[32m   4. Redistribution. You may reproduce and distribute copies of the[m
[32m+[m[32m      Work or Derivative Works thereof in any medium, with or without[m
[32m+[m[32m      modifications, and in Source or Object form, provided that You[m
[32m+[m[32m      meet the following conditions:[m
[32m+[m
[32m+[m[32m      (a) You must give any other recipients of the Work or[m
[32m+[m[32m          Derivative Works a copy of this License; and[m
[32m+[m
[32m+[m[32m      (b) You must cause any modified files to carry prominent notices[m
[32m+[m[32m          stating that You changed the files; and[m
[32m+[m
[32m+[m[32m      (c) You must retain, in the Source form of any Derivative Works[m
[32m+[m[32m          that You distribute, all copyright, patent, trademark, and[m
[32m+[m[32m          attribution notices from the Source form of the Work,[m
[32m+[m[32m          excluding those notices that do not pertain to any part of[m
[32m+[m[32m          the Derivative Works; and[m
[32m+[m
[32m+[m[32m      (d) If the Work includes a "NOTICE" text file as part of its[m
[32m+[m[32m          distribution, then any Derivative Works that You distribute must[m
[32m+[m[32m          include a readable copy of the attribution notices contained[m
[32m+[m[32m          within such NOTICE file, excluding those notices that do not[m
[32m+[m[32m          pertain to any part of the Derivative Works, in at least one[m
[32m+[m[32m          of the following places: within a NOTICE text file distributed[m
[32m+[m[32m          as part of the Derivative Works; within the Source form or[m
[32m+[m[32m          documentation, if provided along with the Derivative Works; or,[m
[32m+[m[32m          within a display generated by the Derivative Works, if and[m
[32m+[m[32m          wherever such third-party notices normally appear. The contents[m
[32m+[m[32m          of the NOTICE file are for informational purposes only and[m
[32m+[m[32m          do not modify the License. You may add Your own attribution[m
[32m+[m[32m          notices within Derivative Works that You distribute, alongside[m
[32m+[m[32m          or as an addendum to the NOTICE text from the Work, provided[m
[32m+[m[32m          that such additional attribution notices cannot be construed[m
[32m+[m[32m          as modifying the License.[m
[32m+[m
[32m+[m[32m      You may add Your own copyright statement to Your modifications and[m
[32m+[m[32m      may provide additional or different license terms and conditions[m
[32m+[m[32m      for use, reproduction, or distribution of Your modifications, or[m
[32m+[m[32m      for any such Derivative Works as a whole, provided Your use,[m
[32m+[m[32m      reproduction, and distribution of the Work otherwise complies with[m
[32m+[m[32m      the conditions stated in this License.[m
[32m+[m
[32m+[m[32m   5. Submission of Contributions. Unless You explicitly state otherwise,[m
[32m+[m[32m      any Contribution intentionally submitted for inclusion in the Work[m
[32m+[m[32m      by You to the Licensor shall be under the terms and conditions of[m
[32m+[m[32m      this License, without any additional terms or conditions.[m
[32m+[m[32m      Notwithstanding the above, nothing herein shall supersede or modify[m
[32m+[m[32m      the terms of any separate license agreement you may have executed[m
[32m+[m[32m      with Licensor regarding such Contributions.[m
[32m+[m
[32m+[m[32m   6. Trademarks. This License does not grant permission to use the trade[m
[32m+[m[32m      names, trademarks, service marks, or product names of the Licensor,[m
[32m+[m[32m      except as required for reasonable and customary use in describing the[m
[32m+[m[32m      origin of the Work and reproducing the content of the NOTICE file.[m
[32m+[m
[32m+[m[32m   7. Disclaimer of Warranty. Unless required by applicable law or[m
[32m+[m[32m      agreed to in writing, Licensor provides the Work (and each[m
[32m+[m[32m      Contributor provides its Contributions) on an "AS IS" BASIS,[m
[32m+[m[32m      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or[m
[32m+[m[32m      implied, including, without limitation, any warranties or conditions[m
[32m+[m[32m      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A[m
[32m+[m[32m      PARTICULAR PURPOSE. You are solely responsible for determining the[m
[32m+[m[32m      appropriateness of using or redistributing the Work and assume any[m
[32m+[m[32m      risks associated with Your exercise of permissions under this License.[m
[32m+[m
[32m+[m[32m   8. Limitation of Liability. In no event and under no legal theory,[m
[32m+[m[32m      whether in tort (including negligence), contract, or otherwise,[m
[32m+[m[32m      unless required by applicable law (such as deliberate and grossly[m
[32m+[m[32m      negligent acts) or agreed to in writing, shall any Contributor be[m
[32m+[m[32m      liable to You for damages, including any direct, indirect, special,[m
[32m+[m[32m      incidental, or consequential damages of any character arising as a[m
[32m+[m[32m      result of this License or out of the use or inability to use the[m
[32m+[m[32m      Work (including but not limited to damages for loss of goodwill,[m
[32m+[m[32m      work stoppage, computer failure or malfunction, or any and all[m
[32m+[m[32m      other commercial damages or losses), even if such Contributor[m
[32m+[m[32m      has been advised of the possibility of such damages.[m
[32m+[m
[32m+[m[32m   9. Accepting Warranty or Additional Liability. While redistributing[m
[32m+[m[32m      the Work or Derivative Works thereof, You may choose to offer,[m
[32m+[m[32m      and charge a fee for, acceptance of support, warranty, indemnity,[m
[32m+[m[32m      or other liability obligations and/or rights consistent with this[m
[32m+[m[32m      License. However, in accepting such obligations, You may act only[m
[32m+[m[32m      on Your own behalf and on Your sole responsibility, not on behalf[m
[32m+[m[32m      of any other Contributor, and only if You agree to indemnify,[m
[32m+[m[32m      defend, and hold each Contributor harmless for any liability[m
[32m+[m[32m      incurred by, or claims asserted against, such Contributor by reason[m
[32m+[m[32m      of your accepting any such warranty or additional liability.[m
[32m+[m
[32m+[m[32m   END OF TERMS AND CONDITIONS[m
[32m+[m
[32m+[m[32m   APPENDIX: How to apply the Apache License to your work.[m
[32m+[m
[32m+[m[32m      To apply the Apache License to your work, attach the following[m
[32m+[m[32m      boilerplate notice, with the fields enclosed by brackets "{}"[m
[32m+[m[32m      replaced with your own identifying information. (Don't include[m
[32m+[m[32m      the brackets!)  The text should be enclosed in the appropriate[m
[32m+[m[32m      comment syntax for the file format. We also recommend that a[m
[32m+[m[32m      file or class name and description of purpose be included on the[m
[32m+[m[32m      same "printed page" as the copyright notice for easier[m
[32m+[m[32m      identification within third-party archives.[m
[32m+[m
[32m+[m[32m   Copyright {yyyy} {name of copyright owner}[m
[32m+[m
[32m+[m[32m   Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m   you may not use this file except in compliance with the License.[m
[32m+[m[32m   You may obtain a copy of the License at[m
[32m+[m
[32m+[m[32m       http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m
[32m+[m[32m   Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m   distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m   See the License for the specific language governing permissions and[m
[32m+[m[32m   limitations under the License.[m
[32m+[m
